# # DO NOT EDIT THIS FILE!
# #
# # This file is generated from the CDP specification using AST. If you need to make
# # changes, edit the generator and regenerate all of the modules.

from __future__ import annotations
"""CDP domain: Animation (experimental)"""
import typing
import enum
from dataclasses import dataclass
from .util import T_JSON_DICT, event_class
from . import dom
from . import runtime
None


@dataclass
class Animation:
    """Animation instance."""
    id_: str
    name: str
    paused_state: bool
    play_state: str
    playback_rate: float
    start_time: float
    current_time: float
    type_: str
    source: typing.Optional[AnimationEffect] = None
    css_id: typing.Optional[str] = None
    view_or_scroll_timeline: typing.Optional[ViewOrScrollTimeline] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['id'] = self.id_
        json_data['name'] = self.name
        json_data['pausedState'] = self.paused_state
        json_data['playState'] = self.play_state
        json_data['playbackRate'] = self.playback_rate
        json_data['startTime'] = self.start_time
        json_data['currentTime'] = self.current_time
        json_data['type'] = self.type_
        if self.source is not None:
            json_data['source'] = self.source.to_json()
        if self.css_id is not None:
            json_data['cssId'] = self.css_id
        if self.view_or_scroll_timeline is not None:
            json_data['viewOrScrollTimeline'
                ] = self.view_or_scroll_timeline.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->Animation:
        return cls(id_=json_obj['id'], name=json_obj['name'], paused_state=
            json_obj['pausedState'], play_state=json_obj['playState'],
            playback_rate=json_obj['playbackRate'], start_time=json_obj[
            'startTime'], current_time=json_obj['currentTime'], type_=
            json_obj['type'], source=AnimationEffect.from_json(json_obj[
            'source']) if json_obj.get('source') is not None else None,
            css_id=json_obj['cssId'] if json_obj.get('cssId') is not None else
            None, view_or_scroll_timeline=ViewOrScrollTimeline.from_json(
            json_obj['viewOrScrollTimeline']) if json_obj.get(
            'viewOrScrollTimeline') is not None else None)


@dataclass
class AnimationEffect:
    """AnimationEffect instance"""
    delay: float
    end_delay: float
    iteration_start: float
    iterations: float
    duration: float
    direction: str
    fill: str
    easing: str
    backend_node_id: typing.Optional[dom.BackendNodeId] = None
    keyframes_rule: typing.Optional[KeyframesRule] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['delay'] = self.delay
        json_data['endDelay'] = self.end_delay
        json_data['iterationStart'] = self.iteration_start
        json_data['iterations'] = self.iterations
        json_data['duration'] = self.duration
        json_data['direction'] = self.direction
        json_data['fill'] = self.fill
        json_data['easing'] = self.easing
        if self.backend_node_id is not None:
            json_data['backendNodeId'] = self.backend_node_id.to_json()
        if self.keyframes_rule is not None:
            json_data['keyframesRule'] = self.keyframes_rule.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->AnimationEffect:
        return cls(delay=json_obj['delay'], end_delay=json_obj['endDelay'],
            iteration_start=json_obj['iterationStart'], iterations=json_obj
            ['iterations'], duration=json_obj['duration'], direction=
            json_obj['direction'], fill=json_obj['fill'], easing=json_obj[
            'easing'], backend_node_id=dom.BackendNodeId.from_json(json_obj
            ['backendNodeId']) if json_obj.get('backendNodeId') is not None
             else None, keyframes_rule=KeyframesRule.from_json(json_obj[
            'keyframesRule']) if json_obj.get('keyframesRule') is not None else
            None)


@dataclass
class KeyframeStyle:
    """Keyframe Style"""
    offset: str
    easing: str

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['offset'] = self.offset
        json_data['easing'] = self.easing
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->KeyframeStyle:
        return cls(offset=json_obj['offset'], easing=json_obj['easing'])


@dataclass
class KeyframesRule:
    """Keyframes Rule"""
    keyframes: typing.List[KeyframeStyle]
    name: typing.Optional[str] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['keyframes'] = [i.to_json() for i in self.keyframes]
        if self.name is not None:
            json_data['name'] = self.name
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->KeyframesRule:
        return cls(keyframes=[KeyframeStyle.from_json(i) for i in json_obj[
            'keyframes']], name=json_obj['name'] if json_obj.get('name') is not
            None else None)


@dataclass
class ViewOrScrollTimeline:
    """Timeline instance"""
    axis: dom.ScrollOrientation
    source_node_id: typing.Optional[dom.BackendNodeId] = None
    start_offset: typing.Optional[float] = None
    end_offset: typing.Optional[float] = None
    subject_node_id: typing.Optional[dom.BackendNodeId] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['axis'] = self.axis.to_json()
        if self.source_node_id is not None:
            json_data['sourceNodeId'] = self.source_node_id.to_json()
        if self.start_offset is not None:
            json_data['startOffset'] = self.start_offset
        if self.end_offset is not None:
            json_data['endOffset'] = self.end_offset
        if self.subject_node_id is not None:
            json_data['subjectNodeId'] = self.subject_node_id.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->ViewOrScrollTimeline:
        return cls(axis=dom.ScrollOrientation.from_json(json_obj['axis']),
            source_node_id=dom.BackendNodeId.from_json(json_obj[
            'sourceNodeId']) if json_obj.get('sourceNodeId') is not None else
            None, start_offset=json_obj['startOffset'] if json_obj.get(
            'startOffset') is not None else None, end_offset=json_obj[
            'endOffset'] if json_obj.get('endOffset') is not None else None,
            subject_node_id=dom.BackendNodeId.from_json(json_obj[
            'subjectNodeId']) if json_obj.get('subjectNodeId') is not None else
            None)


def disable() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Disables animation domain notifications."""
    cmd_dict = {'method': 'Animation.disable'}
    json_result = yield cmd_dict
    return None


def enable() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Enables animation domain notifications."""
    cmd_dict = {'method': 'Animation.enable'}
    json_result = yield cmd_dict
    return None


def get_current_time(id_: str) ->typing.Generator[T_JSON_DICT, T_JSON_DICT,
    float]:
    """Returns the current time of the an animation.

:param ...:

:param id_: Id of animation.


:returns: Current time of the page."""
    params_dict: T_JSON_DICT = dict()
    params_dict['id'] = id_
    cmd_dict = {'method': 'Animation.getCurrentTime', 'params': params_dict}
    json_result = yield cmd_dict
    return json_result['currentTime']


def get_playback_rate() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, float]:
    """Gets the playback rate of the document timeline.


:returns: Playback rate for animations on page."""
    cmd_dict = {'method': 'Animation.getPlaybackRate'}
    json_result = yield cmd_dict
    return json_result['playbackRate']


def release_animations(animations: typing.List[str]) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, None]:
    """Releases a set of animations to no longer be manipulated.

:param ...:

:param animations: List of animation ids to seek."""
    params_dict: T_JSON_DICT = dict()
    params_dict['animations'] = [i for i in animations]
    cmd_dict = {'method': 'Animation.releaseAnimations', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def resolve_animation(animation_id: str) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, runtime.RemoteObject]:
    """Gets the remote object of the Animation.

:param ...:

:param animation_id: Animation id.


:returns: Corresponding remote object."""
    params_dict: T_JSON_DICT = dict()
    params_dict['animationId'] = animation_id
    cmd_dict = {'method': 'Animation.resolveAnimation', 'params': params_dict}
    json_result = yield cmd_dict
    return runtime.RemoteObject.from_json(json_result['remoteObject'])


def seek_animations(animations: typing.List[str], current_time: float
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Seek a set of animations to a particular time within each animation.

:param ...:

:param animations: List of animation ids to seek.

:param current_time: Set the current time of each animation."""
    params_dict: T_JSON_DICT = dict()
    params_dict['animations'] = [i for i in animations]
    params_dict['currentTime'] = current_time
    cmd_dict = {'method': 'Animation.seekAnimations', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def set_paused(animations: typing.List[str], paused: bool) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, None]:
    """Sets the paused state of a set of animations.

:param ...:

:param animations: Animations to set the pause state of.

:param paused: Paused state to set to."""
    params_dict: T_JSON_DICT = dict()
    params_dict['animations'] = [i for i in animations]
    params_dict['paused'] = paused
    cmd_dict = {'method': 'Animation.setPaused', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def set_playback_rate(playback_rate: float) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, None]:
    """Sets the playback rate of the document timeline.

:param ...:

:param playback_rate: Playback rate for animations on page"""
    params_dict: T_JSON_DICT = dict()
    params_dict['playbackRate'] = playback_rate
    cmd_dict = {'method': 'Animation.setPlaybackRate', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def set_timing(animation_id: str, duration: float, delay: float
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Sets the timing of an animation node.

:param ...:

:param animation_id: Animation id.

:param duration: Duration of the animation.

:param delay: Delay of the animation."""
    params_dict: T_JSON_DICT = dict()
    params_dict['animationId'] = animation_id
    params_dict['duration'] = duration
    params_dict['delay'] = delay
    cmd_dict = {'method': 'Animation.setTiming', 'params': params_dict}
    json_result = yield cmd_dict
    return None


@event_class('Animation.animationCanceled')
@dataclass
class AnimationCanceled:
    """Event for when an animation has been cancelled."""
    id_: str

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->AnimationCanceled:
        return cls(id_=json_obj['id'])


@event_class('Animation.animationCreated')
@dataclass
class AnimationCreated:
    """Event for each animation that has been created."""
    id_: str

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->AnimationCreated:
        return cls(id_=json_obj['id'])


@event_class('Animation.animationStarted')
@dataclass
class AnimationStarted:
    """Event for animation that has been started."""
    animation: Animation

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->AnimationStarted:
        return cls(animation=Animation.from_json(json_obj['animation']))


@event_class('Animation.animationUpdated')
@dataclass
class AnimationUpdated:
    """Event for animation that has been updated."""
    animation: Animation

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->AnimationUpdated:
        return cls(animation=Animation.from_json(json_obj['animation']))
