# # DO NOT EDIT THIS FILE!
# #
# # This file is generated from the CDP specification using AST. If you need to make
# # changes, edit the generator and regenerate all of the modules.

from __future__ import annotations
"""CDP domain: BluetoothEmulation (experimental)

This domain allows configuring virtual Bluetooth devices to test
the web-bluetooth API."""
import typing
import enum
from dataclasses import dataclass
from .util import T_JSON_DICT, event_class
None


@dataclass
class CharacteristicProperties:
    """Describes the properties of a characteristic. This follows Bluetooth Core
Specification BT 4.2 Vol 3 Part G 3.3.1. Characteristic Properties."""
    broadcast: typing.Optional[bool] = None
    read: typing.Optional[bool] = None
    write_without_response: typing.Optional[bool] = None
    write: typing.Optional[bool] = None
    notify: typing.Optional[bool] = None
    indicate: typing.Optional[bool] = None
    authenticated_signed_writes: typing.Optional[bool] = None
    extended_properties: typing.Optional[bool] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        if self.broadcast is not None:
            json_data['broadcast'] = self.broadcast
        if self.read is not None:
            json_data['read'] = self.read
        if self.write_without_response is not None:
            json_data['writeWithoutResponse'] = self.write_without_response
        if self.write is not None:
            json_data['write'] = self.write
        if self.notify is not None:
            json_data['notify'] = self.notify
        if self.indicate is not None:
            json_data['indicate'] = self.indicate
        if self.authenticated_signed_writes is not None:
            json_data['authenticatedSignedWrites'
                ] = self.authenticated_signed_writes
        if self.extended_properties is not None:
            json_data['extendedProperties'] = self.extended_properties
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->CharacteristicProperties:
        return cls(broadcast=json_obj['broadcast'] if json_obj.get(
            'broadcast') is not None else None, read=json_obj['read'] if 
            json_obj.get('read') is not None else None,
            write_without_response=json_obj['writeWithoutResponse'] if 
            json_obj.get('writeWithoutResponse') is not None else None,
            write=json_obj['write'] if json_obj.get('write') is not None else
            None, notify=json_obj['notify'] if json_obj.get('notify') is not
            None else None, indicate=json_obj['indicate'] if json_obj.get(
            'indicate') is not None else None, authenticated_signed_writes=
            json_obj['authenticatedSignedWrites'] if json_obj.get(
            'authenticatedSignedWrites') is not None else None,
            extended_properties=json_obj['extendedProperties'] if json_obj.
            get('extendedProperties') is not None else None)


@dataclass
class ManufacturerData:
    """Stores the manufacturer data"""
    key: int
    data: str

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['key'] = self.key
        json_data['data'] = self.data
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->ManufacturerData:
        return cls(key=json_obj['key'], data=json_obj['data'])


@dataclass
class ScanEntry:
    """Stores the advertisement packet information that is sent by a Bluetooth device."""
    device_address: str
    rssi: int
    scan_record: ScanRecord

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['deviceAddress'] = self.device_address
        json_data['rssi'] = self.rssi
        json_data['scanRecord'] = self.scan_record.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->ScanEntry:
        return cls(device_address=json_obj['deviceAddress'], rssi=json_obj[
            'rssi'], scan_record=ScanRecord.from_json(json_obj['scanRecord']))


@dataclass
class ScanRecord:
    """Stores the byte data of the advertisement packet sent by a Bluetooth device."""
    name: typing.Optional[str] = None
    uuids: typing.Optional[typing.List[str]] = None
    appearance: typing.Optional[int] = None
    tx_power: typing.Optional[int] = None
    manufacturer_data: typing.Optional[typing.List[ManufacturerData]] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        if self.name is not None:
            json_data['name'] = self.name
        if self.uuids is not None:
            json_data['uuids'] = [i for i in self.uuids]
        if self.appearance is not None:
            json_data['appearance'] = self.appearance
        if self.tx_power is not None:
            json_data['txPower'] = self.tx_power
        if self.manufacturer_data is not None:
            json_data['manufacturerData'] = [i.to_json() for i in self.
                manufacturer_data]
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->ScanRecord:
        return cls(name=json_obj['name'] if json_obj.get('name') is not
            None else None, uuids=[i for i in json_obj['uuids']] if 
            json_obj.get('uuids') is not None else None, appearance=
            json_obj['appearance'] if json_obj.get('appearance') is not
            None else None, tx_power=json_obj['txPower'] if json_obj.get(
            'txPower') is not None else None, manufacturer_data=[
            ManufacturerData.from_json(i) for i in json_obj[
            'manufacturerData']] if json_obj.get('manufacturerData') is not
            None else None)


class CentralState(enum.Enum):
    """Indicates the various states of Central."""
    ABSENT = 'absent'
    POWERED_OFF = 'powered-off'
    POWERED_ON = 'powered-on'

    @classmethod
    def from_json(cls, json: str) ->CentralState:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<CentralState.{}>'.format(self.value)


class GATTOperationType(enum.Enum):
    """Indicates the various types of GATT event."""
    CONNECTION = 'connection'
    DISCOVERY = 'discovery'

    @classmethod
    def from_json(cls, json: str) ->GATTOperationType:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<GATTOperationType.{}>'.format(self.value)


def add_characteristic(service_id: str, characteristic_uuid: str,
    properties: CharacteristicProperties) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, str]:
    """Adds a characteristic with |characteristicUuid| and |properties| to the
service represented by |serviceId|.

:param ...:

:param service_id:

:param characteristic_uuid:

:param properties:


:returns: An identifier that uniquely represents this characteristic."""
    params_dict: T_JSON_DICT = dict()
    params_dict['serviceId'] = service_id
    params_dict['characteristicUuid'] = characteristic_uuid
    params_dict['properties'] = properties.to_json()
    cmd_dict = {'method': 'BluetoothEmulation.addCharacteristic', 'params':
        params_dict}
    json_result = yield cmd_dict
    return json_result['characteristicId']


def add_descriptor(characteristic_id: str, descriptor_uuid: str
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """Adds a descriptor with |descriptorUuid| to the characteristic respresented
by |characteristicId|.

:param ...:

:param characteristic_id:

:param descriptor_uuid:


:returns: An identifier that uniquely represents this descriptor."""
    params_dict: T_JSON_DICT = dict()
    params_dict['characteristicId'] = characteristic_id
    params_dict['descriptorUuid'] = descriptor_uuid
    cmd_dict = {'method': 'BluetoothEmulation.addDescriptor', 'params':
        params_dict}
    json_result = yield cmd_dict
    return json_result['descriptorId']


def add_service(address: str, service_uuid: str) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, str]:
    """Adds a service with |serviceUuid| to the peripheral with |address|.

:param ...:

:param address:

:param service_uuid:


:returns: An identifier that uniquely represents this service."""
    params_dict: T_JSON_DICT = dict()
    params_dict['address'] = address
    params_dict['serviceUuid'] = service_uuid
    cmd_dict = {'method': 'BluetoothEmulation.addService', 'params':
        params_dict}
    json_result = yield cmd_dict
    return json_result['serviceId']


def disable() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Disable the BluetoothEmulation domain."""
    cmd_dict = {'method': 'BluetoothEmulation.disable'}
    json_result = yield cmd_dict
    return None


def enable(state: CentralState, le_supported: bool) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, None]:
    """Enable the BluetoothEmulation domain.

:param ...:

:param state: State of the simulated central.

:param le_supported: If the simulated central supports low-energy."""
    params_dict: T_JSON_DICT = dict()
    params_dict['state'] = state.to_json()
    params_dict['leSupported'] = le_supported
    cmd_dict = {'method': 'BluetoothEmulation.enable', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def remove_characteristic(characteristic_id: str) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, None]:
    """Removes the characteristic respresented by |characteristicId| from the
simulated central.

:param ...:

:param characteristic_id:"""
    params_dict: T_JSON_DICT = dict()
    params_dict['characteristicId'] = characteristic_id
    cmd_dict = {'method': 'BluetoothEmulation.removeCharacteristic',
        'params': params_dict}
    json_result = yield cmd_dict
    return None


def remove_descriptor(descriptor_id: str) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, None]:
    """Removes the descriptor with |descriptorId| from the simulated central.

:param ...:

:param descriptor_id:"""
    params_dict: T_JSON_DICT = dict()
    params_dict['descriptorId'] = descriptor_id
    cmd_dict = {'method': 'BluetoothEmulation.removeDescriptor', 'params':
        params_dict}
    json_result = yield cmd_dict
    return None


def remove_service(service_id: str) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, None]:
    """Removes the service respresented by |serviceId| from the simulated central.

:param ...:

:param service_id:"""
    params_dict: T_JSON_DICT = dict()
    params_dict['serviceId'] = service_id
    cmd_dict = {'method': 'BluetoothEmulation.removeService', 'params':
        params_dict}
    json_result = yield cmd_dict
    return None


def set_simulated_central_state(state: CentralState) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, None]:
    """Set the state of the simulated central.

:param ...:

:param state: State of the simulated central."""
    params_dict: T_JSON_DICT = dict()
    params_dict['state'] = state.to_json()
    cmd_dict = {'method': 'BluetoothEmulation.setSimulatedCentralState',
        'params': params_dict}
    json_result = yield cmd_dict
    return None


def simulate_advertisement(entry: ScanEntry) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, None]:
    """Simulates an advertisement packet described in |entry| being received by
the central.

:param ...:

:param entry:"""
    params_dict: T_JSON_DICT = dict()
    params_dict['entry'] = entry.to_json()
    cmd_dict = {'method': 'BluetoothEmulation.simulateAdvertisement',
        'params': params_dict}
    json_result = yield cmd_dict
    return None


def simulate_gatt_operation_response(address: str, type_: GATTOperationType,
    code: int) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Simulates the response code from the peripheral with |address| for a
GATT operation of |type|. The |code| value follows the HCI Error Codes from
Bluetooth Core Specification Vol 2 Part D 1.3 List Of Error Codes.

:param ...:

:param address:

:param type_:

:param code:"""
    params_dict: T_JSON_DICT = dict()
    params_dict['address'] = address
    params_dict['type'] = type_.to_json()
    params_dict['code'] = code
    cmd_dict = {'method':
        'BluetoothEmulation.simulateGATTOperationResponse', 'params':
        params_dict}
    json_result = yield cmd_dict
    return None


def simulate_preconnected_peripheral(address: str, name: str,
    manufacturer_data: typing.List[ManufacturerData], known_service_uuids:
    typing.List[str]) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Simulates a peripheral with |address|, |name| and |knownServiceUuids|
that has already been connected to the system.

:param ...:

:param address:

:param name:

:param manufacturer_data:

:param known_service_uuids:"""
    params_dict: T_JSON_DICT = dict()
    params_dict['address'] = address
    params_dict['name'] = name
    params_dict['manufacturerData'] = [i.to_json() for i in manufacturer_data]
    params_dict['knownServiceUuids'] = [i for i in known_service_uuids]
    cmd_dict = {'method':
        'BluetoothEmulation.simulatePreconnectedPeripheral', 'params':
        params_dict}
    json_result = yield cmd_dict
    return None


@event_class('BluetoothEmulation.gattOperationReceived')
@dataclass
class GattOperationReceived:
    """Event for when a GATT operation of |type| to the peripheral with |address|
happened."""
    address: str
    type_: GATTOperationType

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->GattOperationReceived:
        return cls(address=json_obj['address'], type_=GATTOperationType.
            from_json(json_obj['type']))
