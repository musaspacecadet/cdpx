# # DO NOT EDIT THIS FILE!
# #
# # This file is generated from the CDP specification using AST. If you need to make
# # changes, edit the generator and regenerate all of the modules.

from __future__ import annotations
"""CDP domain: IO

Input/Output operations for streams produced by DevTools."""
import typing
import enum
from .util import T_JSON_DICT
from . import runtime
None


class StreamHandle(str):
    """This is either obtained from another method or specified as ``blob:<uuid>`` where
``<uuid>`` is an UUID of a Blob.

Represents the CDP type 'IO.StreamHandle'."""

    def to_json(self) ->str:
        return self

    @classmethod
    def from_json(cls, json: str) ->StreamHandle:
        return cls(json)

    def __repr__(self) ->str:
        return 'StreamHandle({})'.format(super().__repr__())


def close(handle: StreamHandle) ->typing.Generator[T_JSON_DICT, T_JSON_DICT,
    None]:
    """Close the stream, discard any temporary backing storage.

:param ...:

:param handle: Handle of the stream to close."""
    params_dict: T_JSON_DICT = dict()
    params_dict['handle'] = handle.to_json()
    cmd_dict = {'method': 'IO.close', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def read(handle: StreamHandle, offset: typing.Optional[int]=None, size:
    typing.Optional[int]=None) ->typing.Generator[T_JSON_DICT, T_JSON_DICT,
    typing.Tuple[typing.Optional[bool], str, bool]]:
    """Read a chunk of the stream

:param ...:

:param handle: Handle of the stream to read.

:param offset: *(Optional)* Seek to the specified offset before reading (if not specified, proceed with offset following the last read). Some types of streams may only support sequential reads.

:param size: *(Optional)* Maximum number of bytes to read (left upon the agent discretion if not specified).


:returns: A tuple with the following items:

    1. **base64Encoded** - *(Optional)* Set if the data is base64-encoded
    2. **data** - Data that were read.
    3. **eof** - Set if the end-of-file condition occurred while reading."""
    params_dict: T_JSON_DICT = dict()
    params_dict['handle'] = handle.to_json()
    if offset is not None:
        params_dict['offset'] = offset
    if size is not None:
        params_dict['size'] = size
    cmd_dict = {'method': 'IO.read', 'params': params_dict}
    json_result = yield cmd_dict
    return json_result['base64Encoded'] if json_result.get('base64Encoded'
        ) is not None else None, json_result['data'], json_result['eof']


def resolve_blob(object_id: runtime.RemoteObjectId) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, str]:
    """Return UUID of Blob object specified by a remote object id.

:param ...:

:param object_id: Object id of a Blob object wrapper.


:returns: UUID of the specified Blob."""
    params_dict: T_JSON_DICT = dict()
    params_dict['objectId'] = object_id.to_json()
    cmd_dict = {'method': 'IO.resolveBlob', 'params': params_dict}
    json_result = yield cmd_dict
    return json_result['uuid']
