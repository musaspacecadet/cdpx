# # DO NOT EDIT THIS FILE!
# #
# # This file is generated from the CDP specification using AST. If you need to make
# # changes, edit the generator and regenerate all of the modules.

from __future__ import annotations
"""CDP domain: Emulation

This domain emulates different environments for the page."""
import typing
import enum
from dataclasses import dataclass
from .util import T_JSON_DICT, event_class
from deprecated.sphinx import deprecated
from . import dom
from . import network
from . import page
from . import runtime
None


@dataclass
class DevicePosture:
    type_: str

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['type'] = self.type_
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->DevicePosture:
        return cls(type_=json_obj['type'])


@dataclass
class DisplayFeature:
    orientation: str
    offset: int
    mask_length: int

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['orientation'] = self.orientation
        json_data['offset'] = self.offset
        json_data['maskLength'] = self.mask_length
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->DisplayFeature:
        return cls(orientation=json_obj['orientation'], offset=json_obj[
            'offset'], mask_length=json_obj['maskLength'])


@dataclass
class MediaFeature:
    name: str
    value: str

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['name'] = self.name
        json_data['value'] = self.value
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->MediaFeature:
        return cls(name=json_obj['name'], value=json_obj['value'])


@dataclass
class PressureMetadata:
    available: typing.Optional[bool] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        if self.available is not None:
            json_data['available'] = self.available
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->PressureMetadata:
        return cls(available=json_obj['available'] if json_obj.get(
            'available') is not None else None)


@dataclass
class SafeAreaInsets:
    top: typing.Optional[int] = None
    top_max: typing.Optional[int] = None
    left: typing.Optional[int] = None
    left_max: typing.Optional[int] = None
    bottom: typing.Optional[int] = None
    bottom_max: typing.Optional[int] = None
    right: typing.Optional[int] = None
    right_max: typing.Optional[int] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        if self.top is not None:
            json_data['top'] = self.top
        if self.top_max is not None:
            json_data['topMax'] = self.top_max
        if self.left is not None:
            json_data['left'] = self.left
        if self.left_max is not None:
            json_data['leftMax'] = self.left_max
        if self.bottom is not None:
            json_data['bottom'] = self.bottom
        if self.bottom_max is not None:
            json_data['bottomMax'] = self.bottom_max
        if self.right is not None:
            json_data['right'] = self.right
        if self.right_max is not None:
            json_data['rightMax'] = self.right_max
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->SafeAreaInsets:
        return cls(top=json_obj['top'] if json_obj.get('top') is not None else
            None, top_max=json_obj['topMax'] if json_obj.get('topMax') is not
            None else None, left=json_obj['left'] if json_obj.get('left')
             is not None else None, left_max=json_obj['leftMax'] if 
            json_obj.get('leftMax') is not None else None, bottom=json_obj[
            'bottom'] if json_obj.get('bottom') is not None else None,
            bottom_max=json_obj['bottomMax'] if json_obj.get('bottomMax')
             is not None else None, right=json_obj['right'] if json_obj.get
            ('right') is not None else None, right_max=json_obj['rightMax'] if
            json_obj.get('rightMax') is not None else None)


@dataclass
class ScreenOrientation:
    """Screen orientation."""
    type_: str
    angle: int

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['type'] = self.type_
        json_data['angle'] = self.angle
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->ScreenOrientation:
        return cls(type_=json_obj['type'], angle=json_obj['angle'])


@dataclass
class SensorMetadata:
    available: typing.Optional[bool] = None
    minimum_frequency: typing.Optional[float] = None
    maximum_frequency: typing.Optional[float] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        if self.available is not None:
            json_data['available'] = self.available
        if self.minimum_frequency is not None:
            json_data['minimumFrequency'] = self.minimum_frequency
        if self.maximum_frequency is not None:
            json_data['maximumFrequency'] = self.maximum_frequency
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->SensorMetadata:
        return cls(available=json_obj['available'] if json_obj.get(
            'available') is not None else None, minimum_frequency=json_obj[
            'minimumFrequency'] if json_obj.get('minimumFrequency') is not
            None else None, maximum_frequency=json_obj['maximumFrequency'] if
            json_obj.get('maximumFrequency') is not None else None)


@dataclass
class SensorReading:
    single: typing.Optional[SensorReadingSingle] = None
    xyz: typing.Optional[SensorReadingXYZ] = None
    quaternion: typing.Optional[SensorReadingQuaternion] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        if self.single is not None:
            json_data['single'] = self.single.to_json()
        if self.xyz is not None:
            json_data['xyz'] = self.xyz.to_json()
        if self.quaternion is not None:
            json_data['quaternion'] = self.quaternion.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->SensorReading:
        return cls(single=SensorReadingSingle.from_json(json_obj['single']) if
            json_obj.get('single') is not None else None, xyz=
            SensorReadingXYZ.from_json(json_obj['xyz']) if json_obj.get(
            'xyz') is not None else None, quaternion=
            SensorReadingQuaternion.from_json(json_obj['quaternion']) if 
            json_obj.get('quaternion') is not None else None)


@dataclass
class SensorReadingQuaternion:
    x: float
    y: float
    z: float
    w: float

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['x'] = self.x
        json_data['y'] = self.y
        json_data['z'] = self.z
        json_data['w'] = self.w
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->SensorReadingQuaternion:
        return cls(x=json_obj['x'], y=json_obj['y'], z=json_obj['z'], w=
            json_obj['w'])


@dataclass
class SensorReadingSingle:
    value: float

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['value'] = self.value
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->SensorReadingSingle:
        return cls(value=json_obj['value'])


@dataclass
class SensorReadingXYZ:
    x: float
    y: float
    z: float

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['x'] = self.x
        json_data['y'] = self.y
        json_data['z'] = self.z
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->SensorReadingXYZ:
        return cls(x=json_obj['x'], y=json_obj['y'], z=json_obj['z'])


@dataclass
class UserAgentBrandVersion:
    """Used to specify User Agent Client Hints to emulate. See https://wicg.github.io/ua-client-hints"""
    brand: str
    version: str

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['brand'] = self.brand
        json_data['version'] = self.version
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->UserAgentBrandVersion:
        return cls(brand=json_obj['brand'], version=json_obj['version'])


@dataclass
class UserAgentMetadata:
    """Used to specify User Agent Client Hints to emulate. See https://wicg.github.io/ua-client-hints
Missing optional values will be filled in by the target with what it would normally use."""
    platform: str
    platform_version: str
    architecture: str
    model: str
    mobile: bool
    brands: typing.Optional[typing.List[UserAgentBrandVersion]] = None
    full_version_list: typing.Optional[typing.List[UserAgentBrandVersion]
        ] = None
    full_version: typing.Optional[str] = None
    bitness: typing.Optional[str] = None
    wow64: typing.Optional[bool] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['platform'] = self.platform
        json_data['platformVersion'] = self.platform_version
        json_data['architecture'] = self.architecture
        json_data['model'] = self.model
        json_data['mobile'] = self.mobile
        if self.brands is not None:
            json_data['brands'] = [i.to_json() for i in self.brands]
        if self.full_version_list is not None:
            json_data['fullVersionList'] = [i.to_json() for i in self.
                full_version_list]
        if self.full_version is not None:
            json_data['fullVersion'] = self.full_version
        if self.bitness is not None:
            json_data['bitness'] = self.bitness
        if self.wow64 is not None:
            json_data['wow64'] = self.wow64
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->UserAgentMetadata:
        return cls(platform=json_obj['platform'], platform_version=json_obj
            ['platformVersion'], architecture=json_obj['architecture'],
            model=json_obj['model'], mobile=json_obj['mobile'], brands=[
            UserAgentBrandVersion.from_json(i) for i in json_obj['brands']] if
            json_obj.get('brands') is not None else None, full_version_list
            =[UserAgentBrandVersion.from_json(i) for i in json_obj[
            'fullVersionList']] if json_obj.get('fullVersionList') is not
            None else None, full_version=json_obj['fullVersion'] if 
            json_obj.get('fullVersion') is not None else None, bitness=
            json_obj['bitness'] if json_obj.get('bitness') is not None else
            None, wow64=json_obj['wow64'] if json_obj.get('wow64') is not
            None else None)


class DisabledImageType(enum.Enum):
    """Enum of image types that can be disabled."""
    AVIF = 'avif'
    WEBP = 'webp'

    @classmethod
    def from_json(cls, json: str) ->DisabledImageType:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<DisabledImageType.{}>'.format(self.value)


class PressureSource(enum.Enum):
    CPU = 'cpu'

    @classmethod
    def from_json(cls, json: str) ->PressureSource:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<PressureSource.{}>'.format(self.value)


class PressureState(enum.Enum):
    NOMINAL = 'nominal'
    FAIR = 'fair'
    SERIOUS = 'serious'
    CRITICAL = 'critical'

    @classmethod
    def from_json(cls, json: str) ->PressureState:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<PressureState.{}>'.format(self.value)


class SensorType(enum.Enum):
    """Used to specify sensor types to emulate.
See https://w3c.github.io/sensors/#automation for more information."""
    ABSOLUTE_ORIENTATION = 'absolute-orientation'
    ACCELEROMETER = 'accelerometer'
    AMBIENT_LIGHT = 'ambient-light'
    GRAVITY = 'gravity'
    GYROSCOPE = 'gyroscope'
    LINEAR_ACCELERATION = 'linear-acceleration'
    MAGNETOMETER = 'magnetometer'
    RELATIVE_ORIENTATION = 'relative-orientation'

    @classmethod
    def from_json(cls, json: str) ->SensorType:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<SensorType.{}>'.format(self.value)


class VirtualTimePolicy(enum.Enum):
    """advance: If the scheduler runs out of immediate work, the virtual time base may fast forward to
allow the next delayed task (if any) to run; pause: The virtual time base may not advance;
pauseIfNetworkFetchesPending: The virtual time base may not advance if there are any pending
resource fetches."""
    ADVANCE = 'advance'
    PAUSE = 'pause'
    PAUSE_IF_NETWORK_FETCHES_PENDING = 'pauseIfNetworkFetchesPending'

    @classmethod
    def from_json(cls, json: str) ->VirtualTimePolicy:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<VirtualTimePolicy.{}>'.format(self.value)


@deprecated(version='1.3')
def can_emulate() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, bool]:
    """Tells whether emulation is supported.

.. deprecated:: 1.3


:returns: True if emulation is supported."""
    cmd_dict = {'method': 'Emulation.canEmulate'}
    json_result = yield cmd_dict
    return json_result['result']


def clear_device_metrics_override() ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, None]:
    """Clears the overridden device metrics."""
    cmd_dict = {'method': 'Emulation.clearDeviceMetricsOverride'}
    json_result = yield cmd_dict
    return None


def clear_device_posture_override() ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, None]:
    """Clears a device posture override set with either setDeviceMetricsOverride()
or setDevicePostureOverride() and starts using posture information from the
platform again.
Does nothing if no override is set.

**EXPERIMENTAL**"""
    cmd_dict = {'method': 'Emulation.clearDevicePostureOverride'}
    json_result = yield cmd_dict
    return None


def clear_display_features_override() ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, None]:
    """Clears the display features override set with either setDeviceMetricsOverride()
or setDisplayFeaturesOverride() and starts using display features from the
platform again.
Does nothing if no override is set.

**EXPERIMENTAL**"""
    cmd_dict = {'method': 'Emulation.clearDisplayFeaturesOverride'}
    json_result = yield cmd_dict
    return None


def clear_geolocation_override() ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, None]:
    """Clears the overridden Geolocation Position and Error."""
    cmd_dict = {'method': 'Emulation.clearGeolocationOverride'}
    json_result = yield cmd_dict
    return None


def clear_idle_override() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Clears Idle state overrides."""
    cmd_dict = {'method': 'Emulation.clearIdleOverride'}
    json_result = yield cmd_dict
    return None


def get_overridden_sensor_information(type_: SensorType) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, float]:
    """**EXPERIMENTAL**


:param ...:

:param type_:


:returns:"""
    params_dict: T_JSON_DICT = dict()
    params_dict['type'] = type_.to_json()
    cmd_dict = {'method': 'Emulation.getOverriddenSensorInformation',
        'params': params_dict}
    json_result = yield cmd_dict
    return json_result['requestedSamplingFrequency']


def reset_page_scale_factor() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None
    ]:
    """Requests that page scale factor is reset to initial values.

**EXPERIMENTAL**"""
    cmd_dict = {'method': 'Emulation.resetPageScaleFactor'}
    json_result = yield cmd_dict
    return None


def set_auto_dark_mode_override(enabled: typing.Optional[bool]=None
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Automatically render all web contents using a dark theme.

**EXPERIMENTAL**

:param ...:

:param enabled: *(Optional)* Whether to enable or disable automatic dark mode. If not specified, any existing override will be cleared."""
    params_dict: T_JSON_DICT = dict()
    if enabled is not None:
        params_dict['enabled'] = enabled
    cmd_dict = {'method': 'Emulation.setAutoDarkModeOverride', 'params':
        params_dict}
    json_result = yield cmd_dict
    return None


def set_automation_override(enabled: bool) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, None]:
    """Allows overriding the automation flag.

**EXPERIMENTAL**

:param ...:

:param enabled: Whether the override should be enabled."""
    params_dict: T_JSON_DICT = dict()
    params_dict['enabled'] = enabled
    cmd_dict = {'method': 'Emulation.setAutomationOverride', 'params':
        params_dict}
    json_result = yield cmd_dict
    return None


def set_cpu_throttling_rate(rate: float) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, None]:
    """Enables CPU throttling to emulate slow CPUs.

:param ...:

:param rate: Throttling rate as a slowdown factor (1 is no throttle, 2 is 2x slowdown, etc)."""
    params_dict: T_JSON_DICT = dict()
    params_dict['rate'] = rate
    cmd_dict = {'method': 'Emulation.setCPUThrottlingRate', 'params':
        params_dict}
    json_result = yield cmd_dict
    return None


def set_default_background_color_override(color: typing.Optional[dom.RGBA]=None
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Sets or clears an override of the default background color of the frame. This override is used
if the content does not specify one.

:param ...:

:param color: *(Optional)* RGBA of the default background color. If not specified, any existing override will be cleared."""
    params_dict: T_JSON_DICT = dict()
    if color is not None:
        params_dict['color'] = color.to_json()
    cmd_dict = {'method': 'Emulation.setDefaultBackgroundColorOverride',
        'params': params_dict}
    json_result = yield cmd_dict
    return None


def set_device_metrics_override(width: int, height: int,
    device_scale_factor: float, mobile: bool, scale: typing.Optional[float]
    =None, screen_width: typing.Optional[int]=None, screen_height: typing.
    Optional[int]=None, position_x: typing.Optional[int]=None, position_y:
    typing.Optional[int]=None, dont_set_visible_size: typing.Optional[bool]
    =None, screen_orientation: typing.Optional[ScreenOrientation]=None,
    viewport: typing.Optional[page.Viewport]=None, display_feature: typing.
    Optional[DisplayFeature]=None, device_posture: typing.Optional[
    DevicePosture]=None) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
query results).

:param ...:

:param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.

:param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.

:param device_scale_factor: Overriding device scale factor value. 0 disables the override.

:param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.

:param scale: **(EXPERIMENTAL)** *(Optional)* Scale to apply to resulting view image.

:param screen_width: **(EXPERIMENTAL)** *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).

:param screen_height: **(EXPERIMENTAL)** *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).

:param position_x: **(EXPERIMENTAL)** *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).

:param position_y: **(EXPERIMENTAL)** *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).

:param dont_set_visible_size: **(EXPERIMENTAL)** *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.

:param screen_orientation: *(Optional)* Screen orientation override.

:param viewport: **(EXPERIMENTAL)** *(Optional)* If set, the visible area of the page will be overridden to this viewport. This viewport change is not observed by the page, e.g. viewport-relative elements do not change positions.

:param display_feature: **(DEPRECATED)** **(EXPERIMENTAL)** *(Optional)* If set, the display feature of a multi-segment screen. If not set, multi-segment support is turned-off. Deprecated, use Emulation.setDisplayFeaturesOverride.

:param device_posture: **(DEPRECATED)** **(EXPERIMENTAL)** *(Optional)* If set, the posture of a foldable device. If not set the posture is set to continuous. Deprecated, use Emulation.setDevicePostureOverride."""
    params_dict: T_JSON_DICT = dict()
    params_dict['width'] = width
    params_dict['height'] = height
    params_dict['deviceScaleFactor'] = device_scale_factor
    params_dict['mobile'] = mobile
    if scale is not None:
        params_dict['scale'] = scale
    if screen_width is not None:
        params_dict['screenWidth'] = screen_width
    if screen_height is not None:
        params_dict['screenHeight'] = screen_height
    if position_x is not None:
        params_dict['positionX'] = position_x
    if position_y is not None:
        params_dict['positionY'] = position_y
    if dont_set_visible_size is not None:
        params_dict['dontSetVisibleSize'] = dont_set_visible_size
    if screen_orientation is not None:
        params_dict['screenOrientation'] = screen_orientation.to_json()
    if viewport is not None:
        params_dict['viewport'] = viewport.to_json()
    if display_feature is not None:
        params_dict['displayFeature'] = display_feature.to_json()
    if device_posture is not None:
        params_dict['devicePosture'] = device_posture.to_json()
    cmd_dict = {'method': 'Emulation.setDeviceMetricsOverride', 'params':
        params_dict}
    json_result = yield cmd_dict
    return None


def set_device_posture_override(posture: DevicePosture) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, None]:
    """Start reporting the given posture value to the Device Posture API.
This override can also be set in setDeviceMetricsOverride().

**EXPERIMENTAL**

:param ...:

:param posture:"""
    params_dict: T_JSON_DICT = dict()
    params_dict['posture'] = posture.to_json()
    cmd_dict = {'method': 'Emulation.setDevicePostureOverride', 'params':
        params_dict}
    json_result = yield cmd_dict
    return None


def set_disabled_image_types(image_types: typing.List[DisabledImageType]
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """**EXPERIMENTAL**


:param ...:

:param image_types: Image types to disable."""
    params_dict: T_JSON_DICT = dict()
    params_dict['imageTypes'] = [i.to_json() for i in image_types]
    cmd_dict = {'method': 'Emulation.setDisabledImageTypes', 'params':
        params_dict}
    json_result = yield cmd_dict
    return None


def set_display_features_override(features: typing.List[DisplayFeature]
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Start using the given display features to pupulate the Viewport Segments API.
This override can also be set in setDeviceMetricsOverride().

**EXPERIMENTAL**

:param ...:

:param features:"""
    params_dict: T_JSON_DICT = dict()
    params_dict['features'] = [i.to_json() for i in features]
    cmd_dict = {'method': 'Emulation.setDisplayFeaturesOverride', 'params':
        params_dict}
    json_result = yield cmd_dict
    return None


def set_document_cookie_disabled(disabled: bool) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, None]:
    """**EXPERIMENTAL**


:param ...:

:param disabled: Whether document.coookie API should be disabled."""
    params_dict: T_JSON_DICT = dict()
    params_dict['disabled'] = disabled
    cmd_dict = {'method': 'Emulation.setDocumentCookieDisabled', 'params':
        params_dict}
    json_result = yield cmd_dict
    return None


def set_emit_touch_events_for_mouse(enabled: bool, configuration: typing.
    Optional[str]=None) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """**EXPERIMENTAL**


:param ...:

:param enabled: Whether touch emulation based on mouse input should be enabled.

:param configuration: *(Optional)* Touch/gesture events configuration. Default: current platform."""
    params_dict: T_JSON_DICT = dict()
    params_dict['enabled'] = enabled
    if configuration is not None:
        params_dict['configuration'] = configuration
    cmd_dict = {'method': 'Emulation.setEmitTouchEventsForMouse', 'params':
        params_dict}
    json_result = yield cmd_dict
    return None


def set_emulated_media(media: typing.Optional[str]=None, features: typing.
    Optional[typing.List[MediaFeature]]=None) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, None]:
    """Emulates the given media type or media feature for CSS media queries.

:param ...:

:param media: *(Optional)* Media type to emulate. Empty string disables the override.

:param features: *(Optional)* Media features to emulate."""
    params_dict: T_JSON_DICT = dict()
    if media is not None:
        params_dict['media'] = media
    if features is not None:
        params_dict['features'] = [i.to_json() for i in features]
    cmd_dict = {'method': 'Emulation.setEmulatedMedia', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def set_emulated_vision_deficiency(type_: str) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, None]:
    """Emulates the given vision deficiency.

:param ...:

:param type_: Vision deficiency to emulate. Order: best-effort emulations come first, followed by any physiologically accurate emulations for medically recognized color vision deficiencies."""
    params_dict: T_JSON_DICT = dict()
    params_dict['type'] = type_
    cmd_dict = {'method': 'Emulation.setEmulatedVisionDeficiency', 'params':
        params_dict}
    json_result = yield cmd_dict
    return None


def set_focus_emulation_enabled(enabled: bool) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, None]:
    """Enables or disables simulating a focused and active page.

**EXPERIMENTAL**

:param ...:

:param enabled: Whether to enable to disable focus emulation."""
    params_dict: T_JSON_DICT = dict()
    params_dict['enabled'] = enabled
    cmd_dict = {'method': 'Emulation.setFocusEmulationEnabled', 'params':
        params_dict}
    json_result = yield cmd_dict
    return None


def set_geolocation_override(latitude: typing.Optional[float]=None,
    longitude: typing.Optional[float]=None, accuracy: typing.Optional[float
    ]=None, altitude: typing.Optional[float]=None, altitude_accuracy:
    typing.Optional[float]=None, heading: typing.Optional[float]=None,
    speed: typing.Optional[float]=None) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, None]:
    """Overrides the Geolocation Position or Error. Omitting latitude, longitude or
accuracy emulates position unavailable.

:param ...:

:param latitude: *(Optional)* Mock latitude

:param longitude: *(Optional)* Mock longitude

:param accuracy: *(Optional)* Mock accuracy

:param altitude: *(Optional)* Mock altitude

:param altitude_accuracy: *(Optional)* Mock altitudeAccuracy

:param heading: *(Optional)* Mock heading

:param speed: *(Optional)* Mock speed"""
    params_dict: T_JSON_DICT = dict()
    if latitude is not None:
        params_dict['latitude'] = latitude
    if longitude is not None:
        params_dict['longitude'] = longitude
    if accuracy is not None:
        params_dict['accuracy'] = accuracy
    if altitude is not None:
        params_dict['altitude'] = altitude
    if altitude_accuracy is not None:
        params_dict['altitudeAccuracy'] = altitude_accuracy
    if heading is not None:
        params_dict['heading'] = heading
    if speed is not None:
        params_dict['speed'] = speed
    cmd_dict = {'method': 'Emulation.setGeolocationOverride', 'params':
        params_dict}
    json_result = yield cmd_dict
    return None


def set_hardware_concurrency_override(hardware_concurrency: int
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """**EXPERIMENTAL**


:param ...:

:param hardware_concurrency: Hardware concurrency to report"""
    params_dict: T_JSON_DICT = dict()
    params_dict['hardwareConcurrency'] = hardware_concurrency
    cmd_dict = {'method': 'Emulation.setHardwareConcurrencyOverride',
        'params': params_dict}
    json_result = yield cmd_dict
    return None


def set_idle_override(is_user_active: bool, is_screen_unlocked: bool
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Overrides the Idle state.

:param ...:

:param is_user_active: Mock isUserActive

:param is_screen_unlocked: Mock isScreenUnlocked"""
    params_dict: T_JSON_DICT = dict()
    params_dict['isUserActive'] = is_user_active
    params_dict['isScreenUnlocked'] = is_screen_unlocked
    cmd_dict = {'method': 'Emulation.setIdleOverride', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def set_locale_override(locale: typing.Optional[str]=None) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, None]:
    """Overrides default host system locale with the specified one.

**EXPERIMENTAL**

:param ...:

:param locale: *(Optional)* ICU style C locale (e.g. "en_US"). If not specified or empty, disables the override and restores default host system locale."""
    params_dict: T_JSON_DICT = dict()
    if locale is not None:
        params_dict['locale'] = locale
    cmd_dict = {'method': 'Emulation.setLocaleOverride', 'params': params_dict}
    json_result = yield cmd_dict
    return None


@deprecated(version='1.3')
def set_navigator_overrides(platform: str) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, None]:
    """Overrides value returned by the javascript navigator object.

.. deprecated:: 1.3

**EXPERIMENTAL**

:param ...:

:param platform: The platform navigator.platform should return."""
    params_dict: T_JSON_DICT = dict()
    params_dict['platform'] = platform
    cmd_dict = {'method': 'Emulation.setNavigatorOverrides', 'params':
        params_dict}
    json_result = yield cmd_dict
    return None


def set_page_scale_factor(page_scale_factor: float) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, None]:
    """Sets a specified page scale factor.

**EXPERIMENTAL**

:param ...:

:param page_scale_factor: Page scale factor."""
    params_dict: T_JSON_DICT = dict()
    params_dict['pageScaleFactor'] = page_scale_factor
    cmd_dict = {'method': 'Emulation.setPageScaleFactor', 'params': params_dict
        }
    json_result = yield cmd_dict
    return None


def set_pressure_source_override_enabled(enabled: bool, source:
    PressureSource, metadata: typing.Optional[PressureMetadata]=None
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Overrides a pressure source of a given type, as used by the Compute
Pressure API, so that updates to PressureObserver.observe() are provided
via setPressureStateOverride instead of being retrieved from
platform-provided telemetry data.

**EXPERIMENTAL**

:param ...:

:param enabled:

:param source:

:param metadata: *(Optional)*"""
    params_dict: T_JSON_DICT = dict()
    params_dict['enabled'] = enabled
    params_dict['source'] = source.to_json()
    if metadata is not None:
        params_dict['metadata'] = metadata.to_json()
    cmd_dict = {'method': 'Emulation.setPressureSourceOverrideEnabled',
        'params': params_dict}
    json_result = yield cmd_dict
    return None


def set_pressure_state_override(source: PressureSource, state: PressureState
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Provides a given pressure state that will be processed and eventually be
delivered to PressureObserver users. |source| must have been previously
overridden by setPressureSourceOverrideEnabled.

**EXPERIMENTAL**

:param ...:

:param source:

:param state:"""
    params_dict: T_JSON_DICT = dict()
    params_dict['source'] = source.to_json()
    params_dict['state'] = state.to_json()
    cmd_dict = {'method': 'Emulation.setPressureStateOverride', 'params':
        params_dict}
    json_result = yield cmd_dict
    return None


def set_safe_area_insets_override(insets: SafeAreaInsets) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, None]:
    """Overrides the values for env(safe-area-inset-*) and env(safe-area-max-inset-*). Unset values will cause the
respective variables to be undefined, even if previously overridden.

**EXPERIMENTAL**

:param ...:

:param insets:"""
    params_dict: T_JSON_DICT = dict()
    params_dict['insets'] = insets.to_json()
    cmd_dict = {'method': 'Emulation.setSafeAreaInsetsOverride', 'params':
        params_dict}
    json_result = yield cmd_dict
    return None


def set_script_execution_disabled(value: bool) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, None]:
    """Switches script execution in the page.

:param ...:

:param value: Whether script execution should be disabled in the page."""
    params_dict: T_JSON_DICT = dict()
    params_dict['value'] = value
    cmd_dict = {'method': 'Emulation.setScriptExecutionDisabled', 'params':
        params_dict}
    json_result = yield cmd_dict
    return None


def set_scrollbars_hidden(hidden: bool) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, None]:
    """**EXPERIMENTAL**


:param ...:

:param hidden: Whether scrollbars should be always hidden."""
    params_dict: T_JSON_DICT = dict()
    params_dict['hidden'] = hidden
    cmd_dict = {'method': 'Emulation.setScrollbarsHidden', 'params':
        params_dict}
    json_result = yield cmd_dict
    return None


def set_sensor_override_enabled(enabled: bool, type_: SensorType, metadata:
    typing.Optional[SensorMetadata]=None) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, None]:
    """Overrides a platform sensor of a given type. If |enabled| is true, calls to
Sensor.start() will use a virtual sensor as backend rather than fetching
data from a real hardware sensor. Otherwise, existing virtual
sensor-backend Sensor objects will fire an error event and new calls to
Sensor.start() will attempt to use a real sensor instead.

**EXPERIMENTAL**

:param ...:

:param enabled:

:param type_:

:param metadata: *(Optional)*"""
    params_dict: T_JSON_DICT = dict()
    params_dict['enabled'] = enabled
    params_dict['type'] = type_.to_json()
    if metadata is not None:
        params_dict['metadata'] = metadata.to_json()
    cmd_dict = {'method': 'Emulation.setSensorOverrideEnabled', 'params':
        params_dict}
    json_result = yield cmd_dict
    return None


def set_sensor_override_readings(type_: SensorType, reading: SensorReading
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Updates the sensor readings reported by a sensor type previously overridden
by setSensorOverrideEnabled.

**EXPERIMENTAL**

:param ...:

:param type_:

:param reading:"""
    params_dict: T_JSON_DICT = dict()
    params_dict['type'] = type_.to_json()
    params_dict['reading'] = reading.to_json()
    cmd_dict = {'method': 'Emulation.setSensorOverrideReadings', 'params':
        params_dict}
    json_result = yield cmd_dict
    return None


def set_timezone_override(timezone_id: str) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, None]:
    """Overrides default host system timezone with the specified one.

:param ...:

:param timezone_id: The timezone identifier. List of supported timezones: https://source.chromium.org/chromium/chromium/deps/icu.git/+/faee8bc70570192d82d2978a71e2a615788597d1:source/data/misc/metaZones.txt If empty, disables the override and restores default host system timezone."""
    params_dict: T_JSON_DICT = dict()
    params_dict['timezoneId'] = timezone_id
    cmd_dict = {'method': 'Emulation.setTimezoneOverride', 'params':
        params_dict}
    json_result = yield cmd_dict
    return None


def set_touch_emulation_enabled(enabled: bool, max_touch_points: typing.
    Optional[int]=None) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Enables touch on platforms which do not support them.

:param ...:

:param enabled: Whether the touch event emulation should be enabled.

:param max_touch_points: *(Optional)* Maximum touch points supported. Defaults to one."""
    params_dict: T_JSON_DICT = dict()
    params_dict['enabled'] = enabled
    if max_touch_points is not None:
        params_dict['maxTouchPoints'] = max_touch_points
    cmd_dict = {'method': 'Emulation.setTouchEmulationEnabled', 'params':
        params_dict}
    json_result = yield cmd_dict
    return None


def set_user_agent_override(user_agent: str, accept_language: typing.
    Optional[str]=None, platform: typing.Optional[str]=None,
    user_agent_metadata: typing.Optional[UserAgentMetadata]=None
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Allows overriding user agent with the given string.
``userAgentMetadata`` must be set for Client Hint headers to be sent.

:param ...:

:param user_agent: User agent to use.

:param accept_language: *(Optional)* Browser language to emulate.

:param platform: *(Optional)* The platform navigator.platform should return.

:param user_agent_metadata: **(EXPERIMENTAL)** *(Optional)* To be sent in Sec-CH-UA-* headers and returned in navigator.userAgentData"""
    params_dict: T_JSON_DICT = dict()
    params_dict['userAgent'] = user_agent
    if accept_language is not None:
        params_dict['acceptLanguage'] = accept_language
    if platform is not None:
        params_dict['platform'] = platform
    if user_agent_metadata is not None:
        params_dict['userAgentMetadata'] = user_agent_metadata.to_json()
    cmd_dict = {'method': 'Emulation.setUserAgentOverride', 'params':
        params_dict}
    json_result = yield cmd_dict
    return None


def set_virtual_time_policy(policy: VirtualTimePolicy, budget: typing.
    Optional[float]=None, max_virtual_time_task_starvation_count: typing.
    Optional[int]=None, initial_virtual_time: typing.Optional[network.
    TimeSinceEpoch]=None) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, float]:
    """Turns on virtual time for all frames (replacing real-time with a synthetic time source) and sets
the current virtual time policy.  Note this supersedes any previous time budget.

**EXPERIMENTAL**

:param ...:

:param policy:

:param budget: *(Optional)* If set, after this many virtual milliseconds have elapsed virtual time will be paused and a virtualTimeBudgetExpired event is sent.

:param max_virtual_time_task_starvation_count: *(Optional)* If set this specifies the maximum number of tasks that can be run before virtual is forced forwards to prevent deadlock.

:param initial_virtual_time: *(Optional)* If set, base::Time::Now will be overridden to initially return this value.


:returns: Absolute timestamp at which virtual time was first enabled (up time in milliseconds)."""
    params_dict: T_JSON_DICT = dict()
    params_dict['policy'] = policy.to_json()
    if budget is not None:
        params_dict['budget'] = budget
    if max_virtual_time_task_starvation_count is not None:
        params_dict['maxVirtualTimeTaskStarvationCount'
            ] = max_virtual_time_task_starvation_count
    if initial_virtual_time is not None:
        params_dict['initialVirtualTime'] = initial_virtual_time.to_json()
    cmd_dict = {'method': 'Emulation.setVirtualTimePolicy', 'params':
        params_dict}
    json_result = yield cmd_dict
    return json_result['virtualTimeTicksBase']


@deprecated(version='1.3')
def set_visible_size(width: int, height: int) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, None]:
    """Resizes the frame/viewport of the page. Note that this does not affect the frame's container
(e.g. browser window). Can be used to produce screenshots of the specified size. Not supported
on Android.

.. deprecated:: 1.3

**EXPERIMENTAL**

:param ...:

:param width: Frame width (DIP).

:param height: Frame height (DIP)."""
    params_dict: T_JSON_DICT = dict()
    params_dict['width'] = width
    params_dict['height'] = height
    cmd_dict = {'method': 'Emulation.setVisibleSize', 'params': params_dict}
    json_result = yield cmd_dict
    return None


@event_class('Emulation.virtualTimeBudgetExpired')
@dataclass
class VirtualTimeBudgetExpired:
    """**EXPERIMENTAL**

Notification sent after the virtual time budget for the current VirtualTimePolicy has run out."""
    pass

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->VirtualTimeBudgetExpired:
        return cls()
