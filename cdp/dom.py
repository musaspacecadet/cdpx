# # DO NOT EDIT THIS FILE!
# #
# # This file is generated from the CDP specification using AST. If you need to make
# # changes, edit the generator and regenerate all of the modules.

from __future__ import annotations
"""CDP domain: DOM

This domain exposes DOM read/write operations. Each DOM Node is represented with its mirror object
that has an ``id``. This ``id`` can be used to get additional information on the Node, resolve it into
the JavaScript object wrapper, etc. It is important that client receives DOM events only for the
nodes that are known to the client. Backend keeps track of the nodes that were sent to the client
and never sends the same node twice. It is client's responsibility to collect information about
the nodes that were sent to the client. Note that ``iframe`` owner elements will return
corresponding document elements as their child nodes."""
import typing
import enum
from dataclasses import dataclass
from .util import T_JSON_DICT, event_class
from deprecated.sphinx import deprecated
from . import page
from . import runtime
None


@dataclass
class BackendNode:
    """Backend node with a friendly name."""
    node_type: int
    node_name: str
    backend_node_id: BackendNodeId

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['nodeType'] = self.node_type
        json_data['nodeName'] = self.node_name
        json_data['backendNodeId'] = self.backend_node_id.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->BackendNode:
        return cls(node_type=json_obj['nodeType'], node_name=json_obj[
            'nodeName'], backend_node_id=BackendNodeId.from_json(json_obj[
            'backendNodeId']))


@dataclass
class BoxModel:
    """Box model."""
    content: Quad
    padding: Quad
    border: Quad
    margin: Quad
    width: int
    height: int
    shape_outside: typing.Optional[ShapeOutsideInfo] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['content'] = self.content.to_json()
        json_data['padding'] = self.padding.to_json()
        json_data['border'] = self.border.to_json()
        json_data['margin'] = self.margin.to_json()
        json_data['width'] = self.width
        json_data['height'] = self.height
        if self.shape_outside is not None:
            json_data['shapeOutside'] = self.shape_outside.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->BoxModel:
        return cls(content=Quad.from_json(json_obj['content']), padding=
            Quad.from_json(json_obj['padding']), border=Quad.from_json(
            json_obj['border']), margin=Quad.from_json(json_obj['margin']),
            width=json_obj['width'], height=json_obj['height'],
            shape_outside=ShapeOutsideInfo.from_json(json_obj[
            'shapeOutside']) if json_obj.get('shapeOutside') is not None else
            None)


@dataclass
class CSSComputedStyleProperty:
    name: str
    value: str

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['name'] = self.name
        json_data['value'] = self.value
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->CSSComputedStyleProperty:
        return cls(name=json_obj['name'], value=json_obj['value'])


@dataclass
class DetachedElementInfo:
    """A structure to hold the top-level node of a detached tree and an array of its retained descendants."""
    tree_node: Node
    retained_node_ids: typing.List[NodeId]

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['treeNode'] = self.tree_node.to_json()
        json_data['retainedNodeIds'] = [i.to_json() for i in self.
            retained_node_ids]
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->DetachedElementInfo:
        return cls(tree_node=Node.from_json(json_obj['treeNode']),
            retained_node_ids=[NodeId.from_json(i) for i in json_obj[
            'retainedNodeIds']])


@dataclass
class Node:
    """DOM interaction is implemented in terms of mirror objects that represent the actual DOM nodes.
DOMNode is a base node mirror type."""
    node_id: NodeId
    backend_node_id: BackendNodeId
    node_type: int
    node_name: str
    local_name: str
    node_value: str
    parent_id: typing.Optional[NodeId] = None
    child_node_count: typing.Optional[int] = None
    children: typing.Optional[typing.List[Node]] = None
    attributes: typing.Optional[typing.List[str]] = None
    document_url: typing.Optional[str] = None
    base_url: typing.Optional[str] = None
    public_id: typing.Optional[str] = None
    system_id: typing.Optional[str] = None
    internal_subset: typing.Optional[str] = None
    xml_version: typing.Optional[str] = None
    name: typing.Optional[str] = None
    value: typing.Optional[str] = None
    pseudo_type: typing.Optional[PseudoType] = None
    pseudo_identifier: typing.Optional[str] = None
    shadow_root_type: typing.Optional[ShadowRootType] = None
    frame_id: typing.Optional[page.FrameId] = None
    content_document: typing.Optional[Node] = None
    shadow_roots: typing.Optional[typing.List[Node]] = None
    template_content: typing.Optional[Node] = None
    pseudo_elements: typing.Optional[typing.List[Node]] = None
    imported_document: typing.Optional[Node] = None
    distributed_nodes: typing.Optional[typing.List[BackendNode]] = None
    is_svg: typing.Optional[bool] = None
    compatibility_mode: typing.Optional[CompatibilityMode] = None
    assigned_slot: typing.Optional[BackendNode] = None
    is_scrollable: typing.Optional[bool] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['nodeId'] = self.node_id.to_json()
        json_data['backendNodeId'] = self.backend_node_id.to_json()
        json_data['nodeType'] = self.node_type
        json_data['nodeName'] = self.node_name
        json_data['localName'] = self.local_name
        json_data['nodeValue'] = self.node_value
        if self.parent_id is not None:
            json_data['parentId'] = self.parent_id.to_json()
        if self.child_node_count is not None:
            json_data['childNodeCount'] = self.child_node_count
        if self.children is not None:
            json_data['children'] = [i.to_json() for i in self.children]
        if self.attributes is not None:
            json_data['attributes'] = [i for i in self.attributes]
        if self.document_url is not None:
            json_data['documentURL'] = self.document_url
        if self.base_url is not None:
            json_data['baseURL'] = self.base_url
        if self.public_id is not None:
            json_data['publicId'] = self.public_id
        if self.system_id is not None:
            json_data['systemId'] = self.system_id
        if self.internal_subset is not None:
            json_data['internalSubset'] = self.internal_subset
        if self.xml_version is not None:
            json_data['xmlVersion'] = self.xml_version
        if self.name is not None:
            json_data['name'] = self.name
        if self.value is not None:
            json_data['value'] = self.value
        if self.pseudo_type is not None:
            json_data['pseudoType'] = self.pseudo_type.to_json()
        if self.pseudo_identifier is not None:
            json_data['pseudoIdentifier'] = self.pseudo_identifier
        if self.shadow_root_type is not None:
            json_data['shadowRootType'] = self.shadow_root_type.to_json()
        if self.frame_id is not None:
            json_data['frameId'] = self.frame_id.to_json()
        if self.content_document is not None:
            json_data['contentDocument'] = self.content_document.to_json()
        if self.shadow_roots is not None:
            json_data['shadowRoots'] = [i.to_json() for i in self.shadow_roots]
        if self.template_content is not None:
            json_data['templateContent'] = self.template_content.to_json()
        if self.pseudo_elements is not None:
            json_data['pseudoElements'] = [i.to_json() for i in self.
                pseudo_elements]
        if self.imported_document is not None:
            json_data['importedDocument'] = self.imported_document.to_json()
        if self.distributed_nodes is not None:
            json_data['distributedNodes'] = [i.to_json() for i in self.
                distributed_nodes]
        if self.is_svg is not None:
            json_data['isSVG'] = self.is_svg
        if self.compatibility_mode is not None:
            json_data['compatibilityMode'] = self.compatibility_mode.to_json()
        if self.assigned_slot is not None:
            json_data['assignedSlot'] = self.assigned_slot.to_json()
        if self.is_scrollable is not None:
            json_data['isScrollable'] = self.is_scrollable
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->Node:
        return cls(node_id=NodeId.from_json(json_obj['nodeId']),
            backend_node_id=BackendNodeId.from_json(json_obj[
            'backendNodeId']), node_type=json_obj['nodeType'], node_name=
            json_obj['nodeName'], local_name=json_obj['localName'],
            node_value=json_obj['nodeValue'], parent_id=NodeId.from_json(
            json_obj['parentId']) if json_obj.get('parentId') is not None else
            None, child_node_count=json_obj['childNodeCount'] if json_obj.
            get('childNodeCount') is not None else None, children=[Node.
            from_json(i) for i in json_obj['children']] if json_obj.get(
            'children') is not None else None, attributes=[i for i in
            json_obj['attributes']] if json_obj.get('attributes') is not
            None else None, document_url=json_obj['documentURL'] if 
            json_obj.get('documentURL') is not None else None, base_url=
            json_obj['baseURL'] if json_obj.get('baseURL') is not None else
            None, public_id=json_obj['publicId'] if json_obj.get('publicId'
            ) is not None else None, system_id=json_obj['systemId'] if 
            json_obj.get('systemId') is not None else None, internal_subset
            =json_obj['internalSubset'] if json_obj.get('internalSubset')
             is not None else None, xml_version=json_obj['xmlVersion'] if 
            json_obj.get('xmlVersion') is not None else None, name=json_obj
            ['name'] if json_obj.get('name') is not None else None, value=
            json_obj['value'] if json_obj.get('value') is not None else
            None, pseudo_type=PseudoType.from_json(json_obj['pseudoType']) if
            json_obj.get('pseudoType') is not None else None,
            pseudo_identifier=json_obj['pseudoIdentifier'] if json_obj.get(
            'pseudoIdentifier') is not None else None, shadow_root_type=
            ShadowRootType.from_json(json_obj['shadowRootType']) if 
            json_obj.get('shadowRootType') is not None else None, frame_id=
            page.FrameId.from_json(json_obj['frameId']) if json_obj.get(
            'frameId') is not None else None, content_document=Node.
            from_json(json_obj['contentDocument']) if json_obj.get(
            'contentDocument') is not None else None, shadow_roots=[Node.
            from_json(i) for i in json_obj['shadowRoots']] if json_obj.get(
            'shadowRoots') is not None else None, template_content=Node.
            from_json(json_obj['templateContent']) if json_obj.get(
            'templateContent') is not None else None, pseudo_elements=[Node
            .from_json(i) for i in json_obj['pseudoElements']] if json_obj.
            get('pseudoElements') is not None else None, imported_document=
            Node.from_json(json_obj['importedDocument']) if json_obj.get(
            'importedDocument') is not None else None, distributed_nodes=[
            BackendNode.from_json(i) for i in json_obj['distributedNodes']] if
            json_obj.get('distributedNodes') is not None else None, is_svg=
            json_obj['isSVG'] if json_obj.get('isSVG') is not None else
            None, compatibility_mode=CompatibilityMode.from_json(json_obj[
            'compatibilityMode']) if json_obj.get('compatibilityMode') is not
            None else None, assigned_slot=BackendNode.from_json(json_obj[
            'assignedSlot']) if json_obj.get('assignedSlot') is not None else
            None, is_scrollable=json_obj['isScrollable'] if json_obj.get(
            'isScrollable') is not None else None)


@dataclass
class RGBA:
    """A structure holding an RGBA color."""
    r: int
    g: int
    b: int
    a: typing.Optional[float] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['r'] = self.r
        json_data['g'] = self.g
        json_data['b'] = self.b
        if self.a is not None:
            json_data['a'] = self.a
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->RGBA:
        return cls(r=json_obj['r'], g=json_obj['g'], b=json_obj['b'], a=
            json_obj['a'] if json_obj.get('a') is not None else None)


@dataclass
class Rect:
    """Rectangle."""
    x: float
    y: float
    width: float
    height: float

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['x'] = self.x
        json_data['y'] = self.y
        json_data['width'] = self.width
        json_data['height'] = self.height
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->Rect:
        return cls(x=json_obj['x'], y=json_obj['y'], width=json_obj['width'
            ], height=json_obj['height'])


@dataclass
class ShapeOutsideInfo:
    """CSS Shape Outside details."""
    bounds: Quad
    shape: typing.List[typing.Any]
    margin_shape: typing.List[typing.Any]

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['bounds'] = self.bounds.to_json()
        json_data['shape'] = [i for i in self.shape]
        json_data['marginShape'] = [i for i in self.margin_shape]
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->ShapeOutsideInfo:
        return cls(bounds=Quad.from_json(json_obj['bounds']), shape=[i for
            i in json_obj['shape']], margin_shape=[i for i in json_obj[
            'marginShape']])


class CompatibilityMode(enum.Enum):
    """Document compatibility mode."""
    QUIRKS_MODE = 'QuirksMode'
    LIMITED_QUIRKS_MODE = 'LimitedQuirksMode'
    NO_QUIRKS_MODE = 'NoQuirksMode'

    @classmethod
    def from_json(cls, json: str) ->CompatibilityMode:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<CompatibilityMode.{}>'.format(self.value)


class LogicalAxes(enum.Enum):
    """ContainerSelector logical axes"""
    INLINE = 'Inline'
    BLOCK = 'Block'
    BOTH = 'Both'

    @classmethod
    def from_json(cls, json: str) ->LogicalAxes:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<LogicalAxes.{}>'.format(self.value)


class PhysicalAxes(enum.Enum):
    """ContainerSelector physical axes"""
    HORIZONTAL = 'Horizontal'
    VERTICAL = 'Vertical'
    BOTH = 'Both'

    @classmethod
    def from_json(cls, json: str) ->PhysicalAxes:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<PhysicalAxes.{}>'.format(self.value)


class PseudoType(enum.Enum):
    """Pseudo element type."""
    FIRST_LINE = 'first-line'
    FIRST_LETTER = 'first-letter'
    CHECKMARK = 'checkmark'
    BEFORE = 'before'
    AFTER = 'after'
    PICKER_ICON = 'picker-icon'
    MARKER = 'marker'
    BACKDROP = 'backdrop'
    COLUMN = 'column'
    SELECTION = 'selection'
    SEARCH_TEXT = 'search-text'
    TARGET_TEXT = 'target-text'
    SPELLING_ERROR = 'spelling-error'
    GRAMMAR_ERROR = 'grammar-error'
    HIGHLIGHT = 'highlight'
    FIRST_LINE_INHERITED = 'first-line-inherited'
    SCROLL_MARKER = 'scroll-marker'
    SCROLL_MARKER_GROUP = 'scroll-marker-group'
    SCROLL_BUTTON = 'scroll-button'
    SCROLLBAR = 'scrollbar'
    SCROLLBAR_THUMB = 'scrollbar-thumb'
    SCROLLBAR_BUTTON = 'scrollbar-button'
    SCROLLBAR_TRACK = 'scrollbar-track'
    SCROLLBAR_TRACK_PIECE = 'scrollbar-track-piece'
    SCROLLBAR_CORNER = 'scrollbar-corner'
    RESIZER = 'resizer'
    INPUT_LIST_BUTTON = 'input-list-button'
    VIEW_TRANSITION = 'view-transition'
    VIEW_TRANSITION_GROUP = 'view-transition-group'
    VIEW_TRANSITION_IMAGE_PAIR = 'view-transition-image-pair'
    VIEW_TRANSITION_OLD = 'view-transition-old'
    VIEW_TRANSITION_NEW = 'view-transition-new'
    PLACEHOLDER = 'placeholder'
    FILE_SELECTOR_BUTTON = 'file-selector-button'
    DETAILS_CONTENT = 'details-content'
    PICKER = 'picker'

    @classmethod
    def from_json(cls, json: str) ->PseudoType:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<PseudoType.{}>'.format(self.value)


class ScrollOrientation(enum.Enum):
    """Physical scroll orientation"""
    HORIZONTAL = 'horizontal'
    VERTICAL = 'vertical'

    @classmethod
    def from_json(cls, json: str) ->ScrollOrientation:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<ScrollOrientation.{}>'.format(self.value)


class ShadowRootType(enum.Enum):
    """Shadow root type."""
    USER_AGENT = 'user-agent'
    OPEN_ = 'open'
    CLOSED = 'closed'

    @classmethod
    def from_json(cls, json: str) ->ShadowRootType:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<ShadowRootType.{}>'.format(self.value)


class BackendNodeId(int):
    """Unique DOM node identifier used to reference a node that may not have been pushed to the
front-end.

Represents the CDP type 'DOM.BackendNodeId'."""

    def to_json(self) ->int:
        return self

    @classmethod
    def from_json(cls, json: int) ->BackendNodeId:
        return cls(json)

    def __repr__(self) ->str:
        return 'BackendNodeId({})'.format(super().__repr__())


class NodeId(int):
    """Unique DOM node identifier.

Represents the CDP type 'DOM.NodeId'."""

    def to_json(self) ->int:
        return self

    @classmethod
    def from_json(cls, json: int) ->NodeId:
        return cls(json)

    def __repr__(self) ->str:
        return 'NodeId({})'.format(super().__repr__())


class Quad(list):
    """An array of quad vertices, x immediately followed by y for each point, points clock-wise.

Represents the CDP array type 'DOM.Quad'."""

    def to_json(self) ->typing.List[float]:
        return self

    @classmethod
    def from_json(cls, json: typing.List[float]) ->Quad:
        return cls(json)

    def __repr__(self) ->str:
        return 'Quad({})'.format(super().__repr__())


def collect_class_names_from_subtree(node_id: NodeId) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, typing.List[str]]:
    """Collects class names for the node with given id and all of it's child nodes.

**EXPERIMENTAL**

:param ...:

:param node_id: Id of the node to collect class names.


:returns: Class name list."""
    params_dict: T_JSON_DICT = dict()
    params_dict['nodeId'] = node_id.to_json()
    cmd_dict = {'method': 'DOM.collectClassNamesFromSubtree', 'params':
        params_dict}
    json_result = yield cmd_dict
    return [i for i in json_result['classNames']]


def copy_to(node_id: NodeId, target_node_id: NodeId, insert_before_node_id:
    typing.Optional[NodeId]=None) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, NodeId]:
    """Creates a deep copy of the specified node and places it into the target container before the
given anchor.

**EXPERIMENTAL**

:param ...:

:param node_id: Id of the node to copy.

:param target_node_id: Id of the element to drop the copy into.

:param insert_before_node_id: *(Optional)* Drop the copy before this node (if absent, the copy becomes the last child of ``targetNodeId``).


:returns: Id of the node clone."""
    params_dict: T_JSON_DICT = dict()
    params_dict['nodeId'] = node_id.to_json()
    params_dict['targetNodeId'] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params_dict['insertBeforeNodeId'] = insert_before_node_id.to_json()
    cmd_dict = {'method': 'DOM.copyTo', 'params': params_dict}
    json_result = yield cmd_dict
    return NodeId.from_json(json_result['nodeId'])


def describe_node(node_id: typing.Optional[NodeId]=None, backend_node_id:
    typing.Optional[BackendNodeId]=None, object_id: typing.Optional[runtime
    .RemoteObjectId]=None, depth: typing.Optional[int]=None, pierce: typing
    .Optional[bool]=None) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """Describes node given its id, does not require domain to be enabled. Does not start tracking any
objects, can be used for automation.

:param ...:

:param node_id: *(Optional)* Identifier of the node.

:param backend_node_id: *(Optional)* Identifier of the backend node.

:param object_id: *(Optional)* JavaScript object id of the node wrapper.

:param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.

:param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).


:returns: Node description."""
    params_dict: T_JSON_DICT = dict()
    if node_id is not None:
        params_dict['nodeId'] = node_id.to_json()
    if backend_node_id is not None:
        params_dict['backendNodeId'] = backend_node_id.to_json()
    if object_id is not None:
        params_dict['objectId'] = object_id.to_json()
    if depth is not None:
        params_dict['depth'] = depth
    if pierce is not None:
        params_dict['pierce'] = pierce
    cmd_dict = {'method': 'DOM.describeNode', 'params': params_dict}
    json_result = yield cmd_dict
    return Node.from_json(json_result['node'])


def disable() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Disables DOM agent for the given page."""
    cmd_dict = {'method': 'DOM.disable'}
    json_result = yield cmd_dict
    return None


def discard_search_results(search_id: str) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, None]:
    """Discards search results from the session with the given id. ``getSearchResults`` should no longer
be called for that search.

**EXPERIMENTAL**

:param ...:

:param search_id: Unique search session identifier."""
    params_dict: T_JSON_DICT = dict()
    params_dict['searchId'] = search_id
    cmd_dict = {'method': 'DOM.discardSearchResults', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def enable(include_whitespace: typing.Optional[str]=None) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, None]:
    """Enables DOM agent for the given page.

:param ...:

:param include_whitespace: **(EXPERIMENTAL)** *(Optional)* Whether to include whitespaces in the children array of returned Nodes."""
    params_dict: T_JSON_DICT = dict()
    if include_whitespace is not None:
        params_dict['includeWhitespace'] = include_whitespace
    cmd_dict = {'method': 'DOM.enable', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def focus(node_id: typing.Optional[NodeId]=None, backend_node_id: typing.
    Optional[BackendNodeId]=None, object_id: typing.Optional[runtime.
    RemoteObjectId]=None) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Focuses the given element.

:param ...:

:param node_id: *(Optional)* Identifier of the node.

:param backend_node_id: *(Optional)* Identifier of the backend node.

:param object_id: *(Optional)* JavaScript object id of the node wrapper."""
    params_dict: T_JSON_DICT = dict()
    if node_id is not None:
        params_dict['nodeId'] = node_id.to_json()
    if backend_node_id is not None:
        params_dict['backendNodeId'] = backend_node_id.to_json()
    if object_id is not None:
        params_dict['objectId'] = object_id.to_json()
    cmd_dict = {'method': 'DOM.focus', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def get_anchor_element(node_id: NodeId, anchor_specifier: typing.Optional[
    str]=None) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """Returns the target anchor element of the given anchor query according to
https://www.w3.org/TR/css-anchor-position-1/#target.

**EXPERIMENTAL**

:param ...:

:param node_id: Id of the positioned element from which to find the anchor.

:param anchor_specifier: *(Optional)* An optional anchor specifier, as defined in https://www.w3.org/TR/css-anchor-position-1/#anchor-specifier. If not provided, it will return the implicit anchor element for the given positioned element.


:returns: The anchor element of the given anchor query."""
    params_dict: T_JSON_DICT = dict()
    params_dict['nodeId'] = node_id.to_json()
    if anchor_specifier is not None:
        params_dict['anchorSpecifier'] = anchor_specifier
    cmd_dict = {'method': 'DOM.getAnchorElement', 'params': params_dict}
    json_result = yield cmd_dict
    return NodeId.from_json(json_result['nodeId'])


def get_attributes(node_id: NodeId) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, typing.List[str]]:
    """Returns attributes for the specified node.

:param ...:

:param node_id: Id of the node to retrieve attributes for.


:returns: An interleaved array of node attribute names and values."""
    params_dict: T_JSON_DICT = dict()
    params_dict['nodeId'] = node_id.to_json()
    cmd_dict = {'method': 'DOM.getAttributes', 'params': params_dict}
    json_result = yield cmd_dict
    return [i for i in json_result['attributes']]


def get_box_model(node_id: typing.Optional[NodeId]=None, backend_node_id:
    typing.Optional[BackendNodeId]=None, object_id: typing.Optional[runtime
    .RemoteObjectId]=None) ->typing.Generator[T_JSON_DICT, T_JSON_DICT,
    BoxModel]:
    """Returns boxes for the given node.

:param ...:

:param node_id: *(Optional)* Identifier of the node.

:param backend_node_id: *(Optional)* Identifier of the backend node.

:param object_id: *(Optional)* JavaScript object id of the node wrapper.


:returns: Box model for the node."""
    params_dict: T_JSON_DICT = dict()
    if node_id is not None:
        params_dict['nodeId'] = node_id.to_json()
    if backend_node_id is not None:
        params_dict['backendNodeId'] = backend_node_id.to_json()
    if object_id is not None:
        params_dict['objectId'] = object_id.to_json()
    cmd_dict = {'method': 'DOM.getBoxModel', 'params': params_dict}
    json_result = yield cmd_dict
    return BoxModel.from_json(json_result['model'])


def get_container_for_node(node_id: NodeId, container_name: typing.Optional
    [str]=None, physical_axes: typing.Optional[PhysicalAxes]=None,
    logical_axes: typing.Optional[LogicalAxes]=None, queries_scroll_state:
    typing.Optional[bool]=None) ->typing.Generator[T_JSON_DICT, T_JSON_DICT,
    typing.Optional[NodeId]]:
    """Returns the query container of the given node based on container query
conditions: containerName, physical and logical axes, and whether it queries
scroll-state. If no axes are provided and queriesScrollState is false, the
style container is returned, which is the direct parent or the closest
element with a matching container-name.

**EXPERIMENTAL**

:param ...:

:param node_id:

:param container_name: *(Optional)*

:param physical_axes: *(Optional)*

:param logical_axes: *(Optional)*

:param queries_scroll_state: *(Optional)*


:returns: *(Optional)* The container node for the given node, or null if not found."""
    params_dict: T_JSON_DICT = dict()
    params_dict['nodeId'] = node_id.to_json()
    if container_name is not None:
        params_dict['containerName'] = container_name
    if physical_axes is not None:
        params_dict['physicalAxes'] = physical_axes.to_json()
    if logical_axes is not None:
        params_dict['logicalAxes'] = logical_axes.to_json()
    if queries_scroll_state is not None:
        params_dict['queriesScrollState'] = queries_scroll_state
    cmd_dict = {'method': 'DOM.getContainerForNode', 'params': params_dict}
    json_result = yield cmd_dict
    return NodeId.from_json(json_result['nodeId']) if json_result.get('nodeId'
        ) is not None else None


def get_content_quads(node_id: typing.Optional[NodeId]=None,
    backend_node_id: typing.Optional[BackendNodeId]=None, object_id: typing
    .Optional[runtime.RemoteObjectId]=None) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, typing.List[Quad]]:
    """Returns quads that describe node position on the page. This method
might return multiple quads for inline nodes.

**EXPERIMENTAL**

:param ...:

:param node_id: *(Optional)* Identifier of the node.

:param backend_node_id: *(Optional)* Identifier of the backend node.

:param object_id: *(Optional)* JavaScript object id of the node wrapper.


:returns: Quads that describe node layout relative to viewport."""
    params_dict: T_JSON_DICT = dict()
    if node_id is not None:
        params_dict['nodeId'] = node_id.to_json()
    if backend_node_id is not None:
        params_dict['backendNodeId'] = backend_node_id.to_json()
    if object_id is not None:
        params_dict['objectId'] = object_id.to_json()
    cmd_dict = {'method': 'DOM.getContentQuads', 'params': params_dict}
    json_result = yield cmd_dict
    return [Quad.from_json(i) for i in json_result['quads']]


def get_detached_dom_nodes() ->typing.Generator[T_JSON_DICT, T_JSON_DICT,
    typing.List[DetachedElementInfo]]:
    """Returns list of detached nodes

**EXPERIMENTAL**


:returns: The list of detached nodes"""
    cmd_dict = {'method': 'DOM.getDetachedDomNodes'}
    json_result = yield cmd_dict
    return [DetachedElementInfo.from_json(i) for i in json_result[
        'detachedNodes']]


def get_document(depth: typing.Optional[int]=None, pierce: typing.Optional[
    bool]=None) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """Returns the root DOM node (and optionally the subtree) to the caller.
Implicitly enables the DOM domain events for the current target.

:param ...:

:param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.

:param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).


:returns: Resulting node."""
    params_dict: T_JSON_DICT = dict()
    if depth is not None:
        params_dict['depth'] = depth
    if pierce is not None:
        params_dict['pierce'] = pierce
    cmd_dict = {'method': 'DOM.getDocument', 'params': params_dict}
    json_result = yield cmd_dict
    return Node.from_json(json_result['root'])


def get_element_by_relation(node_id: NodeId, relation: str) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, NodeId]:
    """Returns the NodeId of the matched element according to certain relations.

**EXPERIMENTAL**

:param ...:

:param node_id: Id of the node from which to query the relation.

:param relation: Type of relation to get.


:returns: NodeId of the element matching the queried relation."""
    params_dict: T_JSON_DICT = dict()
    params_dict['nodeId'] = node_id.to_json()
    params_dict['relation'] = relation
    cmd_dict = {'method': 'DOM.getElementByRelation', 'params': params_dict}
    json_result = yield cmd_dict
    return NodeId.from_json(json_result['nodeId'])


def get_file_info(object_id: runtime.RemoteObjectId) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, str]:
    """Returns file information for the given
File wrapper.

**EXPERIMENTAL**

:param ...:

:param object_id: JavaScript object id of the node wrapper.


:returns:"""
    params_dict: T_JSON_DICT = dict()
    params_dict['objectId'] = object_id.to_json()
    cmd_dict = {'method': 'DOM.getFileInfo', 'params': params_dict}
    json_result = yield cmd_dict
    return json_result['path']


@deprecated(version='1.3')
def get_flattened_document(depth: typing.Optional[int]=None, pierce: typing
    .Optional[bool]=None) ->typing.Generator[T_JSON_DICT, T_JSON_DICT,
    typing.List[Node]]:
    """Returns the root DOM node (and optionally the subtree) to the caller.
Deprecated, as it is not designed to work well with the rest of the DOM agent.
Use DOMSnapshot.captureSnapshot instead.

.. deprecated:: 1.3

:param ...:

:param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.

:param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).


:returns: Resulting node."""
    params_dict: T_JSON_DICT = dict()
    if depth is not None:
        params_dict['depth'] = depth
    if pierce is not None:
        params_dict['pierce'] = pierce
    cmd_dict = {'method': 'DOM.getFlattenedDocument', 'params': params_dict}
    json_result = yield cmd_dict
    return [Node.from_json(i) for i in json_result['nodes']]


def get_frame_owner(frame_id: page.FrameId) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, typing.Tuple[BackendNodeId, typing.Optional[NodeId]]]:
    """Returns iframe node that owns iframe with the given domain.

**EXPERIMENTAL**

:param ...:

:param frame_id:


:returns: A tuple with the following items:

    1. **backendNodeId** - Resulting node.
    2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document."""
    params_dict: T_JSON_DICT = dict()
    params_dict['frameId'] = frame_id.to_json()
    cmd_dict = {'method': 'DOM.getFrameOwner', 'params': params_dict}
    json_result = yield cmd_dict
    return BackendNodeId.from_json(json_result['backendNodeId']
        ), NodeId.from_json(json_result['nodeId']) if json_result.get('nodeId'
        ) is not None else None


def get_node_for_location(x: int, y: int, include_user_agent_shadow_dom:
    typing.Optional[bool]=None, ignore_pointer_events_none: typing.Optional
    [bool]=None) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, typing.Tuple[
    BackendNodeId, page.FrameId, typing.Optional[NodeId]]]:
    """Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
either returned or not.

:param ...:

:param x: X coordinate.

:param y: Y coordinate.

:param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false).

:param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them.


:returns: A tuple with the following items:

    1. **backendNodeId** - Resulting node.
    2. **frameId** - Frame this node belongs to.
    3. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document."""
    params_dict: T_JSON_DICT = dict()
    params_dict['x'] = x
    params_dict['y'] = y
    if include_user_agent_shadow_dom is not None:
        params_dict['includeUserAgentShadowDOM'
            ] = include_user_agent_shadow_dom
    if ignore_pointer_events_none is not None:
        params_dict['ignorePointerEventsNone'] = ignore_pointer_events_none
    cmd_dict = {'method': 'DOM.getNodeForLocation', 'params': params_dict}
    json_result = yield cmd_dict
    return BackendNodeId.from_json(json_result['backendNodeId']
        ), page.FrameId.from_json(json_result['frameId']), NodeId.from_json(
        json_result['nodeId']) if json_result.get('nodeId'
        ) is not None else None


def get_node_stack_traces(node_id: NodeId) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, typing.Optional[runtime.StackTrace]]:
    """Gets stack traces associated with a Node. As of now, only provides stack trace for Node creation.

**EXPERIMENTAL**

:param ...:

:param node_id: Id of the node to get stack traces for.


:returns: *(Optional)* Creation stack trace, if available."""
    params_dict: T_JSON_DICT = dict()
    params_dict['nodeId'] = node_id.to_json()
    cmd_dict = {'method': 'DOM.getNodeStackTraces', 'params': params_dict}
    json_result = yield cmd_dict
    return runtime.StackTrace.from_json(json_result['creation']
        ) if json_result.get('creation') is not None else None


def get_nodes_for_subtree_by_style(node_id: NodeId, computed_styles: typing
    .List[CSSComputedStyleProperty], pierce: typing.Optional[bool]=None
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, typing.List[NodeId]]:
    """Finds nodes with a given computed style in a subtree.

**EXPERIMENTAL**

:param ...:

:param node_id: Node ID pointing to the root of a subtree.

:param computed_styles: The style to filter nodes by (includes nodes if any of properties matches).

:param pierce: *(Optional)* Whether or not iframes and shadow roots in the same target should be traversed when returning the results (default is false).


:returns: Resulting nodes."""
    params_dict: T_JSON_DICT = dict()
    params_dict['nodeId'] = node_id.to_json()
    params_dict['computedStyles'] = [i.to_json() for i in computed_styles]
    if pierce is not None:
        params_dict['pierce'] = pierce
    cmd_dict = {'method': 'DOM.getNodesForSubtreeByStyle', 'params':
        params_dict}
    json_result = yield cmd_dict
    return [NodeId.from_json(i) for i in json_result['nodeIds']]


def get_outer_html(node_id: typing.Optional[NodeId]=None, backend_node_id:
    typing.Optional[BackendNodeId]=None, object_id: typing.Optional[runtime
    .RemoteObjectId]=None) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """Returns node's HTML markup.

:param ...:

:param node_id: *(Optional)* Identifier of the node.

:param backend_node_id: *(Optional)* Identifier of the backend node.

:param object_id: *(Optional)* JavaScript object id of the node wrapper.


:returns: Outer HTML markup."""
    params_dict: T_JSON_DICT = dict()
    if node_id is not None:
        params_dict['nodeId'] = node_id.to_json()
    if backend_node_id is not None:
        params_dict['backendNodeId'] = backend_node_id.to_json()
    if object_id is not None:
        params_dict['objectId'] = object_id.to_json()
    cmd_dict = {'method': 'DOM.getOuterHTML', 'params': params_dict}
    json_result = yield cmd_dict
    return json_result['outerHTML']


def get_querying_descendants_for_container(node_id: NodeId) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, typing.List[NodeId]]:
    """Returns the descendants of a container query container that have
container queries against this container.

**EXPERIMENTAL**

:param ...:

:param node_id: Id of the container node to find querying descendants from.


:returns: Descendant nodes with container queries against the given container."""
    params_dict: T_JSON_DICT = dict()
    params_dict['nodeId'] = node_id.to_json()
    cmd_dict = {'method': 'DOM.getQueryingDescendantsForContainer',
        'params': params_dict}
    json_result = yield cmd_dict
    return [NodeId.from_json(i) for i in json_result['nodeIds']]


def get_relayout_boundary(node_id: NodeId) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, NodeId]:
    """Returns the id of the nearest ancestor that is a relayout boundary.

**EXPERIMENTAL**

:param ...:

:param node_id: Id of the node.


:returns: Relayout boundary node id for the given node."""
    params_dict: T_JSON_DICT = dict()
    params_dict['nodeId'] = node_id.to_json()
    cmd_dict = {'method': 'DOM.getRelayoutBoundary', 'params': params_dict}
    json_result = yield cmd_dict
    return NodeId.from_json(json_result['nodeId'])


def get_search_results(search_id: str, from_index: int, to_index: int
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, typing.List[NodeId]]:
    """Returns search results from given ``fromIndex`` to given ``toIndex`` from the search with the given
identifier.

**EXPERIMENTAL**

:param ...:

:param search_id: Unique search session identifier.

:param from_index: Start index of the search result to be returned.

:param to_index: End index of the search result to be returned.


:returns: Ids of the search result nodes."""
    params_dict: T_JSON_DICT = dict()
    params_dict['searchId'] = search_id
    params_dict['fromIndex'] = from_index
    params_dict['toIndex'] = to_index
    cmd_dict = {'method': 'DOM.getSearchResults', 'params': params_dict}
    json_result = yield cmd_dict
    return [NodeId.from_json(i) for i in json_result['nodeIds']]


def get_top_layer_elements() ->typing.Generator[T_JSON_DICT, T_JSON_DICT,
    typing.List[NodeId]]:
    """Returns NodeIds of current top layer elements.
Top layer is rendered closest to the user within a viewport, therefore its elements always
appear on top of all other content.

**EXPERIMENTAL**


:returns: NodeIds of top layer elements"""
    cmd_dict = {'method': 'DOM.getTopLayerElements'}
    json_result = yield cmd_dict
    return [NodeId.from_json(i) for i in json_result['nodeIds']]


def hide_highlight() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Hides any highlight.

Redirects to command 'Overlay'."""
    cmd_dict = {'method': 'DOM.hideHighlight'}
    json_result = yield cmd_dict
    return None


def highlight_node() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Highlights DOM node.

Redirects to command 'Overlay'."""
    cmd_dict = {'method': 'DOM.highlightNode'}
    json_result = yield cmd_dict
    return None


def highlight_rect() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Highlights given rectangle.

Redirects to command 'Overlay'."""
    cmd_dict = {'method': 'DOM.highlightRect'}
    json_result = yield cmd_dict
    return None


def mark_undoable_state() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Marks last undoable state.

**EXPERIMENTAL**"""
    cmd_dict = {'method': 'DOM.markUndoableState'}
    json_result = yield cmd_dict
    return None


def move_to(node_id: NodeId, target_node_id: NodeId, insert_before_node_id:
    typing.Optional[NodeId]=None) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, NodeId]:
    """Moves node into the new container, places it before the given anchor.

:param ...:

:param node_id: Id of the node to move.

:param target_node_id: Id of the element to drop the moved node into.

:param insert_before_node_id: *(Optional)* Drop node before this one (if absent, the moved node becomes the last child of ``targetNodeId``).


:returns: New id of the moved node."""
    params_dict: T_JSON_DICT = dict()
    params_dict['nodeId'] = node_id.to_json()
    params_dict['targetNodeId'] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params_dict['insertBeforeNodeId'] = insert_before_node_id.to_json()
    cmd_dict = {'method': 'DOM.moveTo', 'params': params_dict}
    json_result = yield cmd_dict
    return NodeId.from_json(json_result['nodeId'])


def perform_search(query: str, include_user_agent_shadow_dom: typing.
    Optional[bool]=None) ->typing.Generator[T_JSON_DICT, T_JSON_DICT,
    typing.Tuple[str, int]]:
    """Searches for a given string in the DOM tree. Use ``getSearchResults`` to access search results or
``cancelSearch`` to end this search session.

**EXPERIMENTAL**

:param ...:

:param query: Plain text or query selector or XPath search query.

:param include_user_agent_shadow_dom: *(Optional)* True to search in user agent shadow DOM.


:returns: A tuple with the following items:

    1. **searchId** - Unique search session identifier.
    2. **resultCount** - Number of search results."""
    params_dict: T_JSON_DICT = dict()
    params_dict['query'] = query
    if include_user_agent_shadow_dom is not None:
        params_dict['includeUserAgentShadowDOM'
            ] = include_user_agent_shadow_dom
    cmd_dict = {'method': 'DOM.performSearch', 'params': params_dict}
    json_result = yield cmd_dict
    return json_result['searchId'], json_result['resultCount']


def push_node_by_path_to_frontend(path: str) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, NodeId]:
    """Requests that the node is sent to the caller given its path. // FIXME, use XPath

**EXPERIMENTAL**

:param ...:

:param path: Path to node in the proprietary format.


:returns: Id of the node for given path."""
    params_dict: T_JSON_DICT = dict()
    params_dict['path'] = path
    cmd_dict = {'method': 'DOM.pushNodeByPathToFrontend', 'params': params_dict
        }
    json_result = yield cmd_dict
    return NodeId.from_json(json_result['nodeId'])


def push_nodes_by_backend_ids_to_frontend(backend_node_ids: typing.List[
    BackendNodeId]) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, typing.
    List[NodeId]]:
    """Requests that a batch of nodes is sent to the caller given their backend node ids.

**EXPERIMENTAL**

:param ...:

:param backend_node_ids: The array of backend node ids.


:returns: The array of ids of pushed nodes that correspond to the backend ids specified in backendNodeIds."""
    params_dict: T_JSON_DICT = dict()
    params_dict['backendNodeIds'] = [i.to_json() for i in backend_node_ids]
    cmd_dict = {'method': 'DOM.pushNodesByBackendIdsToFrontend', 'params':
        params_dict}
    json_result = yield cmd_dict
    return [NodeId.from_json(i) for i in json_result['nodeIds']]


def query_selector(node_id: NodeId, selector: str) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, NodeId]:
    """Executes ``querySelector`` on a given node.

:param ...:

:param node_id: Id of the node to query upon.

:param selector: Selector string.


:returns: Query selector result."""
    params_dict: T_JSON_DICT = dict()
    params_dict['nodeId'] = node_id.to_json()
    params_dict['selector'] = selector
    cmd_dict = {'method': 'DOM.querySelector', 'params': params_dict}
    json_result = yield cmd_dict
    return NodeId.from_json(json_result['nodeId'])


def query_selector_all(node_id: NodeId, selector: str) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, typing.List[NodeId]]:
    """Executes ``querySelectorAll`` on a given node.

:param ...:

:param node_id: Id of the node to query upon.

:param selector: Selector string.


:returns: Query selector result."""
    params_dict: T_JSON_DICT = dict()
    params_dict['nodeId'] = node_id.to_json()
    params_dict['selector'] = selector
    cmd_dict = {'method': 'DOM.querySelectorAll', 'params': params_dict}
    json_result = yield cmd_dict
    return [NodeId.from_json(i) for i in json_result['nodeIds']]


def redo() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Re-does the last undone action.

**EXPERIMENTAL**"""
    cmd_dict = {'method': 'DOM.redo'}
    json_result = yield cmd_dict
    return None


def remove_attribute(node_id: NodeId, name: str) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, None]:
    """Removes attribute with given name from an element with given id.

:param ...:

:param node_id: Id of the element to remove attribute from.

:param name: Name of the attribute to remove."""
    params_dict: T_JSON_DICT = dict()
    params_dict['nodeId'] = node_id.to_json()
    params_dict['name'] = name
    cmd_dict = {'method': 'DOM.removeAttribute', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def remove_node(node_id: NodeId) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, None]:
    """Removes node with given id.

:param ...:

:param node_id: Id of the node to remove."""
    params_dict: T_JSON_DICT = dict()
    params_dict['nodeId'] = node_id.to_json()
    cmd_dict = {'method': 'DOM.removeNode', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def request_child_nodes(node_id: NodeId, depth: typing.Optional[int]=None,
    pierce: typing.Optional[bool]=None) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, None]:
    """Requests that children of the node with given id are returned to the caller in form of
``setChildNodes`` events where not only immediate children are retrieved, but all children down to
the specified depth.

:param ...:

:param node_id: Id of the node to get children for.

:param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.

:param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the sub-tree (default is false)."""
    params_dict: T_JSON_DICT = dict()
    params_dict['nodeId'] = node_id.to_json()
    if depth is not None:
        params_dict['depth'] = depth
    if pierce is not None:
        params_dict['pierce'] = pierce
    cmd_dict = {'method': 'DOM.requestChildNodes', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def request_node(object_id: runtime.RemoteObjectId) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, NodeId]:
    """Requests that the node is sent to the caller given the JavaScript node object reference. All
nodes that form the path from the node to the root are also sent to the client as a series of
``setChildNodes`` notifications.

:param ...:

:param object_id: JavaScript object id to convert into node.


:returns: Node id for given object."""
    params_dict: T_JSON_DICT = dict()
    params_dict['objectId'] = object_id.to_json()
    cmd_dict = {'method': 'DOM.requestNode', 'params': params_dict}
    json_result = yield cmd_dict
    return NodeId.from_json(json_result['nodeId'])


def resolve_node(node_id: typing.Optional[NodeId]=None, backend_node_id:
    typing.Optional[BackendNodeId]=None, object_group: typing.Optional[str]
    =None, execution_context_id: typing.Optional[runtime.ExecutionContextId
    ]=None) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, runtime.RemoteObject]:
    """Resolves the JavaScript node object for a given NodeId or BackendNodeId.

:param ...:

:param node_id: *(Optional)* Id of the node to resolve.

:param backend_node_id: *(Optional)* Backend identifier of the node to resolve.

:param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.

:param execution_context_id: *(Optional)* Execution context in which to resolve the node.


:returns: JavaScript object wrapper for given node."""
    params_dict: T_JSON_DICT = dict()
    if node_id is not None:
        params_dict['nodeId'] = node_id.to_json()
    if backend_node_id is not None:
        params_dict['backendNodeId'] = backend_node_id.to_json()
    if object_group is not None:
        params_dict['objectGroup'] = object_group
    if execution_context_id is not None:
        params_dict['executionContextId'] = execution_context_id.to_json()
    cmd_dict = {'method': 'DOM.resolveNode', 'params': params_dict}
    json_result = yield cmd_dict
    return runtime.RemoteObject.from_json(json_result['object'])


def scroll_into_view_if_needed(node_id: typing.Optional[NodeId]=None,
    backend_node_id: typing.Optional[BackendNodeId]=None, object_id: typing
    .Optional[runtime.RemoteObjectId]=None, rect: typing.Optional[Rect]=None
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Scrolls the specified rect of the given node into view if not already visible.
Note: exactly one between nodeId, backendNodeId and objectId should be passed
to identify the node.

:param ...:

:param node_id: *(Optional)* Identifier of the node.

:param backend_node_id: *(Optional)* Identifier of the backend node.

:param object_id: *(Optional)* JavaScript object id of the node wrapper.

:param rect: *(Optional)* The rect to be scrolled into view, relative to the node's border box, in CSS pixels. When omitted, center of the node will be used, similar to Element.scrollIntoView."""
    params_dict: T_JSON_DICT = dict()
    if node_id is not None:
        params_dict['nodeId'] = node_id.to_json()
    if backend_node_id is not None:
        params_dict['backendNodeId'] = backend_node_id.to_json()
    if object_id is not None:
        params_dict['objectId'] = object_id.to_json()
    if rect is not None:
        params_dict['rect'] = rect.to_json()
    cmd_dict = {'method': 'DOM.scrollIntoViewIfNeeded', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def set_attribute_value(node_id: NodeId, name: str, value: str
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Sets attribute for an element with given id.

:param ...:

:param node_id: Id of the element to set attribute for.

:param name: Attribute name.

:param value: Attribute value."""
    params_dict: T_JSON_DICT = dict()
    params_dict['nodeId'] = node_id.to_json()
    params_dict['name'] = name
    params_dict['value'] = value
    cmd_dict = {'method': 'DOM.setAttributeValue', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def set_attributes_as_text(node_id: NodeId, text: str, name: typing.
    Optional[str]=None) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Sets attributes on element with given id. This method is useful when user edits some existing
attribute value and types in several attribute name/value pairs.

:param ...:

:param node_id: Id of the element to set attributes for.

:param text: Text with a number of attributes. Will parse this text using HTML parser.

:param name: *(Optional)* Attribute name to replace with new attributes derived from text in case text parsed successfully."""
    params_dict: T_JSON_DICT = dict()
    params_dict['nodeId'] = node_id.to_json()
    params_dict['text'] = text
    if name is not None:
        params_dict['name'] = name
    cmd_dict = {'method': 'DOM.setAttributesAsText', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def set_file_input_files(files: typing.List[str], node_id: typing.Optional[
    NodeId]=None, backend_node_id: typing.Optional[BackendNodeId]=None,
    object_id: typing.Optional[runtime.RemoteObjectId]=None
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Sets files for the given file input element.

:param ...:

:param files: Array of file paths to set.

:param node_id: *(Optional)* Identifier of the node.

:param backend_node_id: *(Optional)* Identifier of the backend node.

:param object_id: *(Optional)* JavaScript object id of the node wrapper."""
    params_dict: T_JSON_DICT = dict()
    params_dict['files'] = [i for i in files]
    if node_id is not None:
        params_dict['nodeId'] = node_id.to_json()
    if backend_node_id is not None:
        params_dict['backendNodeId'] = backend_node_id.to_json()
    if object_id is not None:
        params_dict['objectId'] = object_id.to_json()
    cmd_dict = {'method': 'DOM.setFileInputFiles', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def set_inspected_node(node_id: NodeId) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, None]:
    """Enables console to refer to the node with given id via $x (see Command Line API for more details
$x functions).

**EXPERIMENTAL**

:param ...:

:param node_id: DOM node id to be accessible by means of $x command line API."""
    params_dict: T_JSON_DICT = dict()
    params_dict['nodeId'] = node_id.to_json()
    cmd_dict = {'method': 'DOM.setInspectedNode', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def set_node_name(node_id: NodeId, name: str) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, NodeId]:
    """Sets node name for a node with given id.

:param ...:

:param node_id: Id of the node to set name for.

:param name: New node's name.


:returns: New node's id."""
    params_dict: T_JSON_DICT = dict()
    params_dict['nodeId'] = node_id.to_json()
    params_dict['name'] = name
    cmd_dict = {'method': 'DOM.setNodeName', 'params': params_dict}
    json_result = yield cmd_dict
    return NodeId.from_json(json_result['nodeId'])


def set_node_stack_traces_enabled(enable: bool) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, None]:
    """Sets if stack traces should be captured for Nodes. See ``Node.getNodeStackTraces``. Default is disabled.

**EXPERIMENTAL**

:param ...:

:param enable: Enable or disable."""
    params_dict: T_JSON_DICT = dict()
    params_dict['enable'] = enable
    cmd_dict = {'method': 'DOM.setNodeStackTracesEnabled', 'params':
        params_dict}
    json_result = yield cmd_dict
    return None


def set_node_value(node_id: NodeId, value: str) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, None]:
    """Sets node value for a node with given id.

:param ...:

:param node_id: Id of the node to set value for.

:param value: New node's value."""
    params_dict: T_JSON_DICT = dict()
    params_dict['nodeId'] = node_id.to_json()
    params_dict['value'] = value
    cmd_dict = {'method': 'DOM.setNodeValue', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def set_outer_html(node_id: NodeId, outer_html: str) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, None]:
    """Sets node HTML markup, returns new node id.

:param ...:

:param node_id: Id of the node to set markup for.

:param outer_html: Outer HTML markup to set."""
    params_dict: T_JSON_DICT = dict()
    params_dict['nodeId'] = node_id.to_json()
    params_dict['outerHTML'] = outer_html
    cmd_dict = {'method': 'DOM.setOuterHTML', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def undo() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Undoes the last performed action.

**EXPERIMENTAL**"""
    cmd_dict = {'method': 'DOM.undo'}
    json_result = yield cmd_dict
    return None


@event_class('DOM.attributeModified')
@dataclass
class AttributeModified:
    """Fired when ``Element``'s attribute is modified."""
    node_id: NodeId
    name: str
    value: str

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->AttributeModified:
        return cls(node_id=NodeId.from_json(json_obj['nodeId']), name=
            json_obj['name'], value=json_obj['value'])


@event_class('DOM.attributeRemoved')
@dataclass
class AttributeRemoved:
    """Fired when ``Element``'s attribute is removed."""
    node_id: NodeId
    name: str

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->AttributeRemoved:
        return cls(node_id=NodeId.from_json(json_obj['nodeId']), name=
            json_obj['name'])


@event_class('DOM.characterDataModified')
@dataclass
class CharacterDataModified:
    """Mirrors ``DOMCharacterDataModified`` event."""
    node_id: NodeId
    character_data: str

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->CharacterDataModified:
        return cls(node_id=NodeId.from_json(json_obj['nodeId']),
            character_data=json_obj['characterData'])


@event_class('DOM.childNodeCountUpdated')
@dataclass
class ChildNodeCountUpdated:
    """Fired when ``Container``'s child node count has changed."""
    node_id: NodeId
    child_node_count: int

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->ChildNodeCountUpdated:
        return cls(node_id=NodeId.from_json(json_obj['nodeId']),
            child_node_count=json_obj['childNodeCount'])


@event_class('DOM.childNodeInserted')
@dataclass
class ChildNodeInserted:
    """Mirrors ``DOMNodeInserted`` event."""
    parent_node_id: NodeId
    previous_node_id: NodeId
    node: Node

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->ChildNodeInserted:
        return cls(parent_node_id=NodeId.from_json(json_obj['parentNodeId']
            ), previous_node_id=NodeId.from_json(json_obj['previousNodeId']
            ), node=Node.from_json(json_obj['node']))


@event_class('DOM.childNodeRemoved')
@dataclass
class ChildNodeRemoved:
    """Mirrors ``DOMNodeRemoved`` event."""
    parent_node_id: NodeId
    node_id: NodeId

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->ChildNodeRemoved:
        return cls(parent_node_id=NodeId.from_json(json_obj['parentNodeId']
            ), node_id=NodeId.from_json(json_obj['nodeId']))


@event_class('DOM.distributedNodesUpdated')
@dataclass
class DistributedNodesUpdated:
    """**EXPERIMENTAL**

Called when distribution is changed."""
    insertion_point_id: NodeId
    distributed_nodes: typing.List[BackendNode]

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->DistributedNodesUpdated:
        return cls(insertion_point_id=NodeId.from_json(json_obj[
            'insertionPointId']), distributed_nodes=[BackendNode.from_json(
            i) for i in json_obj['distributedNodes']])


@event_class('DOM.documentUpdated')
@dataclass
class DocumentUpdated:
    """Fired when ``Document`` has been totally updated. Node ids are no longer valid."""
    pass

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->DocumentUpdated:
        return cls()


@event_class('DOM.inlineStyleInvalidated')
@dataclass
class InlineStyleInvalidated:
    """**EXPERIMENTAL**

Fired when ``Element``'s inline style is modified via a CSS property modification."""
    node_ids: typing.List[NodeId]

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->InlineStyleInvalidated:
        return cls(node_ids=[NodeId.from_json(i) for i in json_obj['nodeIds']])


@event_class('DOM.pseudoElementAdded')
@dataclass
class PseudoElementAdded:
    """**EXPERIMENTAL**

Called when a pseudo element is added to an element."""
    parent_id: NodeId
    pseudo_element: Node

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->PseudoElementAdded:
        return cls(parent_id=NodeId.from_json(json_obj['parentId']),
            pseudo_element=Node.from_json(json_obj['pseudoElement']))


@event_class('DOM.pseudoElementRemoved')
@dataclass
class PseudoElementRemoved:
    """**EXPERIMENTAL**

Called when a pseudo element is removed from an element."""
    parent_id: NodeId
    pseudo_element_id: NodeId

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->PseudoElementRemoved:
        return cls(parent_id=NodeId.from_json(json_obj['parentId']),
            pseudo_element_id=NodeId.from_json(json_obj['pseudoElementId']))


@event_class('DOM.scrollableFlagUpdated')
@dataclass
class ScrollableFlagUpdated:
    """**EXPERIMENTAL**

Fired when a node's scrollability state changes."""
    node_id: NodeId
    is_scrollable: bool

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->ScrollableFlagUpdated:
        return cls(node_id=NodeId.from_json(json_obj['nodeId']),
            is_scrollable=json_obj['isScrollable'])


@event_class('DOM.setChildNodes')
@dataclass
class SetChildNodes:
    """Fired when backend wants to provide client with the missing DOM structure. This happens upon
most of the calls requesting node ids."""
    parent_id: NodeId
    nodes: typing.List[Node]

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->SetChildNodes:
        return cls(parent_id=NodeId.from_json(json_obj['parentId']), nodes=
            [Node.from_json(i) for i in json_obj['nodes']])


@event_class('DOM.shadowRootPopped')
@dataclass
class ShadowRootPopped:
    """**EXPERIMENTAL**

Called when shadow root is popped from the element."""
    host_id: NodeId
    root_id: NodeId

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->ShadowRootPopped:
        return cls(host_id=NodeId.from_json(json_obj['hostId']), root_id=
            NodeId.from_json(json_obj['rootId']))


@event_class('DOM.shadowRootPushed')
@dataclass
class ShadowRootPushed:
    """**EXPERIMENTAL**

Called when shadow root is pushed into the element."""
    host_id: NodeId
    root: Node

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->ShadowRootPushed:
        return cls(host_id=NodeId.from_json(json_obj['hostId']), root=Node.
            from_json(json_obj['root']))


@event_class('DOM.topLayerElementsUpdated')
@dataclass
class TopLayerElementsUpdated:
    """**EXPERIMENTAL**

Called when top layer elements are changed."""
    pass

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->TopLayerElementsUpdated:
        return cls()
