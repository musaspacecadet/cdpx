# # DO NOT EDIT THIS FILE!
# #
# # This file is generated from the CDP specification using AST. If you need to make
# # changes, edit the generator and regenerate all of the modules.

from __future__ import annotations
"""CDP domain: Autofill (experimental)

Defines commands and events for Autofill."""
import typing
import enum
from dataclasses import dataclass
from .util import T_JSON_DICT, event_class
from . import dom
from . import page
None


@dataclass
class Address:
    fields: typing.List[AddressField]

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['fields'] = [i.to_json() for i in self.fields]
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->Address:
        return cls(fields=[AddressField.from_json(i) for i in json_obj[
            'fields']])


@dataclass
class AddressField:
    name: str
    value: str

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['name'] = self.name
        json_data['value'] = self.value
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->AddressField:
        return cls(name=json_obj['name'], value=json_obj['value'])


@dataclass
class AddressFields:
    """A list of address fields."""
    fields: typing.List[AddressField]

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['fields'] = [i.to_json() for i in self.fields]
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->AddressFields:
        return cls(fields=[AddressField.from_json(i) for i in json_obj[
            'fields']])


@dataclass
class AddressUI:
    """Defines how an address can be displayed like in chrome://settings/addresses.
Address UI is a two dimensional array, each inner array is an "address information line", and when rendered in a UI surface should be displayed as such.
The following address UI for instance:
[[{name: "GIVE_NAME", value: "Jon"}, {name: "FAMILY_NAME", value: "Doe"}], [{name: "CITY", value: "Munich"}, {name: "ZIP", value: "81456"}]]
should allow the receiver to render:
Jon Doe
Munich 81456"""
    address_fields: typing.List[AddressFields]

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['addressFields'] = [i.to_json() for i in self.address_fields]
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->AddressUI:
        return cls(address_fields=[AddressFields.from_json(i) for i in
            json_obj['addressFields']])


@dataclass
class CreditCard:
    number: str
    name: str
    expiry_month: str
    expiry_year: str
    cvc: str

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['number'] = self.number
        json_data['name'] = self.name
        json_data['expiryMonth'] = self.expiry_month
        json_data['expiryYear'] = self.expiry_year
        json_data['cvc'] = self.cvc
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->CreditCard:
        return cls(number=json_obj['number'], name=json_obj['name'],
            expiry_month=json_obj['expiryMonth'], expiry_year=json_obj[
            'expiryYear'], cvc=json_obj['cvc'])


@dataclass
class FilledField:
    html_type: str
    id_: str
    name: str
    value: str
    autofill_type: str
    filling_strategy: FillingStrategy
    frame_id: page.FrameId
    field_id: dom.BackendNodeId

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['htmlType'] = self.html_type
        json_data['id'] = self.id_
        json_data['name'] = self.name
        json_data['value'] = self.value
        json_data['autofillType'] = self.autofill_type
        json_data['fillingStrategy'] = self.filling_strategy.to_json()
        json_data['frameId'] = self.frame_id.to_json()
        json_data['fieldId'] = self.field_id.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->FilledField:
        return cls(html_type=json_obj['htmlType'], id_=json_obj['id'], name
            =json_obj['name'], value=json_obj['value'], autofill_type=
            json_obj['autofillType'], filling_strategy=FillingStrategy.
            from_json(json_obj['fillingStrategy']), frame_id=page.FrameId.
            from_json(json_obj['frameId']), field_id=dom.BackendNodeId.
            from_json(json_obj['fieldId']))


class FillingStrategy(enum.Enum):
    """Specified whether a filled field was done so by using the html autocomplete attribute or autofill heuristics."""
    AUTOCOMPLETE_ATTRIBUTE = 'autocompleteAttribute'
    AUTOFILL_INFERRED = 'autofillInferred'

    @classmethod
    def from_json(cls, json: str) ->FillingStrategy:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<FillingStrategy.{}>'.format(self.value)


def disable() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Disables autofill domain notifications."""
    cmd_dict = {'method': 'Autofill.disable'}
    json_result = yield cmd_dict
    return None


def enable() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Enables autofill domain notifications."""
    cmd_dict = {'method': 'Autofill.enable'}
    json_result = yield cmd_dict
    return None


def set_addresses(addresses: typing.List[Address]) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, None]:
    """Set addresses so that developers can verify their forms implementation.

:param ...:

:param addresses:"""
    params_dict: T_JSON_DICT = dict()
    params_dict['addresses'] = [i.to_json() for i in addresses]
    cmd_dict = {'method': 'Autofill.setAddresses', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def trigger(field_id: dom.BackendNodeId, card: CreditCard, frame_id: typing
    .Optional[page.FrameId]=None) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, None]:
    """Trigger autofill on a form identified by the fieldId.
If the field and related form cannot be autofilled, returns an error.

:param ...:

:param field_id: Identifies a field that serves as an anchor for autofill.

:param card: Credit card information to fill out the form. Credit card data is not saved.

:param frame_id: *(Optional)* Identifies the frame that field belongs to."""
    params_dict: T_JSON_DICT = dict()
    params_dict['fieldId'] = field_id.to_json()
    if frame_id is not None:
        params_dict['frameId'] = frame_id.to_json()
    params_dict['card'] = card.to_json()
    cmd_dict = {'method': 'Autofill.trigger', 'params': params_dict}
    json_result = yield cmd_dict
    return None


@event_class('Autofill.addressFormFilled')
@dataclass
class AddressFormFilled:
    """Emitted when an address form is filled."""
    filled_fields: typing.List[FilledField]
    address_ui: AddressUI

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->AddressFormFilled:
        return cls(filled_fields=[FilledField.from_json(i) for i in
            json_obj['filledFields']], address_ui=AddressUI.from_json(
            json_obj['addressUi']))
