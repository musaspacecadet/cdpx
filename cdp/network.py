# # DO NOT EDIT THIS FILE!
# #
# # This file is generated from the CDP specification using AST. If you need to make
# # changes, edit the generator and regenerate all of the modules.

from __future__ import annotations
"""CDP domain: Network

Network domain allows tracking network activities of the page. It exposes information about http,
file, data and other requests and responses, their headers, bodies, timing, etc."""
import typing
import enum
from dataclasses import dataclass
from .util import T_JSON_DICT, event_class
from deprecated.sphinx import deprecated
from . import debugger
from . import emulation
from . import io
from . import page
from . import runtime
from . import security
None


@dataclass
class AssociatedCookie:
    """A cookie associated with the request which may or may not be sent with it.
Includes the cookies itself and reasons for blocking or exemption."""
    cookie: Cookie
    blocked_reasons: typing.List[CookieBlockedReason]
    exemption_reason: typing.Optional[CookieExemptionReason] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['cookie'] = self.cookie.to_json()
        json_data['blockedReasons'] = [i.to_json() for i in self.
            blocked_reasons]
        if self.exemption_reason is not None:
            json_data['exemptionReason'] = self.exemption_reason.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->AssociatedCookie:
        return cls(cookie=Cookie.from_json(json_obj['cookie']),
            blocked_reasons=[CookieBlockedReason.from_json(i) for i in
            json_obj['blockedReasons']], exemption_reason=
            CookieExemptionReason.from_json(json_obj['exemptionReason']) if
            json_obj.get('exemptionReason') is not None else None)


@dataclass
class AuthChallenge:
    """Authorization challenge for HTTP status code 401 or 407."""
    origin: str
    scheme: str
    realm: str
    source: typing.Optional[str] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['origin'] = self.origin
        json_data['scheme'] = self.scheme
        json_data['realm'] = self.realm
        if self.source is not None:
            json_data['source'] = self.source
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->AuthChallenge:
        return cls(origin=json_obj['origin'], scheme=json_obj['scheme'],
            realm=json_obj['realm'], source=json_obj['source'] if json_obj.
            get('source') is not None else None)


@dataclass
class AuthChallengeResponse:
    """Response to an AuthChallenge."""
    response: str
    username: typing.Optional[str] = None
    password: typing.Optional[str] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['response'] = self.response
        if self.username is not None:
            json_data['username'] = self.username
        if self.password is not None:
            json_data['password'] = self.password
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->AuthChallengeResponse:
        return cls(response=json_obj['response'], username=json_obj[
            'username'] if json_obj.get('username') is not None else None,
            password=json_obj['password'] if json_obj.get('password') is not
            None else None)


@dataclass
class BlockedSetCookieWithReason:
    """A cookie which was not stored from a response with the corresponding reason."""
    blocked_reasons: typing.List[SetCookieBlockedReason]
    cookie_line: str
    cookie: typing.Optional[Cookie] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['blockedReasons'] = [i.to_json() for i in self.
            blocked_reasons]
        json_data['cookieLine'] = self.cookie_line
        if self.cookie is not None:
            json_data['cookie'] = self.cookie.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->BlockedSetCookieWithReason:
        return cls(blocked_reasons=[SetCookieBlockedReason.from_json(i) for
            i in json_obj['blockedReasons']], cookie_line=json_obj[
            'cookieLine'], cookie=Cookie.from_json(json_obj['cookie']) if 
            json_obj.get('cookie') is not None else None)


@dataclass
class CachedResource:
    """Information about the cached resource."""
    url: str
    type_: ResourceType
    body_size: float
    response: typing.Optional[Response] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['url'] = self.url
        json_data['type'] = self.type_.to_json()
        json_data['bodySize'] = self.body_size
        if self.response is not None:
            json_data['response'] = self.response.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->CachedResource:
        return cls(url=json_obj['url'], type_=ResourceType.from_json(
            json_obj['type']), body_size=json_obj['bodySize'], response=
            Response.from_json(json_obj['response']) if json_obj.get(
            'response') is not None else None)


@dataclass
class ClientSecurityState:
    initiator_is_secure_context: bool
    initiator_ip_address_space: IPAddressSpace
    private_network_request_policy: PrivateNetworkRequestPolicy

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['initiatorIsSecureContext'
            ] = self.initiator_is_secure_context
        json_data['initiatorIPAddressSpace'
            ] = self.initiator_ip_address_space.to_json()
        json_data['privateNetworkRequestPolicy'
            ] = self.private_network_request_policy.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->ClientSecurityState:
        return cls(initiator_is_secure_context=json_obj[
            'initiatorIsSecureContext'], initiator_ip_address_space=
            IPAddressSpace.from_json(json_obj['initiatorIPAddressSpace']),
            private_network_request_policy=PrivateNetworkRequestPolicy.
            from_json(json_obj['privateNetworkRequestPolicy']))


@dataclass
class ConnectTiming:
    request_time: float

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['requestTime'] = self.request_time
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->ConnectTiming:
        return cls(request_time=json_obj['requestTime'])


@dataclass
class ContentSecurityPolicyStatus:
    effective_directives: str
    is_enforced: bool
    source: ContentSecurityPolicySource

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['effectiveDirectives'] = self.effective_directives
        json_data['isEnforced'] = self.is_enforced
        json_data['source'] = self.source.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->ContentSecurityPolicyStatus:
        return cls(effective_directives=json_obj['effectiveDirectives'],
            is_enforced=json_obj['isEnforced'], source=
            ContentSecurityPolicySource.from_json(json_obj['source']))


@dataclass
class Cookie:
    """Cookie object"""
    name: str
    value: str
    domain: str
    path: str
    expires: float
    size: int
    http_only: bool
    secure: bool
    session: bool
    priority: CookiePriority
    same_party: bool
    source_scheme: CookieSourceScheme
    source_port: int
    same_site: typing.Optional[CookieSameSite] = None
    partition_key: typing.Optional[CookiePartitionKey] = None
    partition_key_opaque: typing.Optional[bool] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['name'] = self.name
        json_data['value'] = self.value
        json_data['domain'] = self.domain
        json_data['path'] = self.path
        json_data['expires'] = self.expires
        json_data['size'] = self.size
        json_data['httpOnly'] = self.http_only
        json_data['secure'] = self.secure
        json_data['session'] = self.session
        json_data['priority'] = self.priority.to_json()
        json_data['sameParty'] = self.same_party
        json_data['sourceScheme'] = self.source_scheme.to_json()
        json_data['sourcePort'] = self.source_port
        if self.same_site is not None:
            json_data['sameSite'] = self.same_site.to_json()
        if self.partition_key is not None:
            json_data['partitionKey'] = self.partition_key.to_json()
        if self.partition_key_opaque is not None:
            json_data['partitionKeyOpaque'] = self.partition_key_opaque
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->Cookie:
        return cls(name=json_obj['name'], value=json_obj['value'], domain=
            json_obj['domain'], path=json_obj['path'], expires=json_obj[
            'expires'], size=json_obj['size'], http_only=json_obj[
            'httpOnly'], secure=json_obj['secure'], session=json_obj[
            'session'], priority=CookiePriority.from_json(json_obj[
            'priority']), same_party=json_obj['sameParty'], source_scheme=
            CookieSourceScheme.from_json(json_obj['sourceScheme']),
            source_port=json_obj['sourcePort'], same_site=CookieSameSite.
            from_json(json_obj['sameSite']) if json_obj.get('sameSite') is not
            None else None, partition_key=CookiePartitionKey.from_json(
            json_obj['partitionKey']) if json_obj.get('partitionKey') is not
            None else None, partition_key_opaque=json_obj[
            'partitionKeyOpaque'] if json_obj.get('partitionKeyOpaque') is not
            None else None)


@dataclass
class CookieParam:
    """Cookie parameter object"""
    name: str
    value: str
    url: typing.Optional[str] = None
    domain: typing.Optional[str] = None
    path: typing.Optional[str] = None
    secure: typing.Optional[bool] = None
    http_only: typing.Optional[bool] = None
    same_site: typing.Optional[CookieSameSite] = None
    expires: typing.Optional[TimeSinceEpoch] = None
    priority: typing.Optional[CookiePriority] = None
    same_party: typing.Optional[bool] = None
    source_scheme: typing.Optional[CookieSourceScheme] = None
    source_port: typing.Optional[int] = None
    partition_key: typing.Optional[CookiePartitionKey] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['name'] = self.name
        json_data['value'] = self.value
        if self.url is not None:
            json_data['url'] = self.url
        if self.domain is not None:
            json_data['domain'] = self.domain
        if self.path is not None:
            json_data['path'] = self.path
        if self.secure is not None:
            json_data['secure'] = self.secure
        if self.http_only is not None:
            json_data['httpOnly'] = self.http_only
        if self.same_site is not None:
            json_data['sameSite'] = self.same_site.to_json()
        if self.expires is not None:
            json_data['expires'] = self.expires.to_json()
        if self.priority is not None:
            json_data['priority'] = self.priority.to_json()
        if self.same_party is not None:
            json_data['sameParty'] = self.same_party
        if self.source_scheme is not None:
            json_data['sourceScheme'] = self.source_scheme.to_json()
        if self.source_port is not None:
            json_data['sourcePort'] = self.source_port
        if self.partition_key is not None:
            json_data['partitionKey'] = self.partition_key.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->CookieParam:
        return cls(name=json_obj['name'], value=json_obj['value'], url=
            json_obj['url'] if json_obj.get('url') is not None else None,
            domain=json_obj['domain'] if json_obj.get('domain') is not None
             else None, path=json_obj['path'] if json_obj.get('path') is not
            None else None, secure=json_obj['secure'] if json_obj.get(
            'secure') is not None else None, http_only=json_obj['httpOnly'] if
            json_obj.get('httpOnly') is not None else None, same_site=
            CookieSameSite.from_json(json_obj['sameSite']) if json_obj.get(
            'sameSite') is not None else None, expires=TimeSinceEpoch.
            from_json(json_obj['expires']) if json_obj.get('expires') is not
            None else None, priority=CookiePriority.from_json(json_obj[
            'priority']) if json_obj.get('priority') is not None else None,
            same_party=json_obj['sameParty'] if json_obj.get('sameParty')
             is not None else None, source_scheme=CookieSourceScheme.
            from_json(json_obj['sourceScheme']) if json_obj.get(
            'sourceScheme') is not None else None, source_port=json_obj[
            'sourcePort'] if json_obj.get('sourcePort') is not None else
            None, partition_key=CookiePartitionKey.from_json(json_obj[
            'partitionKey']) if json_obj.get('partitionKey') is not None else
            None)


@dataclass
class CookiePartitionKey:
    """cookiePartitionKey object
The representation of the components of the key that are created by the cookiePartitionKey class contained in net/cookies/cookie_partition_key.h."""
    top_level_site: str
    has_cross_site_ancestor: bool

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['topLevelSite'] = self.top_level_site
        json_data['hasCrossSiteAncestor'] = self.has_cross_site_ancestor
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->CookiePartitionKey:
        return cls(top_level_site=json_obj['topLevelSite'],
            has_cross_site_ancestor=json_obj['hasCrossSiteAncestor'])


@dataclass
class CorsErrorStatus:
    cors_error: CorsError
    failed_parameter: str

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['corsError'] = self.cors_error.to_json()
        json_data['failedParameter'] = self.failed_parameter
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->CorsErrorStatus:
        return cls(cors_error=CorsError.from_json(json_obj['corsError']),
            failed_parameter=json_obj['failedParameter'])


@dataclass
class CrossOriginEmbedderPolicyStatus:
    value: CrossOriginEmbedderPolicyValue
    report_only_value: CrossOriginEmbedderPolicyValue
    reporting_endpoint: typing.Optional[str] = None
    report_only_reporting_endpoint: typing.Optional[str] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['value'] = self.value.to_json()
        json_data['reportOnlyValue'] = self.report_only_value.to_json()
        if self.reporting_endpoint is not None:
            json_data['reportingEndpoint'] = self.reporting_endpoint
        if self.report_only_reporting_endpoint is not None:
            json_data['reportOnlyReportingEndpoint'
                ] = self.report_only_reporting_endpoint
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT
        ) ->CrossOriginEmbedderPolicyStatus:
        return cls(value=CrossOriginEmbedderPolicyValue.from_json(json_obj[
            'value']), report_only_value=CrossOriginEmbedderPolicyValue.
            from_json(json_obj['reportOnlyValue']), reporting_endpoint=
            json_obj['reportingEndpoint'] if json_obj.get(
            'reportingEndpoint') is not None else None,
            report_only_reporting_endpoint=json_obj[
            'reportOnlyReportingEndpoint'] if json_obj.get(
            'reportOnlyReportingEndpoint') is not None else None)


@dataclass
class CrossOriginOpenerPolicyStatus:
    value: CrossOriginOpenerPolicyValue
    report_only_value: CrossOriginOpenerPolicyValue
    reporting_endpoint: typing.Optional[str] = None
    report_only_reporting_endpoint: typing.Optional[str] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['value'] = self.value.to_json()
        json_data['reportOnlyValue'] = self.report_only_value.to_json()
        if self.reporting_endpoint is not None:
            json_data['reportingEndpoint'] = self.reporting_endpoint
        if self.report_only_reporting_endpoint is not None:
            json_data['reportOnlyReportingEndpoint'
                ] = self.report_only_reporting_endpoint
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->CrossOriginOpenerPolicyStatus:
        return cls(value=CrossOriginOpenerPolicyValue.from_json(json_obj[
            'value']), report_only_value=CrossOriginOpenerPolicyValue.
            from_json(json_obj['reportOnlyValue']), reporting_endpoint=
            json_obj['reportingEndpoint'] if json_obj.get(
            'reportingEndpoint') is not None else None,
            report_only_reporting_endpoint=json_obj[
            'reportOnlyReportingEndpoint'] if json_obj.get(
            'reportOnlyReportingEndpoint') is not None else None)


@dataclass
class DirectTCPSocketOptions:
    no_delay: bool
    keep_alive_delay: typing.Optional[float] = None
    send_buffer_size: typing.Optional[float] = None
    receive_buffer_size: typing.Optional[float] = None
    dns_query_type: typing.Optional[DirectSocketDnsQueryType] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['noDelay'] = self.no_delay
        if self.keep_alive_delay is not None:
            json_data['keepAliveDelay'] = self.keep_alive_delay
        if self.send_buffer_size is not None:
            json_data['sendBufferSize'] = self.send_buffer_size
        if self.receive_buffer_size is not None:
            json_data['receiveBufferSize'] = self.receive_buffer_size
        if self.dns_query_type is not None:
            json_data['dnsQueryType'] = self.dns_query_type.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->DirectTCPSocketOptions:
        return cls(no_delay=json_obj['noDelay'], keep_alive_delay=json_obj[
            'keepAliveDelay'] if json_obj.get('keepAliveDelay') is not None
             else None, send_buffer_size=json_obj['sendBufferSize'] if 
            json_obj.get('sendBufferSize') is not None else None,
            receive_buffer_size=json_obj['receiveBufferSize'] if json_obj.
            get('receiveBufferSize') is not None else None, dns_query_type=
            DirectSocketDnsQueryType.from_json(json_obj['dnsQueryType']) if
            json_obj.get('dnsQueryType') is not None else None)


@dataclass
class ExemptedSetCookieWithReason:
    """A cookie should have been blocked by 3PCD but is exempted and stored from a response with the
corresponding reason. A cookie could only have at most one exemption reason."""
    exemption_reason: CookieExemptionReason
    cookie_line: str
    cookie: Cookie

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['exemptionReason'] = self.exemption_reason.to_json()
        json_data['cookieLine'] = self.cookie_line
        json_data['cookie'] = self.cookie.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->ExemptedSetCookieWithReason:
        return cls(exemption_reason=CookieExemptionReason.from_json(
            json_obj['exemptionReason']), cookie_line=json_obj['cookieLine'
            ], cookie=Cookie.from_json(json_obj['cookie']))


class Headers(dict):
    """Request / response headers as keys / values of JSON object.

Represents the CDP object type 'Network.Headers'. 
Maps to a dictionary."""

    def to_json(self) ->T_JSON_DICT:
        return self

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->Headers:
        return cls(json_obj)

    def __repr__(self) ->str:
        return 'Headers({})'.format(super().__repr__())


@dataclass
class Initiator:
    """Information about the request initiator."""
    type_: str
    stack: typing.Optional[runtime.StackTrace] = None
    url: typing.Optional[str] = None
    line_number: typing.Optional[float] = None
    column_number: typing.Optional[float] = None
    request_id: typing.Optional[RequestId] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['type'] = self.type_
        if self.stack is not None:
            json_data['stack'] = self.stack.to_json()
        if self.url is not None:
            json_data['url'] = self.url
        if self.line_number is not None:
            json_data['lineNumber'] = self.line_number
        if self.column_number is not None:
            json_data['columnNumber'] = self.column_number
        if self.request_id is not None:
            json_data['requestId'] = self.request_id.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->Initiator:
        return cls(type_=json_obj['type'], stack=runtime.StackTrace.
            from_json(json_obj['stack']) if json_obj.get('stack') is not
            None else None, url=json_obj['url'] if json_obj.get('url') is not
            None else None, line_number=json_obj['lineNumber'] if json_obj.
            get('lineNumber') is not None else None, column_number=json_obj
            ['columnNumber'] if json_obj.get('columnNumber') is not None else
            None, request_id=RequestId.from_json(json_obj['requestId']) if 
            json_obj.get('requestId') is not None else None)


@dataclass
class LoadNetworkResourceOptions:
    """An options object that may be extended later to better support CORS,
CORB and streaming."""
    disable_cache: bool
    include_credentials: bool

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['disableCache'] = self.disable_cache
        json_data['includeCredentials'] = self.include_credentials
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->LoadNetworkResourceOptions:
        return cls(disable_cache=json_obj['disableCache'],
            include_credentials=json_obj['includeCredentials'])


@dataclass
class LoadNetworkResourcePageResult:
    """An object providing the result of a network resource load."""
    success: bool
    net_error: typing.Optional[float] = None
    net_error_name: typing.Optional[str] = None
    http_status_code: typing.Optional[float] = None
    stream: typing.Optional[io.StreamHandle] = None
    headers: typing.Optional[Headers] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['success'] = self.success
        if self.net_error is not None:
            json_data['netError'] = self.net_error
        if self.net_error_name is not None:
            json_data['netErrorName'] = self.net_error_name
        if self.http_status_code is not None:
            json_data['httpStatusCode'] = self.http_status_code
        if self.stream is not None:
            json_data['stream'] = self.stream.to_json()
        if self.headers is not None:
            json_data['headers'] = self.headers.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->LoadNetworkResourcePageResult:
        return cls(success=json_obj['success'], net_error=json_obj[
            'netError'] if json_obj.get('netError') is not None else None,
            net_error_name=json_obj['netErrorName'] if json_obj.get(
            'netErrorName') is not None else None, http_status_code=
            json_obj['httpStatusCode'] if json_obj.get('httpStatusCode') is not
            None else None, stream=io.StreamHandle.from_json(json_obj[
            'stream']) if json_obj.get('stream') is not None else None,
            headers=Headers.from_json(json_obj['headers']) if json_obj.get(
            'headers') is not None else None)


@dataclass
class PostDataEntry:
    """Post data entry for HTTP request"""
    bytes_: typing.Optional[str] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        if self.bytes_ is not None:
            json_data['bytes'] = self.bytes_
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->PostDataEntry:
        return cls(bytes_=json_obj['bytes'] if json_obj.get('bytes') is not
            None else None)


@dataclass
class ReportingApiEndpoint:
    url: str
    group_name: str

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['url'] = self.url
        json_data['groupName'] = self.group_name
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->ReportingApiEndpoint:
        return cls(url=json_obj['url'], group_name=json_obj['groupName'])


@dataclass
class ReportingApiReport:
    """An object representing a report generated by the Reporting API."""
    id_: ReportId
    initiator_url: str
    destination: str
    type_: str
    timestamp: TimeSinceEpoch
    depth: int
    completed_attempts: int
    body: T_JSON_DICT
    status: ReportStatus

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['id'] = self.id_.to_json()
        json_data['initiatorUrl'] = self.initiator_url
        json_data['destination'] = self.destination
        json_data['type'] = self.type_
        json_data['timestamp'] = self.timestamp.to_json()
        json_data['depth'] = self.depth
        json_data['completedAttempts'] = self.completed_attempts
        json_data['body'] = self.body
        json_data['status'] = self.status.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->ReportingApiReport:
        return cls(id_=ReportId.from_json(json_obj['id']), initiator_url=
            json_obj['initiatorUrl'], destination=json_obj['destination'],
            type_=json_obj['type'], timestamp=TimeSinceEpoch.from_json(
            json_obj['timestamp']), depth=json_obj['depth'],
            completed_attempts=json_obj['completedAttempts'], body=json_obj
            ['body'], status=ReportStatus.from_json(json_obj['status']))


@dataclass
class Request:
    """HTTP request data."""
    url: str
    method: str
    headers: Headers
    initial_priority: ResourcePriority
    referrer_policy: str
    url_fragment: typing.Optional[str] = None
    post_data: typing.Optional[str] = None
    has_post_data: typing.Optional[bool] = None
    post_data_entries: typing.Optional[typing.List[PostDataEntry]] = None
    mixed_content_type: typing.Optional[security.MixedContentType] = None
    is_link_preload: typing.Optional[bool] = None
    trust_token_params: typing.Optional[TrustTokenParams] = None
    is_same_site: typing.Optional[bool] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['url'] = self.url
        json_data['method'] = self.method
        json_data['headers'] = self.headers.to_json()
        json_data['initialPriority'] = self.initial_priority.to_json()
        json_data['referrerPolicy'] = self.referrer_policy
        if self.url_fragment is not None:
            json_data['urlFragment'] = self.url_fragment
        if self.post_data is not None:
            json_data['postData'] = self.post_data
        if self.has_post_data is not None:
            json_data['hasPostData'] = self.has_post_data
        if self.post_data_entries is not None:
            json_data['postDataEntries'] = [i.to_json() for i in self.
                post_data_entries]
        if self.mixed_content_type is not None:
            json_data['mixedContentType'] = self.mixed_content_type.to_json()
        if self.is_link_preload is not None:
            json_data['isLinkPreload'] = self.is_link_preload
        if self.trust_token_params is not None:
            json_data['trustTokenParams'] = self.trust_token_params.to_json()
        if self.is_same_site is not None:
            json_data['isSameSite'] = self.is_same_site
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->Request:
        return cls(url=json_obj['url'], method=json_obj['method'], headers=
            Headers.from_json(json_obj['headers']), initial_priority=
            ResourcePriority.from_json(json_obj['initialPriority']),
            referrer_policy=json_obj['referrerPolicy'], url_fragment=
            json_obj['urlFragment'] if json_obj.get('urlFragment') is not
            None else None, post_data=json_obj['postData'] if json_obj.get(
            'postData') is not None else None, has_post_data=json_obj[
            'hasPostData'] if json_obj.get('hasPostData') is not None else
            None, post_data_entries=[PostDataEntry.from_json(i) for i in
            json_obj['postDataEntries']] if json_obj.get('postDataEntries')
             is not None else None, mixed_content_type=security.
            MixedContentType.from_json(json_obj['mixedContentType']) if 
            json_obj.get('mixedContentType') is not None else None,
            is_link_preload=json_obj['isLinkPreload'] if json_obj.get(
            'isLinkPreload') is not None else None, trust_token_params=
            TrustTokenParams.from_json(json_obj['trustTokenParams']) if 
            json_obj.get('trustTokenParams') is not None else None,
            is_same_site=json_obj['isSameSite'] if json_obj.get(
            'isSameSite') is not None else None)


@dataclass
class RequestPattern:
    """Request pattern for interception."""
    url_pattern: typing.Optional[str] = None
    resource_type: typing.Optional[ResourceType] = None
    interception_stage: typing.Optional[InterceptionStage] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        if self.url_pattern is not None:
            json_data['urlPattern'] = self.url_pattern
        if self.resource_type is not None:
            json_data['resourceType'] = self.resource_type.to_json()
        if self.interception_stage is not None:
            json_data['interceptionStage'] = self.interception_stage.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->RequestPattern:
        return cls(url_pattern=json_obj['urlPattern'] if json_obj.get(
            'urlPattern') is not None else None, resource_type=ResourceType
            .from_json(json_obj['resourceType']) if json_obj.get(
            'resourceType') is not None else None, interception_stage=
            InterceptionStage.from_json(json_obj['interceptionStage']) if 
            json_obj.get('interceptionStage') is not None else None)


@dataclass
class ResourceTiming:
    """Timing information for the request."""
    request_time: float
    proxy_start: float
    proxy_end: float
    dns_start: float
    dns_end: float
    connect_start: float
    connect_end: float
    ssl_start: float
    ssl_end: float
    worker_start: float
    worker_ready: float
    worker_fetch_start: float
    worker_respond_with_settled: float
    send_start: float
    send_end: float
    push_start: float
    push_end: float
    receive_headers_start: float
    receive_headers_end: float
    worker_router_evaluation_start: typing.Optional[float] = None
    worker_cache_lookup_start: typing.Optional[float] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['requestTime'] = self.request_time
        json_data['proxyStart'] = self.proxy_start
        json_data['proxyEnd'] = self.proxy_end
        json_data['dnsStart'] = self.dns_start
        json_data['dnsEnd'] = self.dns_end
        json_data['connectStart'] = self.connect_start
        json_data['connectEnd'] = self.connect_end
        json_data['sslStart'] = self.ssl_start
        json_data['sslEnd'] = self.ssl_end
        json_data['workerStart'] = self.worker_start
        json_data['workerReady'] = self.worker_ready
        json_data['workerFetchStart'] = self.worker_fetch_start
        json_data['workerRespondWithSettled'
            ] = self.worker_respond_with_settled
        json_data['sendStart'] = self.send_start
        json_data['sendEnd'] = self.send_end
        json_data['pushStart'] = self.push_start
        json_data['pushEnd'] = self.push_end
        json_data['receiveHeadersStart'] = self.receive_headers_start
        json_data['receiveHeadersEnd'] = self.receive_headers_end
        if self.worker_router_evaluation_start is not None:
            json_data['workerRouterEvaluationStart'
                ] = self.worker_router_evaluation_start
        if self.worker_cache_lookup_start is not None:
            json_data['workerCacheLookupStart'
                ] = self.worker_cache_lookup_start
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->ResourceTiming:
        return cls(request_time=json_obj['requestTime'], proxy_start=
            json_obj['proxyStart'], proxy_end=json_obj['proxyEnd'],
            dns_start=json_obj['dnsStart'], dns_end=json_obj['dnsEnd'],
            connect_start=json_obj['connectStart'], connect_end=json_obj[
            'connectEnd'], ssl_start=json_obj['sslStart'], ssl_end=json_obj
            ['sslEnd'], worker_start=json_obj['workerStart'], worker_ready=
            json_obj['workerReady'], worker_fetch_start=json_obj[
            'workerFetchStart'], worker_respond_with_settled=json_obj[
            'workerRespondWithSettled'], send_start=json_obj['sendStart'],
            send_end=json_obj['sendEnd'], push_start=json_obj['pushStart'],
            push_end=json_obj['pushEnd'], receive_headers_start=json_obj[
            'receiveHeadersStart'], receive_headers_end=json_obj[
            'receiveHeadersEnd'], worker_router_evaluation_start=json_obj[
            'workerRouterEvaluationStart'] if json_obj.get(
            'workerRouterEvaluationStart') is not None else None,
            worker_cache_lookup_start=json_obj['workerCacheLookupStart'] if
            json_obj.get('workerCacheLookupStart') is not None else None)


@dataclass
class Response:
    """HTTP response data."""
    url: str
    status: int
    status_text: str
    headers: Headers
    mime_type: str
    charset: str
    connection_reused: bool
    connection_id: float
    encoded_data_length: float
    security_state: security.SecurityState
    headers_text: typing.Optional[str] = None
    request_headers: typing.Optional[Headers] = None
    request_headers_text: typing.Optional[str] = None
    remote_ip_address: typing.Optional[str] = None
    remote_port: typing.Optional[int] = None
    from_disk_cache: typing.Optional[bool] = None
    from_service_worker: typing.Optional[bool] = None
    from_prefetch_cache: typing.Optional[bool] = None
    from_early_hints: typing.Optional[bool] = None
    service_worker_router_info: typing.Optional[ServiceWorkerRouterInfo] = None
    timing: typing.Optional[ResourceTiming] = None
    service_worker_response_source: typing.Optional[ServiceWorkerResponseSource
        ] = None
    response_time: typing.Optional[TimeSinceEpoch] = None
    cache_storage_cache_name: typing.Optional[str] = None
    protocol: typing.Optional[str] = None
    alternate_protocol_usage: typing.Optional[AlternateProtocolUsage] = None
    security_details: typing.Optional[SecurityDetails] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['url'] = self.url
        json_data['status'] = self.status
        json_data['statusText'] = self.status_text
        json_data['headers'] = self.headers.to_json()
        json_data['mimeType'] = self.mime_type
        json_data['charset'] = self.charset
        json_data['connectionReused'] = self.connection_reused
        json_data['connectionId'] = self.connection_id
        json_data['encodedDataLength'] = self.encoded_data_length
        json_data['securityState'] = self.security_state.to_json()
        if self.headers_text is not None:
            json_data['headersText'] = self.headers_text
        if self.request_headers is not None:
            json_data['requestHeaders'] = self.request_headers.to_json()
        if self.request_headers_text is not None:
            json_data['requestHeadersText'] = self.request_headers_text
        if self.remote_ip_address is not None:
            json_data['remoteIPAddress'] = self.remote_ip_address
        if self.remote_port is not None:
            json_data['remotePort'] = self.remote_port
        if self.from_disk_cache is not None:
            json_data['fromDiskCache'] = self.from_disk_cache
        if self.from_service_worker is not None:
            json_data['fromServiceWorker'] = self.from_service_worker
        if self.from_prefetch_cache is not None:
            json_data['fromPrefetchCache'] = self.from_prefetch_cache
        if self.from_early_hints is not None:
            json_data['fromEarlyHints'] = self.from_early_hints
        if self.service_worker_router_info is not None:
            json_data['serviceWorkerRouterInfo'
                ] = self.service_worker_router_info.to_json()
        if self.timing is not None:
            json_data['timing'] = self.timing.to_json()
        if self.service_worker_response_source is not None:
            json_data['serviceWorkerResponseSource'
                ] = self.service_worker_response_source.to_json()
        if self.response_time is not None:
            json_data['responseTime'] = self.response_time.to_json()
        if self.cache_storage_cache_name is not None:
            json_data['cacheStorageCacheName'] = self.cache_storage_cache_name
        if self.protocol is not None:
            json_data['protocol'] = self.protocol
        if self.alternate_protocol_usage is not None:
            json_data['alternateProtocolUsage'
                ] = self.alternate_protocol_usage.to_json()
        if self.security_details is not None:
            json_data['securityDetails'] = self.security_details.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->Response:
        return cls(url=json_obj['url'], status=json_obj['status'],
            status_text=json_obj['statusText'], headers=Headers.from_json(
            json_obj['headers']), mime_type=json_obj['mimeType'], charset=
            json_obj['charset'], connection_reused=json_obj[
            'connectionReused'], connection_id=json_obj['connectionId'],
            encoded_data_length=json_obj['encodedDataLength'],
            security_state=security.SecurityState.from_json(json_obj[
            'securityState']), headers_text=json_obj['headersText'] if 
            json_obj.get('headersText') is not None else None,
            request_headers=Headers.from_json(json_obj['requestHeaders']) if
            json_obj.get('requestHeaders') is not None else None,
            request_headers_text=json_obj['requestHeadersText'] if json_obj
            .get('requestHeadersText') is not None else None,
            remote_ip_address=json_obj['remoteIPAddress'] if json_obj.get(
            'remoteIPAddress') is not None else None, remote_port=json_obj[
            'remotePort'] if json_obj.get('remotePort') is not None else
            None, from_disk_cache=json_obj['fromDiskCache'] if json_obj.get
            ('fromDiskCache') is not None else None, from_service_worker=
            json_obj['fromServiceWorker'] if json_obj.get(
            'fromServiceWorker') is not None else None, from_prefetch_cache
            =json_obj['fromPrefetchCache'] if json_obj.get(
            'fromPrefetchCache') is not None else None, from_early_hints=
            json_obj['fromEarlyHints'] if json_obj.get('fromEarlyHints') is not
            None else None, service_worker_router_info=
            ServiceWorkerRouterInfo.from_json(json_obj[
            'serviceWorkerRouterInfo']) if json_obj.get(
            'serviceWorkerRouterInfo') is not None else None, timing=
            ResourceTiming.from_json(json_obj['timing']) if json_obj.get(
            'timing') is not None else None, service_worker_response_source
            =ServiceWorkerResponseSource.from_json(json_obj[
            'serviceWorkerResponseSource']) if json_obj.get(
            'serviceWorkerResponseSource') is not None else None,
            response_time=TimeSinceEpoch.from_json(json_obj['responseTime']
            ) if json_obj.get('responseTime') is not None else None,
            cache_storage_cache_name=json_obj['cacheStorageCacheName'] if 
            json_obj.get('cacheStorageCacheName') is not None else None,
            protocol=json_obj['protocol'] if json_obj.get('protocol') is not
            None else None, alternate_protocol_usage=AlternateProtocolUsage
            .from_json(json_obj['alternateProtocolUsage']) if json_obj.get(
            'alternateProtocolUsage') is not None else None,
            security_details=SecurityDetails.from_json(json_obj[
            'securityDetails']) if json_obj.get('securityDetails') is not
            None else None)


@dataclass
class SecurityDetails:
    """Security details about a request."""
    protocol: str
    key_exchange: str
    cipher: str
    certificate_id: security.CertificateId
    subject_name: str
    san_list: typing.List[str]
    issuer: str
    valid_from: TimeSinceEpoch
    valid_to: TimeSinceEpoch
    signed_certificate_timestamp_list: typing.List[SignedCertificateTimestamp]
    certificate_transparency_compliance: CertificateTransparencyCompliance
    encrypted_client_hello: bool
    key_exchange_group: typing.Optional[str] = None
    mac: typing.Optional[str] = None
    server_signature_algorithm: typing.Optional[int] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['protocol'] = self.protocol
        json_data['keyExchange'] = self.key_exchange
        json_data['cipher'] = self.cipher
        json_data['certificateId'] = self.certificate_id.to_json()
        json_data['subjectName'] = self.subject_name
        json_data['sanList'] = [i for i in self.san_list]
        json_data['issuer'] = self.issuer
        json_data['validFrom'] = self.valid_from.to_json()
        json_data['validTo'] = self.valid_to.to_json()
        json_data['signedCertificateTimestampList'] = [i.to_json() for i in
            self.signed_certificate_timestamp_list]
        json_data['certificateTransparencyCompliance'
            ] = self.certificate_transparency_compliance.to_json()
        json_data['encryptedClientHello'] = self.encrypted_client_hello
        if self.key_exchange_group is not None:
            json_data['keyExchangeGroup'] = self.key_exchange_group
        if self.mac is not None:
            json_data['mac'] = self.mac
        if self.server_signature_algorithm is not None:
            json_data['serverSignatureAlgorithm'
                ] = self.server_signature_algorithm
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->SecurityDetails:
        return cls(protocol=json_obj['protocol'], key_exchange=json_obj[
            'keyExchange'], cipher=json_obj['cipher'], certificate_id=
            security.CertificateId.from_json(json_obj['certificateId']),
            subject_name=json_obj['subjectName'], san_list=[i for i in
            json_obj['sanList']], issuer=json_obj['issuer'], valid_from=
            TimeSinceEpoch.from_json(json_obj['validFrom']), valid_to=
            TimeSinceEpoch.from_json(json_obj['validTo']),
            signed_certificate_timestamp_list=[SignedCertificateTimestamp.
            from_json(i) for i in json_obj['signedCertificateTimestampList'
            ]], certificate_transparency_compliance=
            CertificateTransparencyCompliance.from_json(json_obj[
            'certificateTransparencyCompliance']), encrypted_client_hello=
            json_obj['encryptedClientHello'], key_exchange_group=json_obj[
            'keyExchangeGroup'] if json_obj.get('keyExchangeGroup') is not
            None else None, mac=json_obj['mac'] if json_obj.get('mac') is not
            None else None, server_signature_algorithm=json_obj[
            'serverSignatureAlgorithm'] if json_obj.get(
            'serverSignatureAlgorithm') is not None else None)


@dataclass
class SecurityIsolationStatus:
    coop: typing.Optional[CrossOriginOpenerPolicyStatus] = None
    coep: typing.Optional[CrossOriginEmbedderPolicyStatus] = None
    csp: typing.Optional[typing.List[ContentSecurityPolicyStatus]] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        if self.coop is not None:
            json_data['coop'] = self.coop.to_json()
        if self.coep is not None:
            json_data['coep'] = self.coep.to_json()
        if self.csp is not None:
            json_data['csp'] = [i.to_json() for i in self.csp]
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->SecurityIsolationStatus:
        return cls(coop=CrossOriginOpenerPolicyStatus.from_json(json_obj[
            'coop']) if json_obj.get('coop') is not None else None, coep=
            CrossOriginEmbedderPolicyStatus.from_json(json_obj['coep']) if 
            json_obj.get('coep') is not None else None, csp=[
            ContentSecurityPolicyStatus.from_json(i) for i in json_obj[
            'csp']] if json_obj.get('csp') is not None else None)


@dataclass
class ServiceWorkerRouterInfo:
    rule_id_matched: typing.Optional[int] = None
    matched_source_type: typing.Optional[ServiceWorkerRouterSource] = None
    actual_source_type: typing.Optional[ServiceWorkerRouterSource] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        if self.rule_id_matched is not None:
            json_data['ruleIdMatched'] = self.rule_id_matched
        if self.matched_source_type is not None:
            json_data['matchedSourceType'] = self.matched_source_type.to_json()
        if self.actual_source_type is not None:
            json_data['actualSourceType'] = self.actual_source_type.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->ServiceWorkerRouterInfo:
        return cls(rule_id_matched=json_obj['ruleIdMatched'] if json_obj.
            get('ruleIdMatched') is not None else None, matched_source_type
            =ServiceWorkerRouterSource.from_json(json_obj[
            'matchedSourceType']) if json_obj.get('matchedSourceType') is not
            None else None, actual_source_type=ServiceWorkerRouterSource.
            from_json(json_obj['actualSourceType']) if json_obj.get(
            'actualSourceType') is not None else None)


@dataclass
class SignedCertificateTimestamp:
    """Details of a signed certificate timestamp (SCT)."""
    status: str
    origin: str
    log_description: str
    log_id: str
    timestamp: float
    hash_algorithm: str
    signature_algorithm: str
    signature_data: str

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['status'] = self.status
        json_data['origin'] = self.origin
        json_data['logDescription'] = self.log_description
        json_data['logId'] = self.log_id
        json_data['timestamp'] = self.timestamp
        json_data['hashAlgorithm'] = self.hash_algorithm
        json_data['signatureAlgorithm'] = self.signature_algorithm
        json_data['signatureData'] = self.signature_data
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->SignedCertificateTimestamp:
        return cls(status=json_obj['status'], origin=json_obj['origin'],
            log_description=json_obj['logDescription'], log_id=json_obj[
            'logId'], timestamp=json_obj['timestamp'], hash_algorithm=
            json_obj['hashAlgorithm'], signature_algorithm=json_obj[
            'signatureAlgorithm'], signature_data=json_obj['signatureData'])


@dataclass
class SignedExchangeError:
    """Information about a signed exchange response."""
    message: str
    signature_index: typing.Optional[int] = None
    error_field: typing.Optional[SignedExchangeErrorField] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['message'] = self.message
        if self.signature_index is not None:
            json_data['signatureIndex'] = self.signature_index
        if self.error_field is not None:
            json_data['errorField'] = self.error_field.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->SignedExchangeError:
        return cls(message=json_obj['message'], signature_index=json_obj[
            'signatureIndex'] if json_obj.get('signatureIndex') is not None
             else None, error_field=SignedExchangeErrorField.from_json(
            json_obj['errorField']) if json_obj.get('errorField') is not
            None else None)


@dataclass
class SignedExchangeHeader:
    """Information about a signed exchange header.
https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#cbor-representation"""
    request_url: str
    response_code: int
    response_headers: Headers
    signatures: typing.List[SignedExchangeSignature]
    header_integrity: str

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['requestUrl'] = self.request_url
        json_data['responseCode'] = self.response_code
        json_data['responseHeaders'] = self.response_headers.to_json()
        json_data['signatures'] = [i.to_json() for i in self.signatures]
        json_data['headerIntegrity'] = self.header_integrity
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->SignedExchangeHeader:
        return cls(request_url=json_obj['requestUrl'], response_code=
            json_obj['responseCode'], response_headers=Headers.from_json(
            json_obj['responseHeaders']), signatures=[
            SignedExchangeSignature.from_json(i) for i in json_obj[
            'signatures']], header_integrity=json_obj['headerIntegrity'])


@dataclass
class SignedExchangeInfo:
    """Information about a signed exchange response."""
    outer_response: Response
    header: typing.Optional[SignedExchangeHeader] = None
    security_details: typing.Optional[SecurityDetails] = None
    errors: typing.Optional[typing.List[SignedExchangeError]] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['outerResponse'] = self.outer_response.to_json()
        if self.header is not None:
            json_data['header'] = self.header.to_json()
        if self.security_details is not None:
            json_data['securityDetails'] = self.security_details.to_json()
        if self.errors is not None:
            json_data['errors'] = [i.to_json() for i in self.errors]
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->SignedExchangeInfo:
        return cls(outer_response=Response.from_json(json_obj[
            'outerResponse']), header=SignedExchangeHeader.from_json(
            json_obj['header']) if json_obj.get('header') is not None else
            None, security_details=SecurityDetails.from_json(json_obj[
            'securityDetails']) if json_obj.get('securityDetails') is not
            None else None, errors=[SignedExchangeError.from_json(i) for i in
            json_obj['errors']] if json_obj.get('errors') is not None else None
            )


@dataclass
class SignedExchangeSignature:
    """Information about a signed exchange signature.
https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#rfc.section.3.1"""
    label: str
    signature: str
    integrity: str
    validity_url: str
    date: int
    expires: int
    cert_url: typing.Optional[str] = None
    cert_sha256: typing.Optional[str] = None
    certificates: typing.Optional[typing.List[str]] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['label'] = self.label
        json_data['signature'] = self.signature
        json_data['integrity'] = self.integrity
        json_data['validityUrl'] = self.validity_url
        json_data['date'] = self.date
        json_data['expires'] = self.expires
        if self.cert_url is not None:
            json_data['certUrl'] = self.cert_url
        if self.cert_sha256 is not None:
            json_data['certSha256'] = self.cert_sha256
        if self.certificates is not None:
            json_data['certificates'] = [i for i in self.certificates]
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->SignedExchangeSignature:
        return cls(label=json_obj['label'], signature=json_obj['signature'],
            integrity=json_obj['integrity'], validity_url=json_obj[
            'validityUrl'], date=json_obj['date'], expires=json_obj[
            'expires'], cert_url=json_obj['certUrl'] if json_obj.get(
            'certUrl') is not None else None, cert_sha256=json_obj[
            'certSha256'] if json_obj.get('certSha256') is not None else
            None, certificates=[i for i in json_obj['certificates']] if 
            json_obj.get('certificates') is not None else None)


@dataclass
class TrustTokenParams:
    """Determines what type of Trust Token operation is executed and
depending on the type, some additional parameters. The values
are specified in third_party/blink/renderer/core/fetch/trust_token.idl."""
    operation: TrustTokenOperationType
    refresh_policy: str
    issuers: typing.Optional[typing.List[str]] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['operation'] = self.operation.to_json()
        json_data['refreshPolicy'] = self.refresh_policy
        if self.issuers is not None:
            json_data['issuers'] = [i for i in self.issuers]
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->TrustTokenParams:
        return cls(operation=TrustTokenOperationType.from_json(json_obj[
            'operation']), refresh_policy=json_obj['refreshPolicy'],
            issuers=[i for i in json_obj['issuers']] if json_obj.get(
            'issuers') is not None else None)


@dataclass
class WebSocketFrame:
    """WebSocket message data. This represents an entire WebSocket message, not just a fragmented frame as the name suggests."""
    opcode: float
    mask: bool
    payload_data: str

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['opcode'] = self.opcode
        json_data['mask'] = self.mask
        json_data['payloadData'] = self.payload_data
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->WebSocketFrame:
        return cls(opcode=json_obj['opcode'], mask=json_obj['mask'],
            payload_data=json_obj['payloadData'])


@dataclass
class WebSocketRequest:
    """WebSocket request data."""
    headers: Headers

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['headers'] = self.headers.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->WebSocketRequest:
        return cls(headers=Headers.from_json(json_obj['headers']))


@dataclass
class WebSocketResponse:
    """WebSocket response data."""
    status: int
    status_text: str
    headers: Headers
    headers_text: typing.Optional[str] = None
    request_headers: typing.Optional[Headers] = None
    request_headers_text: typing.Optional[str] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['status'] = self.status
        json_data['statusText'] = self.status_text
        json_data['headers'] = self.headers.to_json()
        if self.headers_text is not None:
            json_data['headersText'] = self.headers_text
        if self.request_headers is not None:
            json_data['requestHeaders'] = self.request_headers.to_json()
        if self.request_headers_text is not None:
            json_data['requestHeadersText'] = self.request_headers_text
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->WebSocketResponse:
        return cls(status=json_obj['status'], status_text=json_obj[
            'statusText'], headers=Headers.from_json(json_obj['headers']),
            headers_text=json_obj['headersText'] if json_obj.get(
            'headersText') is not None else None, request_headers=Headers.
            from_json(json_obj['requestHeaders']) if json_obj.get(
            'requestHeaders') is not None else None, request_headers_text=
            json_obj['requestHeadersText'] if json_obj.get(
            'requestHeadersText') is not None else None)


class AlternateProtocolUsage(enum.Enum):
    """The reason why Chrome uses a specific transport protocol for HTTP semantics."""
    ALTERNATIVE_JOB_WON_WITHOUT_RACE = 'alternativeJobWonWithoutRace'
    ALTERNATIVE_JOB_WON_RACE = 'alternativeJobWonRace'
    MAIN_JOB_WON_RACE = 'mainJobWonRace'
    MAPPING_MISSING = 'mappingMissing'
    BROKEN = 'broken'
    DNS_ALPN_H3_JOB_WON_WITHOUT_RACE = 'dnsAlpnH3JobWonWithoutRace'
    DNS_ALPN_H3_JOB_WON_RACE = 'dnsAlpnH3JobWonRace'
    UNSPECIFIED_REASON = 'unspecifiedReason'

    @classmethod
    def from_json(cls, json: str) ->AlternateProtocolUsage:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<AlternateProtocolUsage.{}>'.format(self.value)


class BlockedReason(enum.Enum):
    """The reason why request was blocked."""
    OTHER = 'other'
    CSP = 'csp'
    MIXED_CONTENT = 'mixed-content'
    ORIGIN = 'origin'
    INSPECTOR = 'inspector'
    SUBRESOURCE_FILTER = 'subresource-filter'
    CONTENT_TYPE = 'content-type'
    COEP_FRAME_RESOURCE_NEEDS_COEP_HEADER = (
        'coep-frame-resource-needs-coep-header')
    COOP_SANDBOXED_IFRAME_CANNOT_NAVIGATE_TO_COOP_PAGE = (
        'coop-sandboxed-iframe-cannot-navigate-to-coop-page')
    CORP_NOT_SAME_ORIGIN = 'corp-not-same-origin'
    CORP_NOT_SAME_ORIGIN_AFTER_DEFAULTED_TO_SAME_ORIGIN_BY_COEP = (
        'corp-not-same-origin-after-defaulted-to-same-origin-by-coep')
    CORP_NOT_SAME_ORIGIN_AFTER_DEFAULTED_TO_SAME_ORIGIN_BY_DIP = (
        'corp-not-same-origin-after-defaulted-to-same-origin-by-dip')
    CORP_NOT_SAME_ORIGIN_AFTER_DEFAULTED_TO_SAME_ORIGIN_BY_COEP_AND_DIP = (
        'corp-not-same-origin-after-defaulted-to-same-origin-by-coep-and-dip')
    CORP_NOT_SAME_SITE = 'corp-not-same-site'
    SRI_MESSAGE_SIGNATURE_MISMATCH = 'sri-message-signature-mismatch'

    @classmethod
    def from_json(cls, json: str) ->BlockedReason:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<BlockedReason.{}>'.format(self.value)


class CertificateTransparencyCompliance(enum.Enum):
    """Whether the request complied with Certificate Transparency policy."""
    UNKNOWN = 'unknown'
    NOT_COMPLIANT = 'not-compliant'
    COMPLIANT = 'compliant'

    @classmethod
    def from_json(cls, json: str) ->CertificateTransparencyCompliance:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<CertificateTransparencyCompliance.{}>'.format(self.value)


class ConnectionType(enum.Enum):
    """The underlying connection technology that the browser is supposedly using."""
    NONE = 'none'
    CELLULAR2G = 'cellular2g'
    CELLULAR3G = 'cellular3g'
    CELLULAR4G = 'cellular4g'
    BLUETOOTH = 'bluetooth'
    ETHERNET = 'ethernet'
    WIFI = 'wifi'
    WIMAX = 'wimax'
    OTHER = 'other'

    @classmethod
    def from_json(cls, json: str) ->ConnectionType:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<ConnectionType.{}>'.format(self.value)


class ContentEncoding(enum.Enum):
    """List of content encodings supported by the backend."""
    DEFLATE = 'deflate'
    GZIP = 'gzip'
    BR = 'br'
    ZSTD = 'zstd'

    @classmethod
    def from_json(cls, json: str) ->ContentEncoding:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<ContentEncoding.{}>'.format(self.value)


class ContentSecurityPolicySource(enum.Enum):
    HTTP = 'HTTP'
    META = 'Meta'

    @classmethod
    def from_json(cls, json: str) ->ContentSecurityPolicySource:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<ContentSecurityPolicySource.{}>'.format(self.value)


class CookieBlockedReason(enum.Enum):
    """Types of reasons why a cookie may not be sent with a request."""
    SECURE_ONLY = 'SecureOnly'
    NOT_ON_PATH = 'NotOnPath'
    DOMAIN_MISMATCH = 'DomainMismatch'
    SAME_SITE_STRICT = 'SameSiteStrict'
    SAME_SITE_LAX = 'SameSiteLax'
    SAME_SITE_UNSPECIFIED_TREATED_AS_LAX = 'SameSiteUnspecifiedTreatedAsLax'
    SAME_SITE_NONE_INSECURE = 'SameSiteNoneInsecure'
    USER_PREFERENCES = 'UserPreferences'
    THIRD_PARTY_PHASEOUT = 'ThirdPartyPhaseout'
    THIRD_PARTY_BLOCKED_IN_FIRST_PARTY_SET = 'ThirdPartyBlockedInFirstPartySet'
    UNKNOWN_ERROR = 'UnknownError'
    SCHEMEFUL_SAME_SITE_STRICT = 'SchemefulSameSiteStrict'
    SCHEMEFUL_SAME_SITE_LAX = 'SchemefulSameSiteLax'
    SCHEMEFUL_SAME_SITE_UNSPECIFIED_TREATED_AS_LAX = (
        'SchemefulSameSiteUnspecifiedTreatedAsLax')
    SAME_PARTY_FROM_CROSS_PARTY_CONTEXT = 'SamePartyFromCrossPartyContext'
    NAME_VALUE_PAIR_EXCEEDS_MAX_SIZE = 'NameValuePairExceedsMaxSize'
    PORT_MISMATCH = 'PortMismatch'
    SCHEME_MISMATCH = 'SchemeMismatch'
    ANONYMOUS_CONTEXT = 'AnonymousContext'

    @classmethod
    def from_json(cls, json: str) ->CookieBlockedReason:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<CookieBlockedReason.{}>'.format(self.value)


class CookieExemptionReason(enum.Enum):
    """Types of reasons why a cookie should have been blocked by 3PCD but is exempted for the request."""
    NONE = 'None'
    USER_SETTING = 'UserSetting'
    TPCD_METADATA = 'TPCDMetadata'
    TPCD_DEPRECATION_TRIAL = 'TPCDDeprecationTrial'
    TOP_LEVEL_TPCD_DEPRECATION_TRIAL = 'TopLevelTPCDDeprecationTrial'
    TPCD_HEURISTICS = 'TPCDHeuristics'
    ENTERPRISE_POLICY = 'EnterprisePolicy'
    STORAGE_ACCESS = 'StorageAccess'
    TOP_LEVEL_STORAGE_ACCESS = 'TopLevelStorageAccess'
    SCHEME = 'Scheme'
    SAME_SITE_NONE_COOKIES_IN_SANDBOX = 'SameSiteNoneCookiesInSandbox'

    @classmethod
    def from_json(cls, json: str) ->CookieExemptionReason:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<CookieExemptionReason.{}>'.format(self.value)


class CookiePriority(enum.Enum):
    """Represents the cookie's 'Priority' status:
https://tools.ietf.org/html/draft-west-cookie-priority-00"""
    LOW = 'Low'
    MEDIUM = 'Medium'
    HIGH = 'High'

    @classmethod
    def from_json(cls, json: str) ->CookiePriority:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<CookiePriority.{}>'.format(self.value)


class CookieSameSite(enum.Enum):
    """Represents the cookie's 'SameSite' status:
https://tools.ietf.org/html/draft-west-first-party-cookies"""
    STRICT = 'Strict'
    LAX = 'Lax'
    NONE = 'None'

    @classmethod
    def from_json(cls, json: str) ->CookieSameSite:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<CookieSameSite.{}>'.format(self.value)


class CookieSourceScheme(enum.Enum):
    """Represents the source scheme of the origin that originally set the cookie.
A value of "Unset" allows protocol clients to emulate legacy cookie scope for the scheme.
This is a temporary ability and it will be removed in the future."""
    UNSET = 'Unset'
    NON_SECURE = 'NonSecure'
    SECURE = 'Secure'

    @classmethod
    def from_json(cls, json: str) ->CookieSourceScheme:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<CookieSourceScheme.{}>'.format(self.value)


class CorsError(enum.Enum):
    """The reason why request was blocked."""
    DISALLOWED_BY_MODE = 'DisallowedByMode'
    INVALID_RESPONSE = 'InvalidResponse'
    WILDCARD_ORIGIN_NOT_ALLOWED = 'WildcardOriginNotAllowed'
    MISSING_ALLOW_ORIGIN_HEADER = 'MissingAllowOriginHeader'
    MULTIPLE_ALLOW_ORIGIN_VALUES = 'MultipleAllowOriginValues'
    INVALID_ALLOW_ORIGIN_VALUE = 'InvalidAllowOriginValue'
    ALLOW_ORIGIN_MISMATCH = 'AllowOriginMismatch'
    INVALID_ALLOW_CREDENTIALS = 'InvalidAllowCredentials'
    CORS_DISABLED_SCHEME = 'CorsDisabledScheme'
    PREFLIGHT_INVALID_STATUS = 'PreflightInvalidStatus'
    PREFLIGHT_DISALLOWED_REDIRECT = 'PreflightDisallowedRedirect'
    PREFLIGHT_WILDCARD_ORIGIN_NOT_ALLOWED = 'PreflightWildcardOriginNotAllowed'
    PREFLIGHT_MISSING_ALLOW_ORIGIN_HEADER = 'PreflightMissingAllowOriginHeader'
    PREFLIGHT_MULTIPLE_ALLOW_ORIGIN_VALUES = (
        'PreflightMultipleAllowOriginValues')
    PREFLIGHT_INVALID_ALLOW_ORIGIN_VALUE = 'PreflightInvalidAllowOriginValue'
    PREFLIGHT_ALLOW_ORIGIN_MISMATCH = 'PreflightAllowOriginMismatch'
    PREFLIGHT_INVALID_ALLOW_CREDENTIALS = 'PreflightInvalidAllowCredentials'
    PREFLIGHT_MISSING_ALLOW_EXTERNAL = 'PreflightMissingAllowExternal'
    PREFLIGHT_INVALID_ALLOW_EXTERNAL = 'PreflightInvalidAllowExternal'
    PREFLIGHT_MISSING_ALLOW_PRIVATE_NETWORK = (
        'PreflightMissingAllowPrivateNetwork')
    PREFLIGHT_INVALID_ALLOW_PRIVATE_NETWORK = (
        'PreflightInvalidAllowPrivateNetwork')
    INVALID_ALLOW_METHODS_PREFLIGHT_RESPONSE = (
        'InvalidAllowMethodsPreflightResponse')
    INVALID_ALLOW_HEADERS_PREFLIGHT_RESPONSE = (
        'InvalidAllowHeadersPreflightResponse')
    METHOD_DISALLOWED_BY_PREFLIGHT_RESPONSE = (
        'MethodDisallowedByPreflightResponse')
    HEADER_DISALLOWED_BY_PREFLIGHT_RESPONSE = (
        'HeaderDisallowedByPreflightResponse')
    REDIRECT_CONTAINS_CREDENTIALS = 'RedirectContainsCredentials'
    INSECURE_PRIVATE_NETWORK = 'InsecurePrivateNetwork'
    INVALID_PRIVATE_NETWORK_ACCESS = 'InvalidPrivateNetworkAccess'
    UNEXPECTED_PRIVATE_NETWORK_ACCESS = 'UnexpectedPrivateNetworkAccess'
    NO_CORS_REDIRECT_MODE_NOT_FOLLOW = 'NoCorsRedirectModeNotFollow'
    PREFLIGHT_MISSING_PRIVATE_NETWORK_ACCESS_ID = (
        'PreflightMissingPrivateNetworkAccessId')
    PREFLIGHT_MISSING_PRIVATE_NETWORK_ACCESS_NAME = (
        'PreflightMissingPrivateNetworkAccessName')
    PRIVATE_NETWORK_ACCESS_PERMISSION_UNAVAILABLE = (
        'PrivateNetworkAccessPermissionUnavailable')
    PRIVATE_NETWORK_ACCESS_PERMISSION_DENIED = (
        'PrivateNetworkAccessPermissionDenied')
    LOCAL_NETWORK_ACCESS_PERMISSION_DENIED = (
        'LocalNetworkAccessPermissionDenied')

    @classmethod
    def from_json(cls, json: str) ->CorsError:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<CorsError.{}>'.format(self.value)


class CrossOriginEmbedderPolicyValue(enum.Enum):
    NONE = 'None'
    CREDENTIALLESS = 'Credentialless'
    REQUIRE_CORP = 'RequireCorp'

    @classmethod
    def from_json(cls, json: str) ->CrossOriginEmbedderPolicyValue:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<CrossOriginEmbedderPolicyValue.{}>'.format(self.value)


class CrossOriginOpenerPolicyValue(enum.Enum):
    SAME_ORIGIN = 'SameOrigin'
    SAME_ORIGIN_ALLOW_POPUPS = 'SameOriginAllowPopups'
    RESTRICT_PROPERTIES = 'RestrictProperties'
    UNSAFE_NONE = 'UnsafeNone'
    SAME_ORIGIN_PLUS_COEP = 'SameOriginPlusCoep'
    RESTRICT_PROPERTIES_PLUS_COEP = 'RestrictPropertiesPlusCoep'
    NOOPENER_ALLOW_POPUPS = 'NoopenerAllowPopups'

    @classmethod
    def from_json(cls, json: str) ->CrossOriginOpenerPolicyValue:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<CrossOriginOpenerPolicyValue.{}>'.format(self.value)


class DirectSocketDnsQueryType(enum.Enum):
    IPV4 = 'ipv4'
    IPV6 = 'ipv6'

    @classmethod
    def from_json(cls, json: str) ->DirectSocketDnsQueryType:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<DirectSocketDnsQueryType.{}>'.format(self.value)


class ErrorReason(enum.Enum):
    """Network level fetch failure reason."""
    FAILED = 'Failed'
    ABORTED = 'Aborted'
    TIMED_OUT = 'TimedOut'
    ACCESS_DENIED = 'AccessDenied'
    CONNECTION_CLOSED = 'ConnectionClosed'
    CONNECTION_RESET = 'ConnectionReset'
    CONNECTION_REFUSED = 'ConnectionRefused'
    CONNECTION_ABORTED = 'ConnectionAborted'
    CONNECTION_FAILED = 'ConnectionFailed'
    NAME_NOT_RESOLVED = 'NameNotResolved'
    INTERNET_DISCONNECTED = 'InternetDisconnected'
    ADDRESS_UNREACHABLE = 'AddressUnreachable'
    BLOCKED_BY_CLIENT = 'BlockedByClient'
    BLOCKED_BY_RESPONSE = 'BlockedByResponse'

    @classmethod
    def from_json(cls, json: str) ->ErrorReason:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<ErrorReason.{}>'.format(self.value)


class IPAddressSpace(enum.Enum):
    LOCAL = 'Local'
    PRIVATE = 'Private'
    PUBLIC = 'Public'
    UNKNOWN = 'Unknown'

    @classmethod
    def from_json(cls, json: str) ->IPAddressSpace:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<IPAddressSpace.{}>'.format(self.value)


class InterceptionStage(enum.Enum):
    """Stages of the interception to begin intercepting. Request will intercept before the request is
sent. Response will intercept after the response is received."""
    REQUEST = 'Request'
    HEADERS_RECEIVED = 'HeadersReceived'

    @classmethod
    def from_json(cls, json: str) ->InterceptionStage:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<InterceptionStage.{}>'.format(self.value)


class PrivateNetworkRequestPolicy(enum.Enum):
    ALLOW = 'Allow'
    BLOCK_FROM_INSECURE_TO_MORE_PRIVATE = 'BlockFromInsecureToMorePrivate'
    WARN_FROM_INSECURE_TO_MORE_PRIVATE = 'WarnFromInsecureToMorePrivate'
    PREFLIGHT_BLOCK = 'PreflightBlock'
    PREFLIGHT_WARN = 'PreflightWarn'
    PERMISSION_BLOCK = 'PermissionBlock'
    PERMISSION_WARN = 'PermissionWarn'

    @classmethod
    def from_json(cls, json: str) ->PrivateNetworkRequestPolicy:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<PrivateNetworkRequestPolicy.{}>'.format(self.value)


class ReportStatus(enum.Enum):
    """The status of a Reporting API report."""
    QUEUED = 'Queued'
    PENDING = 'Pending'
    MARKED_FOR_REMOVAL = 'MarkedForRemoval'
    SUCCESS = 'Success'

    @classmethod
    def from_json(cls, json: str) ->ReportStatus:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<ReportStatus.{}>'.format(self.value)


class ResourcePriority(enum.Enum):
    """Loading priority of a resource request."""
    VERY_LOW = 'VeryLow'
    LOW = 'Low'
    MEDIUM = 'Medium'
    HIGH = 'High'
    VERY_HIGH = 'VeryHigh'

    @classmethod
    def from_json(cls, json: str) ->ResourcePriority:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<ResourcePriority.{}>'.format(self.value)


class ResourceType(enum.Enum):
    """Resource type as it was perceived by the rendering engine."""
    DOCUMENT = 'Document'
    STYLESHEET = 'Stylesheet'
    IMAGE = 'Image'
    MEDIA = 'Media'
    FONT = 'Font'
    SCRIPT = 'Script'
    TEXT_TRACK = 'TextTrack'
    XHR = 'XHR'
    FETCH = 'Fetch'
    PREFETCH = 'Prefetch'
    EVENT_SOURCE = 'EventSource'
    WEB_SOCKET = 'WebSocket'
    MANIFEST = 'Manifest'
    SIGNED_EXCHANGE = 'SignedExchange'
    PING = 'Ping'
    CSP_VIOLATION_REPORT = 'CSPViolationReport'
    PREFLIGHT = 'Preflight'
    OTHER = 'Other'

    @classmethod
    def from_json(cls, json: str) ->ResourceType:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<ResourceType.{}>'.format(self.value)


class ServiceWorkerResponseSource(enum.Enum):
    """Source of serviceworker response."""
    CACHE_STORAGE = 'cache-storage'
    HTTP_CACHE = 'http-cache'
    FALLBACK_CODE = 'fallback-code'
    NETWORK = 'network'

    @classmethod
    def from_json(cls, json: str) ->ServiceWorkerResponseSource:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<ServiceWorkerResponseSource.{}>'.format(self.value)


class ServiceWorkerRouterSource(enum.Enum):
    """Source of service worker router."""
    NETWORK = 'network'
    CACHE = 'cache'
    FETCH_EVENT = 'fetch-event'
    RACE_NETWORK_AND_FETCH_HANDLER = 'race-network-and-fetch-handler'
    RACE_NETWORK_AND_CACHE = 'race-network-and-cache'

    @classmethod
    def from_json(cls, json: str) ->ServiceWorkerRouterSource:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<ServiceWorkerRouterSource.{}>'.format(self.value)


class SetCookieBlockedReason(enum.Enum):
    """Types of reasons why a cookie may not be stored from a response."""
    SECURE_ONLY = 'SecureOnly'
    SAME_SITE_STRICT = 'SameSiteStrict'
    SAME_SITE_LAX = 'SameSiteLax'
    SAME_SITE_UNSPECIFIED_TREATED_AS_LAX = 'SameSiteUnspecifiedTreatedAsLax'
    SAME_SITE_NONE_INSECURE = 'SameSiteNoneInsecure'
    USER_PREFERENCES = 'UserPreferences'
    THIRD_PARTY_PHASEOUT = 'ThirdPartyPhaseout'
    THIRD_PARTY_BLOCKED_IN_FIRST_PARTY_SET = 'ThirdPartyBlockedInFirstPartySet'
    SYNTAX_ERROR = 'SyntaxError'
    SCHEME_NOT_SUPPORTED = 'SchemeNotSupported'
    OVERWRITE_SECURE = 'OverwriteSecure'
    INVALID_DOMAIN = 'InvalidDomain'
    INVALID_PREFIX = 'InvalidPrefix'
    UNKNOWN_ERROR = 'UnknownError'
    SCHEMEFUL_SAME_SITE_STRICT = 'SchemefulSameSiteStrict'
    SCHEMEFUL_SAME_SITE_LAX = 'SchemefulSameSiteLax'
    SCHEMEFUL_SAME_SITE_UNSPECIFIED_TREATED_AS_LAX = (
        'SchemefulSameSiteUnspecifiedTreatedAsLax')
    SAME_PARTY_FROM_CROSS_PARTY_CONTEXT = 'SamePartyFromCrossPartyContext'
    SAME_PARTY_CONFLICTS_WITH_OTHER_ATTRIBUTES = (
        'SamePartyConflictsWithOtherAttributes')
    NAME_VALUE_PAIR_EXCEEDS_MAX_SIZE = 'NameValuePairExceedsMaxSize'
    DISALLOWED_CHARACTER = 'DisallowedCharacter'
    NO_COOKIE_CONTENT = 'NoCookieContent'

    @classmethod
    def from_json(cls, json: str) ->SetCookieBlockedReason:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<SetCookieBlockedReason.{}>'.format(self.value)


class SignedExchangeErrorField(enum.Enum):
    """Field type for a signed exchange related error."""
    SIGNATURE_SIG = 'signatureSig'
    SIGNATURE_INTEGRITY = 'signatureIntegrity'
    SIGNATURE_CERT_URL = 'signatureCertUrl'
    SIGNATURE_CERT_SHA256 = 'signatureCertSha256'
    SIGNATURE_VALIDITY_URL = 'signatureValidityUrl'
    SIGNATURE_TIMESTAMPS = 'signatureTimestamps'

    @classmethod
    def from_json(cls, json: str) ->SignedExchangeErrorField:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<SignedExchangeErrorField.{}>'.format(self.value)


class TrustTokenOperationType(enum.Enum):
    ISSUANCE = 'Issuance'
    REDEMPTION = 'Redemption'
    SIGNING = 'Signing'

    @classmethod
    def from_json(cls, json: str) ->TrustTokenOperationType:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<TrustTokenOperationType.{}>'.format(self.value)


class InterceptionId(str):
    """Unique intercepted request identifier.

Represents the CDP type 'Network.InterceptionId'."""

    def to_json(self) ->str:
        return self

    @classmethod
    def from_json(cls, json: str) ->InterceptionId:
        return cls(json)

    def __repr__(self) ->str:
        return 'InterceptionId({})'.format(super().__repr__())


class LoaderId(str):
    """Unique loader identifier.

Represents the CDP type 'Network.LoaderId'."""

    def to_json(self) ->str:
        return self

    @classmethod
    def from_json(cls, json: str) ->LoaderId:
        return cls(json)

    def __repr__(self) ->str:
        return 'LoaderId({})'.format(super().__repr__())


class MonotonicTime(float):
    """Monotonically increasing time in seconds since an arbitrary point in the past.

Represents the CDP type 'Network.MonotonicTime'."""

    def to_json(self) ->float:
        return self

    @classmethod
    def from_json(cls, json: float) ->MonotonicTime:
        return cls(json)

    def __repr__(self) ->str:
        return 'MonotonicTime({})'.format(super().__repr__())


class ReportId(str):
    """Represents the CDP type 'Network.ReportId'.

**EXPERIMENTAL**"""

    def to_json(self) ->str:
        return self

    @classmethod
    def from_json(cls, json: str) ->ReportId:
        return cls(json)

    def __repr__(self) ->str:
        return 'ReportId({})'.format(super().__repr__())


class RequestId(str):
    """Unique network request identifier.
Note that this does not identify individual HTTP requests that are part of
a network request.

Represents the CDP type 'Network.RequestId'."""

    def to_json(self) ->str:
        return self

    @classmethod
    def from_json(cls, json: str) ->RequestId:
        return cls(json)

    def __repr__(self) ->str:
        return 'RequestId({})'.format(super().__repr__())


class TimeSinceEpoch(float):
    """UTC time in seconds, counted from January 1, 1970.

Represents the CDP type 'Network.TimeSinceEpoch'."""

    def to_json(self) ->float:
        return self

    @classmethod
    def from_json(cls, json: float) ->TimeSinceEpoch:
        return cls(json)

    def __repr__(self) ->str:
        return 'TimeSinceEpoch({})'.format(super().__repr__())


@deprecated(version='1.3')
def can_clear_browser_cache() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, bool
    ]:
    """Tells whether clearing browser cache is supported.

.. deprecated:: 1.3


:returns: True if browser cache can be cleared."""
    cmd_dict = {'method': 'Network.canClearBrowserCache'}
    json_result = yield cmd_dict
    return json_result['result']


@deprecated(version='1.3')
def can_clear_browser_cookies() ->typing.Generator[T_JSON_DICT, T_JSON_DICT,
    bool]:
    """Tells whether clearing browser cookies is supported.

.. deprecated:: 1.3


:returns: True if browser cookies can be cleared."""
    cmd_dict = {'method': 'Network.canClearBrowserCookies'}
    json_result = yield cmd_dict
    return json_result['result']


@deprecated(version='1.3')
def can_emulate_network_conditions() ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, bool]:
    """Tells whether emulation of network conditions is supported.

.. deprecated:: 1.3


:returns: True if emulation of network conditions is supported."""
    cmd_dict = {'method': 'Network.canEmulateNetworkConditions'}
    json_result = yield cmd_dict
    return json_result['result']


def clear_accepted_encodings_override() ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, None]:
    """Clears accepted encodings set by setAcceptedEncodings

**EXPERIMENTAL**"""
    cmd_dict = {'method': 'Network.clearAcceptedEncodingsOverride'}
    json_result = yield cmd_dict
    return None


def clear_browser_cache() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Clears browser cache."""
    cmd_dict = {'method': 'Network.clearBrowserCache'}
    json_result = yield cmd_dict
    return None


def clear_browser_cookies() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Clears browser cookies."""
    cmd_dict = {'method': 'Network.clearBrowserCookies'}
    json_result = yield cmd_dict
    return None


@deprecated(version='1.3')
def continue_intercepted_request(interception_id: InterceptionId,
    error_reason: typing.Optional[ErrorReason]=None, raw_response: typing.
    Optional[str]=None, url: typing.Optional[str]=None, method: typing.
    Optional[str]=None, post_data: typing.Optional[str]=None, headers:
    typing.Optional[Headers]=None, auth_challenge_response: typing.Optional
    [AuthChallengeResponse]=None) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, None]:
    """Response to Network.requestIntercepted which either modifies the request to continue with any
modifications, or blocks it, or completes it with the provided response bytes. If a network
fetch occurs as a result which encounters a redirect an additional Network.requestIntercepted
event will be sent with the same InterceptionId.
Deprecated, use Fetch.continueRequest, Fetch.fulfillRequest and Fetch.failRequest instead.

.. deprecated:: 1.3

**EXPERIMENTAL**

:param ...:

:param interception_id:

:param error_reason: *(Optional)* If set this causes the request to fail with the given reason. Passing ``Aborted`` for requests marked with ``isNavigationRequest`` also cancels the navigation. Must not be set in response to an authChallenge.

:param raw_response: *(Optional)* If set the requests completes using with the provided base64 encoded raw response, including HTTP status line and headers etc... Must not be set in response to an authChallenge. (Encoded as a base64 string when passed over JSON)

:param url: *(Optional)* If set the request url will be modified in a way that's not observable by page. Must not be set in response to an authChallenge.

:param method: *(Optional)* If set this allows the request method to be overridden. Must not be set in response to an authChallenge.

:param post_data: *(Optional)* If set this allows postData to be set. Must not be set in response to an authChallenge.

:param headers: *(Optional)* If set this allows the request headers to be changed. Must not be set in response to an authChallenge.

:param auth_challenge_response: *(Optional)* Response to a requestIntercepted with an authChallenge. Must not be set otherwise."""
    params_dict: T_JSON_DICT = dict()
    params_dict['interceptionId'] = interception_id.to_json()
    if error_reason is not None:
        params_dict['errorReason'] = error_reason.to_json()
    if raw_response is not None:
        params_dict['rawResponse'] = raw_response
    if url is not None:
        params_dict['url'] = url
    if method is not None:
        params_dict['method'] = method
    if post_data is not None:
        params_dict['postData'] = post_data
    if headers is not None:
        params_dict['headers'] = headers.to_json()
    if auth_challenge_response is not None:
        params_dict['authChallengeResponse'] = auth_challenge_response.to_json(
            )
    cmd_dict = {'method': 'Network.continueInterceptedRequest', 'params':
        params_dict}
    json_result = yield cmd_dict
    return None


def delete_cookies(name: str, url: typing.Optional[str]=None, domain:
    typing.Optional[str]=None, path: typing.Optional[str]=None,
    partition_key: typing.Optional[CookiePartitionKey]=None
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Deletes browser cookies with matching name and url or domain/path/partitionKey pair.

:param ...:

:param name: Name of the cookies to remove.

:param url: *(Optional)* If specified, deletes all the cookies with the given name where domain and path match provided URL.

:param domain: *(Optional)* If specified, deletes only cookies with the exact domain.

:param path: *(Optional)* If specified, deletes only cookies with the exact path.

:param partition_key: **(EXPERIMENTAL)** *(Optional)* If specified, deletes only cookies with the the given name and partitionKey where all partition key attributes match the cookie partition key attribute."""
    params_dict: T_JSON_DICT = dict()
    params_dict['name'] = name
    if url is not None:
        params_dict['url'] = url
    if domain is not None:
        params_dict['domain'] = domain
    if path is not None:
        params_dict['path'] = path
    if partition_key is not None:
        params_dict['partitionKey'] = partition_key.to_json()
    cmd_dict = {'method': 'Network.deleteCookies', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def disable() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Disables network tracking, prevents network events from being sent to the client."""
    cmd_dict = {'method': 'Network.disable'}
    json_result = yield cmd_dict
    return None


def emulate_network_conditions(offline: bool, latency: float,
    download_throughput: float, upload_throughput: float, connection_type:
    typing.Optional[ConnectionType]=None, packet_loss: typing.Optional[
    float]=None, packet_queue_length: typing.Optional[int]=None,
    packet_reordering: typing.Optional[bool]=None) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, None]:
    """Activates emulation of network conditions.

:param ...:

:param offline: True to emulate internet disconnection.

:param latency: Minimum latency from request sent to response headers received (ms).

:param download_throughput: Maximal aggregated download throughput (bytes/sec). -1 disables download throttling.

:param upload_throughput: Maximal aggregated upload throughput (bytes/sec).  -1 disables upload throttling.

:param connection_type: *(Optional)* Connection type if known.

:param packet_loss: **(EXPERIMENTAL)** *(Optional)* WebRTC packet loss (percent, 0-100). 0 disables packet loss emulation, 100 drops all the packets.

:param packet_queue_length: **(EXPERIMENTAL)** *(Optional)* WebRTC packet queue length (packet). 0 removes any queue length limitations.

:param packet_reordering: **(EXPERIMENTAL)** *(Optional)* WebRTC packetReordering feature."""
    params_dict: T_JSON_DICT = dict()
    params_dict['offline'] = offline
    params_dict['latency'] = latency
    params_dict['downloadThroughput'] = download_throughput
    params_dict['uploadThroughput'] = upload_throughput
    if connection_type is not None:
        params_dict['connectionType'] = connection_type.to_json()
    if packet_loss is not None:
        params_dict['packetLoss'] = packet_loss
    if packet_queue_length is not None:
        params_dict['packetQueueLength'] = packet_queue_length
    if packet_reordering is not None:
        params_dict['packetReordering'] = packet_reordering
    cmd_dict = {'method': 'Network.emulateNetworkConditions', 'params':
        params_dict}
    json_result = yield cmd_dict
    return None


def enable(max_total_buffer_size: typing.Optional[int]=None,
    max_resource_buffer_size: typing.Optional[int]=None, max_post_data_size:
    typing.Optional[int]=None) ->typing.Generator[T_JSON_DICT, T_JSON_DICT,
    None]:
    """Enables network tracking, network events will now be delivered to the client.

:param ...:

:param max_total_buffer_size: **(EXPERIMENTAL)** *(Optional)* Buffer size in bytes to use when preserving network payloads (XHRs, etc).

:param max_resource_buffer_size: **(EXPERIMENTAL)** *(Optional)* Per-resource buffer size in bytes to use when preserving network payloads (XHRs, etc).

:param max_post_data_size: *(Optional)* Longest post body size (in bytes) that would be included in requestWillBeSent notification"""
    params_dict: T_JSON_DICT = dict()
    if max_total_buffer_size is not None:
        params_dict['maxTotalBufferSize'] = max_total_buffer_size
    if max_resource_buffer_size is not None:
        params_dict['maxResourceBufferSize'] = max_resource_buffer_size
    if max_post_data_size is not None:
        params_dict['maxPostDataSize'] = max_post_data_size
    cmd_dict = {'method': 'Network.enable', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def enable_reporting_api(enable: bool) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, None]:
    """Enables tracking for the Reporting API, events generated by the Reporting API will now be delivered to the client.
Enabling triggers 'reportingApiReportAdded' for all existing reports.

**EXPERIMENTAL**

:param ...:

:param enable: Whether to enable or disable events for the Reporting API"""
    params_dict: T_JSON_DICT = dict()
    params_dict['enable'] = enable
    cmd_dict = {'method': 'Network.enableReportingApi', 'params': params_dict}
    json_result = yield cmd_dict
    return None


@deprecated(version='1.3')
def get_all_cookies() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, typing.
    List[Cookie]]:
    """Returns all browser cookies. Depending on the backend support, will return detailed cookie
information in the ``cookies`` field.
Deprecated. Use Storage.getCookies instead.

.. deprecated:: 1.3


:returns: Array of cookie objects."""
    cmd_dict = {'method': 'Network.getAllCookies'}
    json_result = yield cmd_dict
    return [Cookie.from_json(i) for i in json_result['cookies']]


def get_certificate(origin: str) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, typing.List[str]]:
    """Returns the DER-encoded certificate.

**EXPERIMENTAL**

:param ...:

:param origin: Origin to get certificate for.


:returns:"""
    params_dict: T_JSON_DICT = dict()
    params_dict['origin'] = origin
    cmd_dict = {'method': 'Network.getCertificate', 'params': params_dict}
    json_result = yield cmd_dict
    return [i for i in json_result['tableNames']]


def get_cookies(urls: typing.Optional[typing.List[str]]=None
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, typing.List[Cookie]]:
    """Returns all browser cookies for the current URL. Depending on the backend support, will return
detailed cookie information in the ``cookies`` field.

:param ...:

:param urls: *(Optional)* The list of URLs for which applicable cookies will be fetched. If not specified, it's assumed to be set to the list containing the URLs of the page and all of its subframes.


:returns: Array of cookie objects."""
    params_dict: T_JSON_DICT = dict()
    if urls is not None:
        params_dict['urls'] = [i for i in urls]
    cmd_dict = {'method': 'Network.getCookies', 'params': params_dict}
    json_result = yield cmd_dict
    return [Cookie.from_json(i) for i in json_result['cookies']]


def get_request_post_data(request_id: RequestId) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, str]:
    """Returns post data sent with the request. Returns an error when no data was sent with the request.

:param ...:

:param request_id: Identifier of the network request to get content for.


:returns: Request body string, omitting files from multipart requests"""
    params_dict: T_JSON_DICT = dict()
    params_dict['requestId'] = request_id.to_json()
    cmd_dict = {'method': 'Network.getRequestPostData', 'params': params_dict}
    json_result = yield cmd_dict
    return json_result['postData']


def get_response_body(request_id: RequestId) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, typing.Tuple[str, bool]]:
    """Returns content served for the given request.

:param ...:

:param request_id: Identifier of the network request to get content for.


:returns: A tuple with the following items:

    1. **body** - Response body.
    2. **base64Encoded** - True, if content was sent as base64."""
    params_dict: T_JSON_DICT = dict()
    params_dict['requestId'] = request_id.to_json()
    cmd_dict = {'method': 'Network.getResponseBody', 'params': params_dict}
    json_result = yield cmd_dict
    return json_result['body'], json_result['base64Encoded']


def get_response_body_for_interception(interception_id: InterceptionId
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, typing.Tuple[str, bool]]:
    """Returns content served for the given currently intercepted request.

**EXPERIMENTAL**

:param ...:

:param interception_id: Identifier for the intercepted request to get body for.


:returns: A tuple with the following items:

    1. **body** - Response body.
    2. **base64Encoded** - True, if content was sent as base64."""
    params_dict: T_JSON_DICT = dict()
    params_dict['interceptionId'] = interception_id.to_json()
    cmd_dict = {'method': 'Network.getResponseBodyForInterception',
        'params': params_dict}
    json_result = yield cmd_dict
    return json_result['body'], json_result['base64Encoded']


def get_security_isolation_status(frame_id: typing.Optional[page.FrameId]=None
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, SecurityIsolationStatus]:
    """Returns information about the COEP/COOP isolation status.

**EXPERIMENTAL**

:param ...:

:param frame_id: *(Optional)* If no frameId is provided, the status of the target is provided.


:returns:"""
    params_dict: T_JSON_DICT = dict()
    if frame_id is not None:
        params_dict['frameId'] = frame_id.to_json()
    cmd_dict = {'method': 'Network.getSecurityIsolationStatus', 'params':
        params_dict}
    json_result = yield cmd_dict
    return SecurityIsolationStatus.from_json(json_result['status'])


def load_network_resource(url: str, options: LoadNetworkResourceOptions,
    frame_id: typing.Optional[page.FrameId]=None) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, LoadNetworkResourcePageResult]:
    """Fetches the resource and returns the content.

**EXPERIMENTAL**

:param ...:

:param url: URL of the resource to get content for.

:param options: Options for the request.

:param frame_id: *(Optional)* Frame id to get the resource for. Mandatory for frame targets, and should be omitted for worker targets.


:returns:"""
    params_dict: T_JSON_DICT = dict()
    if frame_id is not None:
        params_dict['frameId'] = frame_id.to_json()
    params_dict['url'] = url
    params_dict['options'] = options.to_json()
    cmd_dict = {'method': 'Network.loadNetworkResource', 'params': params_dict}
    json_result = yield cmd_dict
    return LoadNetworkResourcePageResult.from_json(json_result['resource'])


def replay_xhr(request_id: RequestId) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, None]:
    """This method sends a new XMLHttpRequest which is identical to the original one. The following
parameters should be identical: method, url, async, request body, extra headers, withCredentials
attribute, user, password.

**EXPERIMENTAL**

:param ...:

:param request_id: Identifier of XHR to replay."""
    params_dict: T_JSON_DICT = dict()
    params_dict['requestId'] = request_id.to_json()
    cmd_dict = {'method': 'Network.replayXHR', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def search_in_response_body(request_id: RequestId, query: str,
    case_sensitive: typing.Optional[bool]=None, is_regex: typing.Optional[
    bool]=None) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, typing.List[
    debugger.SearchMatch]]:
    """Searches for given string in response content.

**EXPERIMENTAL**

:param ...:

:param request_id: Identifier of the network response to search.

:param query: String to search for.

:param case_sensitive: *(Optional)* If true, search is case sensitive.

:param is_regex: *(Optional)* If true, treats string parameter as regex.


:returns: List of search matches."""
    params_dict: T_JSON_DICT = dict()
    params_dict['requestId'] = request_id.to_json()
    params_dict['query'] = query
    if case_sensitive is not None:
        params_dict['caseSensitive'] = case_sensitive
    if is_regex is not None:
        params_dict['isRegex'] = is_regex
    cmd_dict = {'method': 'Network.searchInResponseBody', 'params': params_dict
        }
    json_result = yield cmd_dict
    return [debugger.SearchMatch.from_json(i) for i in json_result['result']]


def set_accepted_encodings(encodings: typing.List[ContentEncoding]
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Sets a list of content encodings that will be accepted. Empty list means no encoding is accepted.

**EXPERIMENTAL**

:param ...:

:param encodings: List of accepted content encodings."""
    params_dict: T_JSON_DICT = dict()
    params_dict['encodings'] = [i.to_json() for i in encodings]
    cmd_dict = {'method': 'Network.setAcceptedEncodings', 'params': params_dict
        }
    json_result = yield cmd_dict
    return None


def set_attach_debug_stack(enabled: bool) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, None]:
    """Specifies whether to attach a page script stack id in requests

**EXPERIMENTAL**

:param ...:

:param enabled: Whether to attach a page script stack for debugging purpose."""
    params_dict: T_JSON_DICT = dict()
    params_dict['enabled'] = enabled
    cmd_dict = {'method': 'Network.setAttachDebugStack', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def set_blocked_ur_ls(urls: typing.List[str]) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, None]:
    """Blocks URLs from loading.

**EXPERIMENTAL**

:param ...:

:param urls: URL patterns to block. Wildcards ('*') are allowed."""
    params_dict: T_JSON_DICT = dict()
    params_dict['urls'] = [i for i in urls]
    cmd_dict = {'method': 'Network.setBlockedURLs', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def set_bypass_service_worker(bypass: bool) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, None]:
    """Toggles ignoring of service worker for each request.

:param ...:

:param bypass: Bypass service worker and load from network."""
    params_dict: T_JSON_DICT = dict()
    params_dict['bypass'] = bypass
    cmd_dict = {'method': 'Network.setBypassServiceWorker', 'params':
        params_dict}
    json_result = yield cmd_dict
    return None


def set_cache_disabled(cache_disabled: bool) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, None]:
    """Toggles ignoring cache for each request. If ``true``, cache will not be used.

:param ...:

:param cache_disabled: Cache disabled state."""
    params_dict: T_JSON_DICT = dict()
    params_dict['cacheDisabled'] = cache_disabled
    cmd_dict = {'method': 'Network.setCacheDisabled', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def set_cookie(name: str, value: str, url: typing.Optional[str]=None,
    domain: typing.Optional[str]=None, path: typing.Optional[str]=None,
    secure: typing.Optional[bool]=None, http_only: typing.Optional[bool]=
    None, same_site: typing.Optional[CookieSameSite]=None, expires: typing.
    Optional[TimeSinceEpoch]=None, priority: typing.Optional[CookiePriority
    ]=None, same_party: typing.Optional[bool]=None, source_scheme: typing.
    Optional[CookieSourceScheme]=None, source_port: typing.Optional[int]=
    None, partition_key: typing.Optional[CookiePartitionKey]=None
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, bool]:
    """Sets a cookie with the given cookie data; may overwrite equivalent cookies if they exist.

:param ...:

:param name: Cookie name.

:param value: Cookie value.

:param url: *(Optional)* The request-URI to associate with the setting of the cookie. This value can affect the default domain, path, source port, and source scheme values of the created cookie.

:param domain: *(Optional)* Cookie domain.

:param path: *(Optional)* Cookie path.

:param secure: *(Optional)* True if cookie is secure.

:param http_only: *(Optional)* True if cookie is http-only.

:param same_site: *(Optional)* Cookie SameSite type.

:param expires: *(Optional)* Cookie expiration date, session cookie if not set

:param priority: **(EXPERIMENTAL)** *(Optional)* Cookie Priority type.

:param same_party: **(EXPERIMENTAL)** *(Optional)* True if cookie is SameParty.

:param source_scheme: **(EXPERIMENTAL)** *(Optional)* Cookie source scheme type.

:param source_port: **(EXPERIMENTAL)** *(Optional)* Cookie source port. Valid values are {-1, [1, 65535]}, -1 indicates an unspecified port. An unspecified port value allows protocol clients to emulate legacy cookie scope for the port. This is a temporary ability and it will be removed in the future.

:param partition_key: **(EXPERIMENTAL)** *(Optional)* Cookie partition key. If not set, the cookie will be set as not partitioned.


:returns: Always set to true. If an error occurs, the response indicates protocol error."""
    params_dict: T_JSON_DICT = dict()
    params_dict['name'] = name
    params_dict['value'] = value
    if url is not None:
        params_dict['url'] = url
    if domain is not None:
        params_dict['domain'] = domain
    if path is not None:
        params_dict['path'] = path
    if secure is not None:
        params_dict['secure'] = secure
    if http_only is not None:
        params_dict['httpOnly'] = http_only
    if same_site is not None:
        params_dict['sameSite'] = same_site.to_json()
    if expires is not None:
        params_dict['expires'] = expires.to_json()
    if priority is not None:
        params_dict['priority'] = priority.to_json()
    if same_party is not None:
        params_dict['sameParty'] = same_party
    if source_scheme is not None:
        params_dict['sourceScheme'] = source_scheme.to_json()
    if source_port is not None:
        params_dict['sourcePort'] = source_port
    if partition_key is not None:
        params_dict['partitionKey'] = partition_key.to_json()
    cmd_dict = {'method': 'Network.setCookie', 'params': params_dict}
    json_result = yield cmd_dict
    return json_result['success']


def set_cookie_controls(enable_third_party_cookie_restriction: bool,
    disable_third_party_cookie_metadata: bool,
    disable_third_party_cookie_heuristics: bool) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, None]:
    """Sets Controls for third-party cookie access
Page reload is required before the new cookie bahavior will be observed

**EXPERIMENTAL**

:param ...:

:param enable_third_party_cookie_restriction: Whether 3pc restriction is enabled.

:param disable_third_party_cookie_metadata: Whether 3pc grace period exception should be enabled; false by default.

:param disable_third_party_cookie_heuristics: Whether 3pc heuristics exceptions should be enabled; false by default."""
    params_dict: T_JSON_DICT = dict()
    params_dict['enableThirdPartyCookieRestriction'
        ] = enable_third_party_cookie_restriction
    params_dict['disableThirdPartyCookieMetadata'
        ] = disable_third_party_cookie_metadata
    params_dict['disableThirdPartyCookieHeuristics'
        ] = disable_third_party_cookie_heuristics
    cmd_dict = {'method': 'Network.setCookieControls', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def set_cookies(cookies: typing.List[CookieParam]) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, None]:
    """Sets given cookies.

:param ...:

:param cookies: Cookies to be set."""
    params_dict: T_JSON_DICT = dict()
    params_dict['cookies'] = [i.to_json() for i in cookies]
    cmd_dict = {'method': 'Network.setCookies', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def set_extra_http_headers(headers: Headers) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, None]:
    """Specifies whether to always send extra HTTP headers with the requests from this page.

:param ...:

:param headers: Map with extra HTTP headers."""
    params_dict: T_JSON_DICT = dict()
    params_dict['headers'] = headers.to_json()
    cmd_dict = {'method': 'Network.setExtraHTTPHeaders', 'params': params_dict}
    json_result = yield cmd_dict
    return None


@deprecated(version='1.3')
def set_request_interception(patterns: typing.List[RequestPattern]
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Sets the requests to intercept that match the provided patterns and optionally resource types.
Deprecated, please use Fetch.enable instead.

.. deprecated:: 1.3

**EXPERIMENTAL**

:param ...:

:param patterns: Requests matching any of these patterns will be forwarded and wait for the corresponding continueInterceptedRequest call."""
    params_dict: T_JSON_DICT = dict()
    params_dict['patterns'] = [i.to_json() for i in patterns]
    cmd_dict = {'method': 'Network.setRequestInterception', 'params':
        params_dict}
    json_result = yield cmd_dict
    return None


def set_user_agent_override(user_agent: str, accept_language: typing.
    Optional[str]=None, platform: typing.Optional[str]=None,
    user_agent_metadata: typing.Optional[emulation.UserAgentMetadata]=None
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Allows overriding user agent with the given string.

Redirects to command 'Emulation'.

:param ...:

:param user_agent: User agent to use.

:param accept_language: *(Optional)* Browser language to emulate.

:param platform: *(Optional)* The platform navigator.platform should return.

:param user_agent_metadata: **(EXPERIMENTAL)** *(Optional)* To be sent in Sec-CH-UA-* headers and returned in navigator.userAgentData"""
    params_dict: T_JSON_DICT = dict()
    params_dict['userAgent'] = user_agent
    if accept_language is not None:
        params_dict['acceptLanguage'] = accept_language
    if platform is not None:
        params_dict['platform'] = platform
    if user_agent_metadata is not None:
        params_dict['userAgentMetadata'] = user_agent_metadata.to_json()
    cmd_dict = {'method': 'Network.setUserAgentOverride', 'params': params_dict
        }
    json_result = yield cmd_dict
    return None


def stream_resource_content(request_id: RequestId) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, str]:
    """Enables streaming of the response for the given requestId.
If enabled, the dataReceived event contains the data that was received during streaming.

**EXPERIMENTAL**

:param ...:

:param request_id: Identifier of the request to stream.


:returns: Data that has been buffered until streaming is enabled. (Encoded as a base64 string when passed over JSON)"""
    params_dict: T_JSON_DICT = dict()
    params_dict['requestId'] = request_id.to_json()
    cmd_dict = {'method': 'Network.streamResourceContent', 'params':
        params_dict}
    json_result = yield cmd_dict
    return json_result['bufferedData']


def take_response_body_for_interception_as_stream(interception_id:
    InterceptionId) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, io.
    StreamHandle]:
    """Returns a handle to the stream representing the response body. Note that after this command,
the intercepted request can't be continued as is -- you either need to cancel it or to provide
the response body. The stream only supports sequential read, IO.read will fail if the position
is specified.

**EXPERIMENTAL**

:param ...:

:param interception_id:


:returns:"""
    params_dict: T_JSON_DICT = dict()
    params_dict['interceptionId'] = interception_id.to_json()
    cmd_dict = {'method': 'Network.takeResponseBodyForInterceptionAsStream',
        'params': params_dict}
    json_result = yield cmd_dict
    return io.StreamHandle.from_json(json_result['stream'])


@event_class('Network.dataReceived')
@dataclass
class DataReceived:
    """Fired when data chunk was received over the network."""
    request_id: RequestId
    timestamp: MonotonicTime
    data_length: int
    encoded_data_length: int
    data: typing.Optional[str] = None

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->DataReceived:
        return cls(request_id=RequestId.from_json(json_obj['requestId']),
            timestamp=MonotonicTime.from_json(json_obj['timestamp']),
            data_length=json_obj['dataLength'], encoded_data_length=
            json_obj['encodedDataLength'], data=json_obj['data'] if 
            json_obj.get('data') is not None else None)


@event_class('Network.directTCPSocketAborted')
@dataclass
class DirectTCPSocketAborted:
    """**EXPERIMENTAL**

Fired when direct_socket.TCPSocket is aborted."""
    identifier: RequestId
    error_message: str
    timestamp: MonotonicTime

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->DirectTCPSocketAborted:
        return cls(identifier=RequestId.from_json(json_obj['identifier']),
            error_message=json_obj['errorMessage'], timestamp=MonotonicTime
            .from_json(json_obj['timestamp']))


@event_class('Network.directTCPSocketChunkError')
@dataclass
class DirectTCPSocketChunkError:
    """**EXPERIMENTAL**

Fired when there is an error
when writing to tcp direct socket stream.
For example, if user writes illegal type like string
instead of ArrayBuffer or ArrayBufferView.
There's no reporting for reading, because
we cannot know errors on the other side."""
    identifier: RequestId
    error_message: str
    timestamp: MonotonicTime

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->DirectTCPSocketChunkError:
        return cls(identifier=RequestId.from_json(json_obj['identifier']),
            error_message=json_obj['errorMessage'], timestamp=MonotonicTime
            .from_json(json_obj['timestamp']))


@event_class('Network.directTCPSocketChunkReceived')
@dataclass
class DirectTCPSocketChunkReceived:
    """**EXPERIMENTAL**

Fired when data is received from tcp direct socket stream."""
    identifier: RequestId
    data: str
    timestamp: MonotonicTime

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->DirectTCPSocketChunkReceived:
        return cls(identifier=RequestId.from_json(json_obj['identifier']),
            data=json_obj['data'], timestamp=MonotonicTime.from_json(
            json_obj['timestamp']))


@event_class('Network.directTCPSocketChunkSent')
@dataclass
class DirectTCPSocketChunkSent:
    """**EXPERIMENTAL**

Fired when data is sent to tcp direct socket stream."""
    identifier: RequestId
    data: str
    timestamp: MonotonicTime

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->DirectTCPSocketChunkSent:
        return cls(identifier=RequestId.from_json(json_obj['identifier']),
            data=json_obj['data'], timestamp=MonotonicTime.from_json(
            json_obj['timestamp']))


@event_class('Network.directTCPSocketClosed')
@dataclass
class DirectTCPSocketClosed:
    """**EXPERIMENTAL**

Fired when direct_socket.TCPSocket is closed."""
    identifier: RequestId
    timestamp: MonotonicTime

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->DirectTCPSocketClosed:
        return cls(identifier=RequestId.from_json(json_obj['identifier']),
            timestamp=MonotonicTime.from_json(json_obj['timestamp']))


@event_class('Network.directTCPSocketCreated')
@dataclass
class DirectTCPSocketCreated:
    """**EXPERIMENTAL**

Fired upon direct_socket.TCPSocket creation."""
    identifier: RequestId
    remote_addr: str
    remote_port: int
    options: DirectTCPSocketOptions
    timestamp: MonotonicTime
    initiator: typing.Optional[Initiator] = None

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->DirectTCPSocketCreated:
        return cls(identifier=RequestId.from_json(json_obj['identifier']),
            remote_addr=json_obj['remoteAddr'], remote_port=json_obj[
            'remotePort'], options=DirectTCPSocketOptions.from_json(
            json_obj['options']), timestamp=MonotonicTime.from_json(
            json_obj['timestamp']), initiator=Initiator.from_json(json_obj[
            'initiator']) if json_obj.get('initiator') is not None else None)


@event_class('Network.directTCPSocketOpened')
@dataclass
class DirectTCPSocketOpened:
    """**EXPERIMENTAL**

Fired when direct_socket.TCPSocket connection is opened."""
    identifier: RequestId
    remote_addr: str
    remote_port: int
    timestamp: MonotonicTime
    local_addr: typing.Optional[str] = None
    local_port: typing.Optional[int] = None

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->DirectTCPSocketOpened:
        return cls(identifier=RequestId.from_json(json_obj['identifier']),
            remote_addr=json_obj['remoteAddr'], remote_port=json_obj[
            'remotePort'], timestamp=MonotonicTime.from_json(json_obj[
            'timestamp']), local_addr=json_obj['localAddr'] if json_obj.get
            ('localAddr') is not None else None, local_port=json_obj[
            'localPort'] if json_obj.get('localPort') is not None else None)


@event_class('Network.eventSourceMessageReceived')
@dataclass
class EventSourceMessageReceived:
    """Fired when EventSource message is received."""
    request_id: RequestId
    timestamp: MonotonicTime
    event_name: str
    event_id: str
    data: str

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->EventSourceMessageReceived:
        return cls(request_id=RequestId.from_json(json_obj['requestId']),
            timestamp=MonotonicTime.from_json(json_obj['timestamp']),
            event_name=json_obj['eventName'], event_id=json_obj['eventId'],
            data=json_obj['data'])


@event_class('Network.loadingFailed')
@dataclass
class LoadingFailed:
    """Fired when HTTP request has failed to load."""
    request_id: RequestId
    timestamp: MonotonicTime
    type_: ResourceType
    error_text: str
    canceled: typing.Optional[bool] = None
    blocked_reason: typing.Optional[BlockedReason] = None
    cors_error_status: typing.Optional[CorsErrorStatus] = None

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->LoadingFailed:
        return cls(request_id=RequestId.from_json(json_obj['requestId']),
            timestamp=MonotonicTime.from_json(json_obj['timestamp']), type_
            =ResourceType.from_json(json_obj['type']), error_text=json_obj[
            'errorText'], canceled=json_obj['canceled'] if json_obj.get(
            'canceled') is not None else None, blocked_reason=BlockedReason
            .from_json(json_obj['blockedReason']) if json_obj.get(
            'blockedReason') is not None else None, cors_error_status=
            CorsErrorStatus.from_json(json_obj['corsErrorStatus']) if 
            json_obj.get('corsErrorStatus') is not None else None)


@event_class('Network.loadingFinished')
@dataclass
class LoadingFinished:
    """Fired when HTTP request has finished loading."""
    request_id: RequestId
    timestamp: MonotonicTime
    encoded_data_length: float

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->LoadingFinished:
        return cls(request_id=RequestId.from_json(json_obj['requestId']),
            timestamp=MonotonicTime.from_json(json_obj['timestamp']),
            encoded_data_length=json_obj['encodedDataLength'])


@event_class('Network.policyUpdated')
@dataclass
class PolicyUpdated:
    """**EXPERIMENTAL**

Fired once security policy has been updated."""
    pass

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->PolicyUpdated:
        return cls()


@event_class('Network.reportingApiEndpointsChangedForOrigin')
@dataclass
class ReportingApiEndpointsChangedForOrigin:
    """**EXPERIMENTAL**"""
    origin: str
    endpoints: typing.List[ReportingApiEndpoint]

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT
        ) ->ReportingApiEndpointsChangedForOrigin:
        return cls(origin=json_obj['origin'], endpoints=[
            ReportingApiEndpoint.from_json(i) for i in json_obj['endpoints']])


@event_class('Network.reportingApiReportAdded')
@dataclass
class ReportingApiReportAdded:
    """**EXPERIMENTAL**

Is sent whenever a new report is added.
And after 'enableReportingApi' for all existing reports."""
    report: ReportingApiReport

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->ReportingApiReportAdded:
        return cls(report=ReportingApiReport.from_json(json_obj['report']))


@event_class('Network.reportingApiReportUpdated')
@dataclass
class ReportingApiReportUpdated:
    """**EXPERIMENTAL**"""
    report: ReportingApiReport

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->ReportingApiReportUpdated:
        return cls(report=ReportingApiReport.from_json(json_obj['report']))


@deprecated(version='1.3')
@event_class('Network.requestIntercepted')
@dataclass
class RequestIntercepted:
    """**EXPERIMENTAL**

Details of an intercepted HTTP request, which must be either allowed, blocked, modified or
mocked.
Deprecated, use Fetch.requestPaused instead.

.. deprecated:: 1.3"""
    interception_id: InterceptionId
    request: Request
    frame_id: page.FrameId
    resource_type: ResourceType
    is_navigation_request: bool
    is_download: typing.Optional[bool] = None
    redirect_url: typing.Optional[str] = None
    auth_challenge: typing.Optional[AuthChallenge] = None
    response_error_reason: typing.Optional[ErrorReason] = None
    response_status_code: typing.Optional[int] = None
    response_headers: typing.Optional[Headers] = None
    request_id: typing.Optional[RequestId] = None

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->RequestIntercepted:
        return cls(interception_id=InterceptionId.from_json(json_obj[
            'interceptionId']), request=Request.from_json(json_obj[
            'request']), frame_id=page.FrameId.from_json(json_obj['frameId'
            ]), resource_type=ResourceType.from_json(json_obj[
            'resourceType']), is_navigation_request=json_obj[
            'isNavigationRequest'], is_download=json_obj['isDownload'] if 
            json_obj.get('isDownload') is not None else None, redirect_url=
            json_obj['redirectUrl'] if json_obj.get('redirectUrl') is not
            None else None, auth_challenge=AuthChallenge.from_json(json_obj
            ['authChallenge']) if json_obj.get('authChallenge') is not None
             else None, response_error_reason=ErrorReason.from_json(
            json_obj['responseErrorReason']) if json_obj.get(
            'responseErrorReason') is not None else None,
            response_status_code=json_obj['responseStatusCode'] if json_obj
            .get('responseStatusCode') is not None else None,
            response_headers=Headers.from_json(json_obj['responseHeaders']) if
            json_obj.get('responseHeaders') is not None else None,
            request_id=RequestId.from_json(json_obj['requestId']) if 
            json_obj.get('requestId') is not None else None)


@event_class('Network.requestServedFromCache')
@dataclass
class RequestServedFromCache:
    """Fired if request ended up loading from cache."""
    request_id: RequestId

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->RequestServedFromCache:
        return cls(request_id=RequestId.from_json(json_obj['requestId']))


@event_class('Network.requestWillBeSent')
@dataclass
class RequestWillBeSent:
    """Fired when page is about to send HTTP request."""
    request_id: RequestId
    loader_id: LoaderId
    document_url: str
    request: Request
    timestamp: MonotonicTime
    wall_time: TimeSinceEpoch
    initiator: Initiator
    redirect_has_extra_info: bool
    redirect_response: typing.Optional[Response] = None
    type_: typing.Optional[ResourceType] = None
    frame_id: typing.Optional[page.FrameId] = None
    has_user_gesture: typing.Optional[bool] = None

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->RequestWillBeSent:
        return cls(request_id=RequestId.from_json(json_obj['requestId']),
            loader_id=LoaderId.from_json(json_obj['loaderId']),
            document_url=json_obj['documentURL'], request=Request.from_json
            (json_obj['request']), timestamp=MonotonicTime.from_json(
            json_obj['timestamp']), wall_time=TimeSinceEpoch.from_json(
            json_obj['wallTime']), initiator=Initiator.from_json(json_obj[
            'initiator']), redirect_has_extra_info=json_obj[
            'redirectHasExtraInfo'], redirect_response=Response.from_json(
            json_obj['redirectResponse']) if json_obj.get(
            'redirectResponse') is not None else None, type_=ResourceType.
            from_json(json_obj['type']) if json_obj.get('type') is not None
             else None, frame_id=page.FrameId.from_json(json_obj['frameId']
            ) if json_obj.get('frameId') is not None else None,
            has_user_gesture=json_obj['hasUserGesture'] if json_obj.get(
            'hasUserGesture') is not None else None)


@event_class('Network.requestWillBeSentExtraInfo')
@dataclass
class RequestWillBeSentExtraInfo:
    """**EXPERIMENTAL**

Fired when additional information about a requestWillBeSent event is available from the
network stack. Not every requestWillBeSent event will have an additional
requestWillBeSentExtraInfo fired for it, and there is no guarantee whether requestWillBeSent
or requestWillBeSentExtraInfo will be fired first for the same request."""
    request_id: RequestId
    associated_cookies: typing.List[AssociatedCookie]
    headers: Headers
    connect_timing: ConnectTiming
    client_security_state: typing.Optional[ClientSecurityState] = None
    site_has_cookie_in_other_partition: typing.Optional[bool] = None

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->RequestWillBeSentExtraInfo:
        return cls(request_id=RequestId.from_json(json_obj['requestId']),
            associated_cookies=[AssociatedCookie.from_json(i) for i in
            json_obj['associatedCookies']], headers=Headers.from_json(
            json_obj['headers']), connect_timing=ConnectTiming.from_json(
            json_obj['connectTiming']), client_security_state=
            ClientSecurityState.from_json(json_obj['clientSecurityState']) if
            json_obj.get('clientSecurityState') is not None else None,
            site_has_cookie_in_other_partition=json_obj[
            'siteHasCookieInOtherPartition'] if json_obj.get(
            'siteHasCookieInOtherPartition') is not None else None)


@event_class('Network.resourceChangedPriority')
@dataclass
class ResourceChangedPriority:
    """**EXPERIMENTAL**

Fired when resource loading priority is changed"""
    request_id: RequestId
    new_priority: ResourcePriority
    timestamp: MonotonicTime

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->ResourceChangedPriority:
        return cls(request_id=RequestId.from_json(json_obj['requestId']),
            new_priority=ResourcePriority.from_json(json_obj['newPriority']
            ), timestamp=MonotonicTime.from_json(json_obj['timestamp']))


@event_class('Network.responseReceived')
@dataclass
class ResponseReceived:
    """Fired when HTTP response is available."""
    request_id: RequestId
    loader_id: LoaderId
    timestamp: MonotonicTime
    type_: ResourceType
    response: Response
    has_extra_info: bool
    frame_id: typing.Optional[page.FrameId] = None

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->ResponseReceived:
        return cls(request_id=RequestId.from_json(json_obj['requestId']),
            loader_id=LoaderId.from_json(json_obj['loaderId']), timestamp=
            MonotonicTime.from_json(json_obj['timestamp']), type_=
            ResourceType.from_json(json_obj['type']), response=Response.
            from_json(json_obj['response']), has_extra_info=json_obj[
            'hasExtraInfo'], frame_id=page.FrameId.from_json(json_obj[
            'frameId']) if json_obj.get('frameId') is not None else None)


@event_class('Network.responseReceivedEarlyHints')
@dataclass
class ResponseReceivedEarlyHints:
    """**EXPERIMENTAL**

Fired when 103 Early Hints headers is received in addition to the common response.
Not every responseReceived event will have an responseReceivedEarlyHints fired.
Only one responseReceivedEarlyHints may be fired for eached responseReceived event."""
    request_id: RequestId
    headers: Headers

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->ResponseReceivedEarlyHints:
        return cls(request_id=RequestId.from_json(json_obj['requestId']),
            headers=Headers.from_json(json_obj['headers']))


@event_class('Network.responseReceivedExtraInfo')
@dataclass
class ResponseReceivedExtraInfo:
    """**EXPERIMENTAL**

Fired when additional information about a responseReceived event is available from the network
stack. Not every responseReceived event will have an additional responseReceivedExtraInfo for
it, and responseReceivedExtraInfo may be fired before or after responseReceived."""
    request_id: RequestId
    blocked_cookies: typing.List[BlockedSetCookieWithReason]
    headers: Headers
    resource_ip_address_space: IPAddressSpace
    status_code: int
    headers_text: typing.Optional[str] = None
    cookie_partition_key: typing.Optional[CookiePartitionKey] = None
    cookie_partition_key_opaque: typing.Optional[bool] = None
    exempted_cookies: typing.Optional[typing.List[ExemptedSetCookieWithReason]
        ] = None

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->ResponseReceivedExtraInfo:
        return cls(request_id=RequestId.from_json(json_obj['requestId']),
            blocked_cookies=[BlockedSetCookieWithReason.from_json(i) for i in
            json_obj['blockedCookies']], headers=Headers.from_json(json_obj
            ['headers']), resource_ip_address_space=IPAddressSpace.
            from_json(json_obj['resourceIPAddressSpace']), status_code=
            json_obj['statusCode'], headers_text=json_obj['headersText'] if
            json_obj.get('headersText') is not None else None,
            cookie_partition_key=CookiePartitionKey.from_json(json_obj[
            'cookiePartitionKey']) if json_obj.get('cookiePartitionKey') is not
            None else None, cookie_partition_key_opaque=json_obj[
            'cookiePartitionKeyOpaque'] if json_obj.get(
            'cookiePartitionKeyOpaque') is not None else None,
            exempted_cookies=[ExemptedSetCookieWithReason.from_json(i) for
            i in json_obj['exemptedCookies']] if json_obj.get(
            'exemptedCookies') is not None else None)


@event_class('Network.signedExchangeReceived')
@dataclass
class SignedExchangeReceived:
    """**EXPERIMENTAL**

Fired when a signed exchange was received over the network"""
    request_id: RequestId
    info: SignedExchangeInfo

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->SignedExchangeReceived:
        return cls(request_id=RequestId.from_json(json_obj['requestId']),
            info=SignedExchangeInfo.from_json(json_obj['info']))


@event_class('Network.subresourceWebBundleInnerResponseError')
@dataclass
class SubresourceWebBundleInnerResponseError:
    """**EXPERIMENTAL**

Fired when request for resources within a .wbn file failed."""
    inner_request_id: RequestId
    inner_request_url: str
    error_message: str
    bundle_request_id: typing.Optional[RequestId] = None

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT
        ) ->SubresourceWebBundleInnerResponseError:
        return cls(inner_request_id=RequestId.from_json(json_obj[
            'innerRequestId']), inner_request_url=json_obj[
            'innerRequestURL'], error_message=json_obj['errorMessage'],
            bundle_request_id=RequestId.from_json(json_obj[
            'bundleRequestId']) if json_obj.get('bundleRequestId') is not
            None else None)


@event_class('Network.subresourceWebBundleInnerResponseParsed')
@dataclass
class SubresourceWebBundleInnerResponseParsed:
    """**EXPERIMENTAL**

Fired when handling requests for resources within a .wbn file.
Note: this will only be fired for resources that are requested by the webpage."""
    inner_request_id: RequestId
    inner_request_url: str
    bundle_request_id: typing.Optional[RequestId] = None

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT
        ) ->SubresourceWebBundleInnerResponseParsed:
        return cls(inner_request_id=RequestId.from_json(json_obj[
            'innerRequestId']), inner_request_url=json_obj[
            'innerRequestURL'], bundle_request_id=RequestId.from_json(
            json_obj['bundleRequestId']) if json_obj.get('bundleRequestId')
             is not None else None)


@event_class('Network.subresourceWebBundleMetadataError')
@dataclass
class SubresourceWebBundleMetadataError:
    """**EXPERIMENTAL**

Fired once when parsing the .wbn file has failed."""
    request_id: RequestId
    error_message: str

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT
        ) ->SubresourceWebBundleMetadataError:
        return cls(request_id=RequestId.from_json(json_obj['requestId']),
            error_message=json_obj['errorMessage'])


@event_class('Network.subresourceWebBundleMetadataReceived')
@dataclass
class SubresourceWebBundleMetadataReceived:
    """**EXPERIMENTAL**

Fired once when parsing the .wbn file has succeeded.
The event contains the information about the web bundle contents."""
    request_id: RequestId
    urls: typing.List[str]

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT
        ) ->SubresourceWebBundleMetadataReceived:
        return cls(request_id=RequestId.from_json(json_obj['requestId']),
            urls=[i for i in json_obj['urls']])


@event_class('Network.trustTokenOperationDone')
@dataclass
class TrustTokenOperationDone:
    """**EXPERIMENTAL**

Fired exactly once for each Trust Token operation. Depending on
the type of the operation and whether the operation succeeded or
failed, the event is fired before the corresponding request was sent
or after the response was received."""
    status: str
    type_: TrustTokenOperationType
    request_id: RequestId
    top_level_origin: typing.Optional[str] = None
    issuer_origin: typing.Optional[str] = None
    issued_token_count: typing.Optional[int] = None

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->TrustTokenOperationDone:
        return cls(status=json_obj['status'], type_=TrustTokenOperationType
            .from_json(json_obj['type']), request_id=RequestId.from_json(
            json_obj['requestId']), top_level_origin=json_obj[
            'topLevelOrigin'] if json_obj.get('topLevelOrigin') is not None
             else None, issuer_origin=json_obj['issuerOrigin'] if json_obj.
            get('issuerOrigin') is not None else None, issued_token_count=
            json_obj['issuedTokenCount'] if json_obj.get('issuedTokenCount'
            ) is not None else None)


@event_class('Network.webSocketClosed')
@dataclass
class WebSocketClosed:
    """Fired when WebSocket is closed."""
    request_id: RequestId
    timestamp: MonotonicTime

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->WebSocketClosed:
        return cls(request_id=RequestId.from_json(json_obj['requestId']),
            timestamp=MonotonicTime.from_json(json_obj['timestamp']))


@event_class('Network.webSocketCreated')
@dataclass
class WebSocketCreated:
    """Fired upon WebSocket creation."""
    request_id: RequestId
    url: str
    initiator: typing.Optional[Initiator] = None

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->WebSocketCreated:
        return cls(request_id=RequestId.from_json(json_obj['requestId']),
            url=json_obj['url'], initiator=Initiator.from_json(json_obj[
            'initiator']) if json_obj.get('initiator') is not None else None)


@event_class('Network.webSocketFrameError')
@dataclass
class WebSocketFrameError:
    """Fired when WebSocket message error occurs."""
    request_id: RequestId
    timestamp: MonotonicTime
    error_message: str

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->WebSocketFrameError:
        return cls(request_id=RequestId.from_json(json_obj['requestId']),
            timestamp=MonotonicTime.from_json(json_obj['timestamp']),
            error_message=json_obj['errorMessage'])


@event_class('Network.webSocketFrameReceived')
@dataclass
class WebSocketFrameReceived:
    """Fired when WebSocket message is received."""
    request_id: RequestId
    timestamp: MonotonicTime
    response: WebSocketFrame

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->WebSocketFrameReceived:
        return cls(request_id=RequestId.from_json(json_obj['requestId']),
            timestamp=MonotonicTime.from_json(json_obj['timestamp']),
            response=WebSocketFrame.from_json(json_obj['response']))


@event_class('Network.webSocketFrameSent')
@dataclass
class WebSocketFrameSent:
    """Fired when WebSocket message is sent."""
    request_id: RequestId
    timestamp: MonotonicTime
    response: WebSocketFrame

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->WebSocketFrameSent:
        return cls(request_id=RequestId.from_json(json_obj['requestId']),
            timestamp=MonotonicTime.from_json(json_obj['timestamp']),
            response=WebSocketFrame.from_json(json_obj['response']))


@event_class('Network.webSocketHandshakeResponseReceived')
@dataclass
class WebSocketHandshakeResponseReceived:
    """Fired when WebSocket handshake response becomes available."""
    request_id: RequestId
    timestamp: MonotonicTime
    response: WebSocketResponse

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT
        ) ->WebSocketHandshakeResponseReceived:
        return cls(request_id=RequestId.from_json(json_obj['requestId']),
            timestamp=MonotonicTime.from_json(json_obj['timestamp']),
            response=WebSocketResponse.from_json(json_obj['response']))


@event_class('Network.webSocketWillSendHandshakeRequest')
@dataclass
class WebSocketWillSendHandshakeRequest:
    """Fired when WebSocket is about to initiate handshake."""
    request_id: RequestId
    timestamp: MonotonicTime
    wall_time: TimeSinceEpoch
    request: WebSocketRequest

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT
        ) ->WebSocketWillSendHandshakeRequest:
        return cls(request_id=RequestId.from_json(json_obj['requestId']),
            timestamp=MonotonicTime.from_json(json_obj['timestamp']),
            wall_time=TimeSinceEpoch.from_json(json_obj['wallTime']),
            request=WebSocketRequest.from_json(json_obj['request']))


@event_class('Network.webTransportClosed')
@dataclass
class WebTransportClosed:
    """Fired when WebTransport is disposed."""
    transport_id: RequestId
    timestamp: MonotonicTime

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->WebTransportClosed:
        return cls(transport_id=RequestId.from_json(json_obj['transportId']
            ), timestamp=MonotonicTime.from_json(json_obj['timestamp']))


@event_class('Network.webTransportConnectionEstablished')
@dataclass
class WebTransportConnectionEstablished:
    """Fired when WebTransport handshake is finished."""
    transport_id: RequestId
    timestamp: MonotonicTime

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT
        ) ->WebTransportConnectionEstablished:
        return cls(transport_id=RequestId.from_json(json_obj['transportId']
            ), timestamp=MonotonicTime.from_json(json_obj['timestamp']))


@event_class('Network.webTransportCreated')
@dataclass
class WebTransportCreated:
    """Fired upon WebTransport creation."""
    transport_id: RequestId
    url: str
    timestamp: MonotonicTime
    initiator: typing.Optional[Initiator] = None

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->WebTransportCreated:
        return cls(transport_id=RequestId.from_json(json_obj['transportId']
            ), url=json_obj['url'], timestamp=MonotonicTime.from_json(
            json_obj['timestamp']), initiator=Initiator.from_json(json_obj[
            'initiator']) if json_obj.get('initiator') is not None else None)
