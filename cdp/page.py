# # DO NOT EDIT THIS FILE!
# #
# # This file is generated from the CDP specification using AST. If you need to make
# # changes, edit the generator and regenerate all of the modules.

from __future__ import annotations
"""CDP domain: Page

Actions and events related to the inspected page belong to the page domain."""
import typing
import enum
from dataclasses import dataclass
from .util import T_JSON_DICT, event_class
from deprecated.sphinx import deprecated
from . import dom
from . import debugger
from . import emulation
from . import io
from . import network
from . import runtime
None


@dataclass
class AdFrameStatus:
    """Indicates whether a frame has been identified as an ad and why."""
    ad_frame_type: AdFrameType
    explanations: typing.Optional[typing.List[AdFrameExplanation]] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['adFrameType'] = self.ad_frame_type.to_json()
        if self.explanations is not None:
            json_data['explanations'] = [i.to_json() for i in self.explanations
                ]
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->AdFrameStatus:
        return cls(ad_frame_type=AdFrameType.from_json(json_obj[
            'adFrameType']), explanations=[AdFrameExplanation.from_json(i) for
            i in json_obj['explanations']] if json_obj.get('explanations')
             is not None else None)


@dataclass
class AdScriptId:
    """Identifies the bottom-most script which caused the frame to be labelled
as an ad."""
    script_id: runtime.ScriptId
    debugger_id: runtime.UniqueDebuggerId

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['scriptId'] = self.script_id.to_json()
        json_data['debuggerId'] = self.debugger_id.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->AdScriptId:
        return cls(script_id=runtime.ScriptId.from_json(json_obj['scriptId'
            ]), debugger_id=runtime.UniqueDebuggerId.from_json(json_obj[
            'debuggerId']))


@dataclass
class AppManifestError:
    """Error while paring app manifest."""
    message: str
    critical: int
    line: int
    column: int

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['message'] = self.message
        json_data['critical'] = self.critical
        json_data['line'] = self.line
        json_data['column'] = self.column
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->AppManifestError:
        return cls(message=json_obj['message'], critical=json_obj[
            'critical'], line=json_obj['line'], column=json_obj['column'])


@dataclass
class AppManifestParsedProperties:
    """Parsed app manifest properties."""
    scope: str

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['scope'] = self.scope
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->AppManifestParsedProperties:
        return cls(scope=json_obj['scope'])


@dataclass
class BackForwardCacheBlockingDetails:
    line_number: int
    column_number: int
    url: typing.Optional[str] = None
    function: typing.Optional[str] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['lineNumber'] = self.line_number
        json_data['columnNumber'] = self.column_number
        if self.url is not None:
            json_data['url'] = self.url
        if self.function is not None:
            json_data['function'] = self.function
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT
        ) ->BackForwardCacheBlockingDetails:
        return cls(line_number=json_obj['lineNumber'], column_number=
            json_obj['columnNumber'], url=json_obj['url'] if json_obj.get(
            'url') is not None else None, function=json_obj['function'] if 
            json_obj.get('function') is not None else None)


@dataclass
class BackForwardCacheNotRestoredExplanation:
    type_: BackForwardCacheNotRestoredReasonType
    reason: BackForwardCacheNotRestoredReason
    context: typing.Optional[str] = None
    details: typing.Optional[typing.List[BackForwardCacheBlockingDetails]
        ] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['type'] = self.type_.to_json()
        json_data['reason'] = self.reason.to_json()
        if self.context is not None:
            json_data['context'] = self.context
        if self.details is not None:
            json_data['details'] = [i.to_json() for i in self.details]
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT
        ) ->BackForwardCacheNotRestoredExplanation:
        return cls(type_=BackForwardCacheNotRestoredReasonType.from_json(
            json_obj['type']), reason=BackForwardCacheNotRestoredReason.
            from_json(json_obj['reason']), context=json_obj['context'] if 
            json_obj.get('context') is not None else None, details=[
            BackForwardCacheBlockingDetails.from_json(i) for i in json_obj[
            'details']] if json_obj.get('details') is not None else None)


@dataclass
class BackForwardCacheNotRestoredExplanationTree:
    url: str
    explanations: typing.List[BackForwardCacheNotRestoredExplanation]
    children: typing.List[BackForwardCacheNotRestoredExplanationTree]

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['url'] = self.url
        json_data['explanations'] = [i.to_json() for i in self.explanations]
        json_data['children'] = [i.to_json() for i in self.children]
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT
        ) ->BackForwardCacheNotRestoredExplanationTree:
        return cls(url=json_obj['url'], explanations=[
            BackForwardCacheNotRestoredExplanation.from_json(i) for i in
            json_obj['explanations']], children=[
            BackForwardCacheNotRestoredExplanationTree.from_json(i) for i in
            json_obj['children']])


@dataclass
class CompilationCacheParams:
    """Per-script compilation cache parameters for ``Page.produceCompilationCache``"""
    url: str
    eager: typing.Optional[bool] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['url'] = self.url
        if self.eager is not None:
            json_data['eager'] = self.eager
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->CompilationCacheParams:
        return cls(url=json_obj['url'], eager=json_obj['eager'] if json_obj
            .get('eager') is not None else None)


@dataclass
class FileFilter:
    name: typing.Optional[str] = None
    accepts: typing.Optional[typing.List[str]] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        if self.name is not None:
            json_data['name'] = self.name
        if self.accepts is not None:
            json_data['accepts'] = [i for i in self.accepts]
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->FileFilter:
        return cls(name=json_obj['name'] if json_obj.get('name') is not
            None else None, accepts=[i for i in json_obj['accepts']] if 
            json_obj.get('accepts') is not None else None)


@dataclass
class FileHandler:
    action: str
    name: str
    launch_type: str
    icons: typing.Optional[typing.List[ImageResource]] = None
    accepts: typing.Optional[typing.List[FileFilter]] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['action'] = self.action
        json_data['name'] = self.name
        json_data['launchType'] = self.launch_type
        if self.icons is not None:
            json_data['icons'] = [i.to_json() for i in self.icons]
        if self.accepts is not None:
            json_data['accepts'] = [i.to_json() for i in self.accepts]
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->FileHandler:
        return cls(action=json_obj['action'], name=json_obj['name'],
            launch_type=json_obj['launchType'], icons=[ImageResource.
            from_json(i) for i in json_obj['icons']] if json_obj.get(
            'icons') is not None else None, accepts=[FileFilter.from_json(i
            ) for i in json_obj['accepts']] if json_obj.get('accepts') is not
            None else None)


@dataclass
class FontFamilies:
    """Generic font families collection."""
    standard: typing.Optional[str] = None
    fixed: typing.Optional[str] = None
    serif: typing.Optional[str] = None
    sans_serif: typing.Optional[str] = None
    cursive: typing.Optional[str] = None
    fantasy: typing.Optional[str] = None
    math: typing.Optional[str] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        if self.standard is not None:
            json_data['standard'] = self.standard
        if self.fixed is not None:
            json_data['fixed'] = self.fixed
        if self.serif is not None:
            json_data['serif'] = self.serif
        if self.sans_serif is not None:
            json_data['sansSerif'] = self.sans_serif
        if self.cursive is not None:
            json_data['cursive'] = self.cursive
        if self.fantasy is not None:
            json_data['fantasy'] = self.fantasy
        if self.math is not None:
            json_data['math'] = self.math
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->FontFamilies:
        return cls(standard=json_obj['standard'] if json_obj.get('standard'
            ) is not None else None, fixed=json_obj['fixed'] if json_obj.
            get('fixed') is not None else None, serif=json_obj['serif'] if 
            json_obj.get('serif') is not None else None, sans_serif=
            json_obj['sansSerif'] if json_obj.get('sansSerif') is not None else
            None, cursive=json_obj['cursive'] if json_obj.get('cursive') is not
            None else None, fantasy=json_obj['fantasy'] if json_obj.get(
            'fantasy') is not None else None, math=json_obj['math'] if 
            json_obj.get('math') is not None else None)


@dataclass
class FontSizes:
    """Default font sizes."""
    standard: typing.Optional[int] = None
    fixed: typing.Optional[int] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        if self.standard is not None:
            json_data['standard'] = self.standard
        if self.fixed is not None:
            json_data['fixed'] = self.fixed
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->FontSizes:
        return cls(standard=json_obj['standard'] if json_obj.get('standard'
            ) is not None else None, fixed=json_obj['fixed'] if json_obj.
            get('fixed') is not None else None)


@dataclass
class Frame:
    """Information about the Frame on the page."""
    id_: FrameId
    loader_id: network.LoaderId
    url: str
    domain_and_registry: str
    security_origin: str
    mime_type: str
    secure_context_type: SecureContextType
    cross_origin_isolated_context_type: CrossOriginIsolatedContextType
    gated_api_features: typing.List[GatedAPIFeatures]
    parent_id: typing.Optional[FrameId] = None
    name: typing.Optional[str] = None
    url_fragment: typing.Optional[str] = None
    security_origin_details: typing.Optional[SecurityOriginDetails] = None
    unreachable_url: typing.Optional[str] = None
    ad_frame_status: typing.Optional[AdFrameStatus] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['id'] = self.id_.to_json()
        json_data['loaderId'] = self.loader_id.to_json()
        json_data['url'] = self.url
        json_data['domainAndRegistry'] = self.domain_and_registry
        json_data['securityOrigin'] = self.security_origin
        json_data['mimeType'] = self.mime_type
        json_data['secureContextType'] = self.secure_context_type.to_json()
        json_data['crossOriginIsolatedContextType'
            ] = self.cross_origin_isolated_context_type.to_json()
        json_data['gatedAPIFeatures'] = [i.to_json() for i in self.
            gated_api_features]
        if self.parent_id is not None:
            json_data['parentId'] = self.parent_id.to_json()
        if self.name is not None:
            json_data['name'] = self.name
        if self.url_fragment is not None:
            json_data['urlFragment'] = self.url_fragment
        if self.security_origin_details is not None:
            json_data['securityOriginDetails'
                ] = self.security_origin_details.to_json()
        if self.unreachable_url is not None:
            json_data['unreachableUrl'] = self.unreachable_url
        if self.ad_frame_status is not None:
            json_data['adFrameStatus'] = self.ad_frame_status.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->Frame:
        return cls(id_=FrameId.from_json(json_obj['id']), loader_id=network
            .LoaderId.from_json(json_obj['loaderId']), url=json_obj['url'],
            domain_and_registry=json_obj['domainAndRegistry'],
            security_origin=json_obj['securityOrigin'], mime_type=json_obj[
            'mimeType'], secure_context_type=SecureContextType.from_json(
            json_obj['secureContextType']),
            cross_origin_isolated_context_type=
            CrossOriginIsolatedContextType.from_json(json_obj[
            'crossOriginIsolatedContextType']), gated_api_features=[
            GatedAPIFeatures.from_json(i) for i in json_obj[
            'gatedAPIFeatures']], parent_id=FrameId.from_json(json_obj[
            'parentId']) if json_obj.get('parentId') is not None else None,
            name=json_obj['name'] if json_obj.get('name') is not None else
            None, url_fragment=json_obj['urlFragment'] if json_obj.get(
            'urlFragment') is not None else None, security_origin_details=
            SecurityOriginDetails.from_json(json_obj[
            'securityOriginDetails']) if json_obj.get(
            'securityOriginDetails') is not None else None, unreachable_url
            =json_obj['unreachableUrl'] if json_obj.get('unreachableUrl')
             is not None else None, ad_frame_status=AdFrameStatus.from_json
            (json_obj['adFrameStatus']) if json_obj.get('adFrameStatus') is not
            None else None)


@dataclass
class FrameResource:
    """Information about the Resource on the page."""
    url: str
    type_: network.ResourceType
    mime_type: str
    last_modified: typing.Optional[network.TimeSinceEpoch] = None
    content_size: typing.Optional[float] = None
    failed: typing.Optional[bool] = None
    canceled: typing.Optional[bool] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['url'] = self.url
        json_data['type'] = self.type_.to_json()
        json_data['mimeType'] = self.mime_type
        if self.last_modified is not None:
            json_data['lastModified'] = self.last_modified.to_json()
        if self.content_size is not None:
            json_data['contentSize'] = self.content_size
        if self.failed is not None:
            json_data['failed'] = self.failed
        if self.canceled is not None:
            json_data['canceled'] = self.canceled
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->FrameResource:
        return cls(url=json_obj['url'], type_=network.ResourceType.
            from_json(json_obj['type']), mime_type=json_obj['mimeType'],
            last_modified=network.TimeSinceEpoch.from_json(json_obj[
            'lastModified']) if json_obj.get('lastModified') is not None else
            None, content_size=json_obj['contentSize'] if json_obj.get(
            'contentSize') is not None else None, failed=json_obj['failed'] if
            json_obj.get('failed') is not None else None, canceled=json_obj
            ['canceled'] if json_obj.get('canceled') is not None else None)


@dataclass
class FrameResourceTree:
    """Information about the Frame hierarchy along with their cached resources."""
    frame: Frame
    resources: typing.List[FrameResource]
    child_frames: typing.Optional[typing.List[FrameResourceTree]] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['frame'] = self.frame.to_json()
        json_data['resources'] = [i.to_json() for i in self.resources]
        if self.child_frames is not None:
            json_data['childFrames'] = [i.to_json() for i in self.child_frames]
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->FrameResourceTree:
        return cls(frame=Frame.from_json(json_obj['frame']), resources=[
            FrameResource.from_json(i) for i in json_obj['resources']],
            child_frames=[FrameResourceTree.from_json(i) for i in json_obj[
            'childFrames']] if json_obj.get('childFrames') is not None else
            None)


@dataclass
class FrameTree:
    """Information about the Frame hierarchy."""
    frame: Frame
    child_frames: typing.Optional[typing.List[FrameTree]] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['frame'] = self.frame.to_json()
        if self.child_frames is not None:
            json_data['childFrames'] = [i.to_json() for i in self.child_frames]
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->FrameTree:
        return cls(frame=Frame.from_json(json_obj['frame']), child_frames=[
            FrameTree.from_json(i) for i in json_obj['childFrames']] if 
            json_obj.get('childFrames') is not None else None)


@dataclass
class ImageResource:
    """The image definition used in both icon and screenshot."""
    url: str
    sizes: typing.Optional[str] = None
    type_: typing.Optional[str] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['url'] = self.url
        if self.sizes is not None:
            json_data['sizes'] = self.sizes
        if self.type_ is not None:
            json_data['type'] = self.type_
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->ImageResource:
        return cls(url=json_obj['url'], sizes=json_obj['sizes'] if json_obj
            .get('sizes') is not None else None, type_=json_obj['type'] if 
            json_obj.get('type') is not None else None)


@dataclass
class InstallabilityError:
    """The installability error"""
    error_id: str
    error_arguments: typing.List[InstallabilityErrorArgument]

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['errorId'] = self.error_id
        json_data['errorArguments'] = [i.to_json() for i in self.
            error_arguments]
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->InstallabilityError:
        return cls(error_id=json_obj['errorId'], error_arguments=[
            InstallabilityErrorArgument.from_json(i) for i in json_obj[
            'errorArguments']])


@dataclass
class InstallabilityErrorArgument:
    name: str
    value: str

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['name'] = self.name
        json_data['value'] = self.value
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->InstallabilityErrorArgument:
        return cls(name=json_obj['name'], value=json_obj['value'])


@dataclass
class LaunchHandler:
    client_mode: str

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['clientMode'] = self.client_mode
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->LaunchHandler:
        return cls(client_mode=json_obj['clientMode'])


@dataclass
class LayoutViewport:
    """Layout viewport position and dimensions."""
    page_x: int
    page_y: int
    client_width: int
    client_height: int

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['pageX'] = self.page_x
        json_data['pageY'] = self.page_y
        json_data['clientWidth'] = self.client_width
        json_data['clientHeight'] = self.client_height
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->LayoutViewport:
        return cls(page_x=json_obj['pageX'], page_y=json_obj['pageY'],
            client_width=json_obj['clientWidth'], client_height=json_obj[
            'clientHeight'])


@dataclass
class NavigationEntry:
    """Navigation history entry."""
    id_: int
    url: str
    user_typed_url: str
    title: str
    transition_type: TransitionType

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['id'] = self.id_
        json_data['url'] = self.url
        json_data['userTypedURL'] = self.user_typed_url
        json_data['title'] = self.title
        json_data['transitionType'] = self.transition_type.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->NavigationEntry:
        return cls(id_=json_obj['id'], url=json_obj['url'], user_typed_url=
            json_obj['userTypedURL'], title=json_obj['title'],
            transition_type=TransitionType.from_json(json_obj[
            'transitionType']))


@dataclass
class OriginTrial:
    trial_name: str
    status: OriginTrialStatus
    tokens_with_status: typing.List[OriginTrialTokenWithStatus]

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['trialName'] = self.trial_name
        json_data['status'] = self.status.to_json()
        json_data['tokensWithStatus'] = [i.to_json() for i in self.
            tokens_with_status]
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->OriginTrial:
        return cls(trial_name=json_obj['trialName'], status=
            OriginTrialStatus.from_json(json_obj['status']),
            tokens_with_status=[OriginTrialTokenWithStatus.from_json(i) for
            i in json_obj['tokensWithStatus']])


@dataclass
class OriginTrialToken:
    origin: str
    match_sub_domains: bool
    trial_name: str
    expiry_time: network.TimeSinceEpoch
    is_third_party: bool
    usage_restriction: OriginTrialUsageRestriction

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['origin'] = self.origin
        json_data['matchSubDomains'] = self.match_sub_domains
        json_data['trialName'] = self.trial_name
        json_data['expiryTime'] = self.expiry_time.to_json()
        json_data['isThirdParty'] = self.is_third_party
        json_data['usageRestriction'] = self.usage_restriction.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->OriginTrialToken:
        return cls(origin=json_obj['origin'], match_sub_domains=json_obj[
            'matchSubDomains'], trial_name=json_obj['trialName'],
            expiry_time=network.TimeSinceEpoch.from_json(json_obj[
            'expiryTime']), is_third_party=json_obj['isThirdParty'],
            usage_restriction=OriginTrialUsageRestriction.from_json(
            json_obj['usageRestriction']))


@dataclass
class OriginTrialTokenWithStatus:
    raw_token_text: str
    status: OriginTrialTokenStatus
    parsed_token: typing.Optional[OriginTrialToken] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['rawTokenText'] = self.raw_token_text
        json_data['status'] = self.status.to_json()
        if self.parsed_token is not None:
            json_data['parsedToken'] = self.parsed_token.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->OriginTrialTokenWithStatus:
        return cls(raw_token_text=json_obj['rawTokenText'], status=
            OriginTrialTokenStatus.from_json(json_obj['status']),
            parsed_token=OriginTrialToken.from_json(json_obj['parsedToken']
            ) if json_obj.get('parsedToken') is not None else None)


@dataclass
class PermissionsPolicyBlockLocator:
    frame_id: FrameId
    block_reason: PermissionsPolicyBlockReason

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['frameId'] = self.frame_id.to_json()
        json_data['blockReason'] = self.block_reason.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->PermissionsPolicyBlockLocator:
        return cls(frame_id=FrameId.from_json(json_obj['frameId']),
            block_reason=PermissionsPolicyBlockReason.from_json(json_obj[
            'blockReason']))


@dataclass
class PermissionsPolicyFeatureState:
    feature: PermissionsPolicyFeature
    allowed: bool
    locator: typing.Optional[PermissionsPolicyBlockLocator] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['feature'] = self.feature.to_json()
        json_data['allowed'] = self.allowed
        if self.locator is not None:
            json_data['locator'] = self.locator.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->PermissionsPolicyFeatureState:
        return cls(feature=PermissionsPolicyFeature.from_json(json_obj[
            'feature']), allowed=json_obj['allowed'], locator=
            PermissionsPolicyBlockLocator.from_json(json_obj['locator']) if
            json_obj.get('locator') is not None else None)


@dataclass
class ProtocolHandler:
    protocol: str
    url: str

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['protocol'] = self.protocol
        json_data['url'] = self.url
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->ProtocolHandler:
        return cls(protocol=json_obj['protocol'], url=json_obj['url'])


@dataclass
class RelatedApplication:
    url: str
    id_: typing.Optional[str] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['url'] = self.url
        if self.id_ is not None:
            json_data['id'] = self.id_
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->RelatedApplication:
        return cls(url=json_obj['url'], id_=json_obj['id'] if json_obj.get(
            'id') is not None else None)


@dataclass
class ScopeExtension:
    origin: str
    has_origin_wildcard: bool

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['origin'] = self.origin
        json_data['hasOriginWildcard'] = self.has_origin_wildcard
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->ScopeExtension:
        return cls(origin=json_obj['origin'], has_origin_wildcard=json_obj[
            'hasOriginWildcard'])


@dataclass
class ScreencastFrameMetadata:
    """Screencast frame metadata."""
    offset_top: float
    page_scale_factor: float
    device_width: float
    device_height: float
    scroll_offset_x: float
    scroll_offset_y: float
    timestamp: typing.Optional[network.TimeSinceEpoch] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['offsetTop'] = self.offset_top
        json_data['pageScaleFactor'] = self.page_scale_factor
        json_data['deviceWidth'] = self.device_width
        json_data['deviceHeight'] = self.device_height
        json_data['scrollOffsetX'] = self.scroll_offset_x
        json_data['scrollOffsetY'] = self.scroll_offset_y
        if self.timestamp is not None:
            json_data['timestamp'] = self.timestamp.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->ScreencastFrameMetadata:
        return cls(offset_top=json_obj['offsetTop'], page_scale_factor=
            json_obj['pageScaleFactor'], device_width=json_obj[
            'deviceWidth'], device_height=json_obj['deviceHeight'],
            scroll_offset_x=json_obj['scrollOffsetX'], scroll_offset_y=
            json_obj['scrollOffsetY'], timestamp=network.TimeSinceEpoch.
            from_json(json_obj['timestamp']) if json_obj.get('timestamp')
             is not None else None)


@dataclass
class Screenshot:
    image: ImageResource
    form_factor: str
    label: typing.Optional[str] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['image'] = self.image.to_json()
        json_data['formFactor'] = self.form_factor
        if self.label is not None:
            json_data['label'] = self.label
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->Screenshot:
        return cls(image=ImageResource.from_json(json_obj['image']),
            form_factor=json_obj['formFactor'], label=json_obj['label'] if 
            json_obj.get('label') is not None else None)


@dataclass
class ScriptFontFamilies:
    """Font families collection for a script."""
    script: str
    font_families: FontFamilies

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['script'] = self.script
        json_data['fontFamilies'] = self.font_families.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->ScriptFontFamilies:
        return cls(script=json_obj['script'], font_families=FontFamilies.
            from_json(json_obj['fontFamilies']))


@dataclass
class SecurityOriginDetails:
    """Additional information about the frame document's security origin."""
    is_localhost: bool

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['isLocalhost'] = self.is_localhost
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->SecurityOriginDetails:
        return cls(is_localhost=json_obj['isLocalhost'])


@dataclass
class ShareTarget:
    action: str
    method: str
    enctype: str
    title: typing.Optional[str] = None
    text: typing.Optional[str] = None
    url: typing.Optional[str] = None
    files: typing.Optional[typing.List[FileFilter]] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['action'] = self.action
        json_data['method'] = self.method
        json_data['enctype'] = self.enctype
        if self.title is not None:
            json_data['title'] = self.title
        if self.text is not None:
            json_data['text'] = self.text
        if self.url is not None:
            json_data['url'] = self.url
        if self.files is not None:
            json_data['files'] = [i.to_json() for i in self.files]
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->ShareTarget:
        return cls(action=json_obj['action'], method=json_obj['method'],
            enctype=json_obj['enctype'], title=json_obj['title'] if 
            json_obj.get('title') is not None else None, text=json_obj[
            'text'] if json_obj.get('text') is not None else None, url=
            json_obj['url'] if json_obj.get('url') is not None else None,
            files=[FileFilter.from_json(i) for i in json_obj['files']] if 
            json_obj.get('files') is not None else None)


@dataclass
class Shortcut:
    name: str
    url: str

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['name'] = self.name
        json_data['url'] = self.url
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->Shortcut:
        return cls(name=json_obj['name'], url=json_obj['url'])


@dataclass
class Viewport:
    """Viewport for capturing screenshot."""
    x: float
    y: float
    width: float
    height: float
    scale: float

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['x'] = self.x
        json_data['y'] = self.y
        json_data['width'] = self.width
        json_data['height'] = self.height
        json_data['scale'] = self.scale
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->Viewport:
        return cls(x=json_obj['x'], y=json_obj['y'], width=json_obj['width'
            ], height=json_obj['height'], scale=json_obj['scale'])


@dataclass
class VisualViewport:
    """Visual viewport position, dimensions, and scale."""
    offset_x: float
    offset_y: float
    page_x: float
    page_y: float
    client_width: float
    client_height: float
    scale: float
    zoom: typing.Optional[float] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['offsetX'] = self.offset_x
        json_data['offsetY'] = self.offset_y
        json_data['pageX'] = self.page_x
        json_data['pageY'] = self.page_y
        json_data['clientWidth'] = self.client_width
        json_data['clientHeight'] = self.client_height
        json_data['scale'] = self.scale
        if self.zoom is not None:
            json_data['zoom'] = self.zoom
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->VisualViewport:
        return cls(offset_x=json_obj['offsetX'], offset_y=json_obj[
            'offsetY'], page_x=json_obj['pageX'], page_y=json_obj['pageY'],
            client_width=json_obj['clientWidth'], client_height=json_obj[
            'clientHeight'], scale=json_obj['scale'], zoom=json_obj['zoom'] if
            json_obj.get('zoom') is not None else None)


@dataclass
class WebAppManifest:
    background_color: typing.Optional[str] = None
    description: typing.Optional[str] = None
    dir_: typing.Optional[str] = None
    display: typing.Optional[str] = None
    display_overrides: typing.Optional[typing.List[str]] = None
    file_handlers: typing.Optional[typing.List[FileHandler]] = None
    icons: typing.Optional[typing.List[ImageResource]] = None
    id_: typing.Optional[str] = None
    lang: typing.Optional[str] = None
    launch_handler: typing.Optional[LaunchHandler] = None
    name: typing.Optional[str] = None
    orientation: typing.Optional[str] = None
    prefer_related_applications: typing.Optional[bool] = None
    protocol_handlers: typing.Optional[typing.List[ProtocolHandler]] = None
    related_applications: typing.Optional[typing.List[RelatedApplication]
        ] = None
    scope: typing.Optional[str] = None
    scope_extensions: typing.Optional[typing.List[ScopeExtension]] = None
    screenshots: typing.Optional[typing.List[Screenshot]] = None
    share_target: typing.Optional[ShareTarget] = None
    short_name: typing.Optional[str] = None
    shortcuts: typing.Optional[typing.List[Shortcut]] = None
    start_url: typing.Optional[str] = None
    theme_color: typing.Optional[str] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        if self.background_color is not None:
            json_data['backgroundColor'] = self.background_color
        if self.description is not None:
            json_data['description'] = self.description
        if self.dir_ is not None:
            json_data['dir'] = self.dir_
        if self.display is not None:
            json_data['display'] = self.display
        if self.display_overrides is not None:
            json_data['displayOverrides'] = [i for i in self.display_overrides]
        if self.file_handlers is not None:
            json_data['fileHandlers'] = [i.to_json() for i in self.
                file_handlers]
        if self.icons is not None:
            json_data['icons'] = [i.to_json() for i in self.icons]
        if self.id_ is not None:
            json_data['id'] = self.id_
        if self.lang is not None:
            json_data['lang'] = self.lang
        if self.launch_handler is not None:
            json_data['launchHandler'] = self.launch_handler.to_json()
        if self.name is not None:
            json_data['name'] = self.name
        if self.orientation is not None:
            json_data['orientation'] = self.orientation
        if self.prefer_related_applications is not None:
            json_data['preferRelatedApplications'
                ] = self.prefer_related_applications
        if self.protocol_handlers is not None:
            json_data['protocolHandlers'] = [i.to_json() for i in self.
                protocol_handlers]
        if self.related_applications is not None:
            json_data['relatedApplications'] = [i.to_json() for i in self.
                related_applications]
        if self.scope is not None:
            json_data['scope'] = self.scope
        if self.scope_extensions is not None:
            json_data['scopeExtensions'] = [i.to_json() for i in self.
                scope_extensions]
        if self.screenshots is not None:
            json_data['screenshots'] = [i.to_json() for i in self.screenshots]
        if self.share_target is not None:
            json_data['shareTarget'] = self.share_target.to_json()
        if self.short_name is not None:
            json_data['shortName'] = self.short_name
        if self.shortcuts is not None:
            json_data['shortcuts'] = [i.to_json() for i in self.shortcuts]
        if self.start_url is not None:
            json_data['startUrl'] = self.start_url
        if self.theme_color is not None:
            json_data['themeColor'] = self.theme_color
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->WebAppManifest:
        return cls(background_color=json_obj['backgroundColor'] if json_obj
            .get('backgroundColor') is not None else None, description=
            json_obj['description'] if json_obj.get('description') is not
            None else None, dir_=json_obj['dir'] if json_obj.get('dir') is not
            None else None, display=json_obj['display'] if json_obj.get(
            'display') is not None else None, display_overrides=[i for i in
            json_obj['displayOverrides']] if json_obj.get(
            'displayOverrides') is not None else None, file_handlers=[
            FileHandler.from_json(i) for i in json_obj['fileHandlers']] if 
            json_obj.get('fileHandlers') is not None else None, icons=[
            ImageResource.from_json(i) for i in json_obj['icons']] if 
            json_obj.get('icons') is not None else None, id_=json_obj['id'] if
            json_obj.get('id') is not None else None, lang=json_obj['lang'] if
            json_obj.get('lang') is not None else None, launch_handler=
            LaunchHandler.from_json(json_obj['launchHandler']) if json_obj.
            get('launchHandler') is not None else None, name=json_obj[
            'name'] if json_obj.get('name') is not None else None,
            orientation=json_obj['orientation'] if json_obj.get(
            'orientation') is not None else None,
            prefer_related_applications=json_obj[
            'preferRelatedApplications'] if json_obj.get(
            'preferRelatedApplications') is not None else None,
            protocol_handlers=[ProtocolHandler.from_json(i) for i in
            json_obj['protocolHandlers']] if json_obj.get(
            'protocolHandlers') is not None else None, related_applications
            =[RelatedApplication.from_json(i) for i in json_obj[
            'relatedApplications']] if json_obj.get('relatedApplications')
             is not None else None, scope=json_obj['scope'] if json_obj.get
            ('scope') is not None else None, scope_extensions=[
            ScopeExtension.from_json(i) for i in json_obj['scopeExtensions'
            ]] if json_obj.get('scopeExtensions') is not None else None,
            screenshots=[Screenshot.from_json(i) for i in json_obj[
            'screenshots']] if json_obj.get('screenshots') is not None else
            None, share_target=ShareTarget.from_json(json_obj['shareTarget'
            ]) if json_obj.get('shareTarget') is not None else None,
            short_name=json_obj['shortName'] if json_obj.get('shortName')
             is not None else None, shortcuts=[Shortcut.from_json(i) for i in
            json_obj['shortcuts']] if json_obj.get('shortcuts') is not None
             else None, start_url=json_obj['startUrl'] if json_obj.get(
            'startUrl') is not None else None, theme_color=json_obj[
            'themeColor'] if json_obj.get('themeColor') is not None else None)


class AdFrameExplanation(enum.Enum):
    PARENT_IS_AD = 'ParentIsAd'
    CREATED_BY_AD_SCRIPT = 'CreatedByAdScript'
    MATCHED_BLOCKING_RULE = 'MatchedBlockingRule'

    @classmethod
    def from_json(cls, json: str) ->AdFrameExplanation:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<AdFrameExplanation.{}>'.format(self.value)


class AdFrameType(enum.Enum):
    """Indicates whether a frame has been identified as an ad."""
    NONE = 'none'
    CHILD = 'child'
    ROOT = 'root'

    @classmethod
    def from_json(cls, json: str) ->AdFrameType:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<AdFrameType.{}>'.format(self.value)


class AutoResponseMode(enum.Enum):
    """Enum of possible auto-response for permission / prompt dialogs."""
    NONE = 'none'
    AUTO_ACCEPT = 'autoAccept'
    AUTO_REJECT = 'autoReject'
    AUTO_OPT_OUT = 'autoOptOut'

    @classmethod
    def from_json(cls, json: str) ->AutoResponseMode:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<AutoResponseMode.{}>'.format(self.value)


class BackForwardCacheNotRestoredReason(enum.Enum):
    """List of not restored reasons for back-forward cache."""
    NOT_PRIMARY_MAIN_FRAME = 'NotPrimaryMainFrame'
    BACK_FORWARD_CACHE_DISABLED = 'BackForwardCacheDisabled'
    RELATED_ACTIVE_CONTENTS_EXIST = 'RelatedActiveContentsExist'
    HTTP_STATUS_NOT_OK = 'HTTPStatusNotOK'
    SCHEME_NOT_HTTP_OR_HTTPS = 'SchemeNotHTTPOrHTTPS'
    LOADING = 'Loading'
    WAS_GRANTED_MEDIA_ACCESS = 'WasGrantedMediaAccess'
    DISABLE_FOR_RENDER_FRAME_HOST_CALLED = 'DisableForRenderFrameHostCalled'
    DOMAIN_NOT_ALLOWED = 'DomainNotAllowed'
    HTTP_METHOD_NOT_GET = 'HTTPMethodNotGET'
    SUBFRAME_IS_NAVIGATING = 'SubframeIsNavigating'
    TIMEOUT = 'Timeout'
    CACHE_LIMIT = 'CacheLimit'
    JAVA_SCRIPT_EXECUTION = 'JavaScriptExecution'
    RENDERER_PROCESS_KILLED = 'RendererProcessKilled'
    RENDERER_PROCESS_CRASHED = 'RendererProcessCrashed'
    SCHEDULER_TRACKED_FEATURE_USED = 'SchedulerTrackedFeatureUsed'
    CONFLICTING_BROWSING_INSTANCE = 'ConflictingBrowsingInstance'
    CACHE_FLUSHED = 'CacheFlushed'
    SERVICE_WORKER_VERSION_ACTIVATION = 'ServiceWorkerVersionActivation'
    SESSION_RESTORED = 'SessionRestored'
    SERVICE_WORKER_POST_MESSAGE = 'ServiceWorkerPostMessage'
    ENTERED_BACK_FORWARD_CACHE_BEFORE_SERVICE_WORKER_HOST_ADDED = (
        'EnteredBackForwardCacheBeforeServiceWorkerHostAdded')
    RENDER_FRAME_HOST_REUSED_SAME_SITE = 'RenderFrameHostReused_SameSite'
    RENDER_FRAME_HOST_REUSED_CROSS_SITE = 'RenderFrameHostReused_CrossSite'
    SERVICE_WORKER_CLAIM = 'ServiceWorkerClaim'
    IGNORE_EVENT_AND_EVICT = 'IgnoreEventAndEvict'
    HAVE_INNER_CONTENTS = 'HaveInnerContents'
    TIMEOUT_PUTTING_IN_CACHE = 'TimeoutPuttingInCache'
    BACK_FORWARD_CACHE_DISABLED_BY_LOW_MEMORY = (
        'BackForwardCacheDisabledByLowMemory')
    BACK_FORWARD_CACHE_DISABLED_BY_COMMAND_LINE = (
        'BackForwardCacheDisabledByCommandLine')
    NETWORK_REQUEST_DATAPIPE_DRAINED_AS_BYTES_CONSUMER = (
        'NetworkRequestDatapipeDrainedAsBytesConsumer')
    NETWORK_REQUEST_REDIRECTED = 'NetworkRequestRedirected'
    NETWORK_REQUEST_TIMEOUT = 'NetworkRequestTimeout'
    NETWORK_EXCEEDS_BUFFER_LIMIT = 'NetworkExceedsBufferLimit'
    NAVIGATION_CANCELLED_WHILE_RESTORING = 'NavigationCancelledWhileRestoring'
    NOT_MOST_RECENT_NAVIGATION_ENTRY = 'NotMostRecentNavigationEntry'
    BACK_FORWARD_CACHE_DISABLED_FOR_PRERENDER = (
        'BackForwardCacheDisabledForPrerender')
    USER_AGENT_OVERRIDE_DIFFERS = 'UserAgentOverrideDiffers'
    FOREGROUND_CACHE_LIMIT = 'ForegroundCacheLimit'
    BROWSING_INSTANCE_NOT_SWAPPED = 'BrowsingInstanceNotSwapped'
    BACK_FORWARD_CACHE_DISABLED_FOR_DELEGATE = (
        'BackForwardCacheDisabledForDelegate')
    UNLOAD_HANDLER_EXISTS_IN_MAIN_FRAME = 'UnloadHandlerExistsInMainFrame'
    UNLOAD_HANDLER_EXISTS_IN_SUB_FRAME = 'UnloadHandlerExistsInSubFrame'
    SERVICE_WORKER_UNREGISTRATION = 'ServiceWorkerUnregistration'
    CACHE_CONTROL_NO_STORE = 'CacheControlNoStore'
    CACHE_CONTROL_NO_STORE_COOKIE_MODIFIED = (
        'CacheControlNoStoreCookieModified')
    CACHE_CONTROL_NO_STORE_HTTP_ONLY_COOKIE_MODIFIED = (
        'CacheControlNoStoreHTTPOnlyCookieModified')
    NO_RESPONSE_HEAD = 'NoResponseHead'
    UNKNOWN = 'Unknown'
    ACTIVATION_NAVIGATIONS_DISALLOWED_FOR_BUG1234857 = (
        'ActivationNavigationsDisallowedForBug1234857')
    ERROR_DOCUMENT = 'ErrorDocument'
    FENCED_FRAMES_EMBEDDER = 'FencedFramesEmbedder'
    COOKIE_DISABLED = 'CookieDisabled'
    HTTP_AUTH_REQUIRED = 'HTTPAuthRequired'
    COOKIE_FLUSHED = 'CookieFlushed'
    BROADCAST_CHANNEL_ON_MESSAGE = 'BroadcastChannelOnMessage'
    WEB_VIEW_SETTINGS_CHANGED = 'WebViewSettingsChanged'
    WEB_VIEW_JAVA_SCRIPT_OBJECT_CHANGED = 'WebViewJavaScriptObjectChanged'
    WEB_VIEW_MESSAGE_LISTENER_INJECTED = 'WebViewMessageListenerInjected'
    WEB_VIEW_SAFE_BROWSING_ALLOWLIST_CHANGED = (
        'WebViewSafeBrowsingAllowlistChanged')
    WEB_VIEW_DOCUMENT_START_JAVASCRIPT_CHANGED = (
        'WebViewDocumentStartJavascriptChanged')
    WEB_SOCKET = 'WebSocket'
    WEB_TRANSPORT = 'WebTransport'
    WEB_RTC = 'WebRTC'
    MAIN_RESOURCE_HAS_CACHE_CONTROL_NO_STORE = (
        'MainResourceHasCacheControlNoStore')
    MAIN_RESOURCE_HAS_CACHE_CONTROL_NO_CACHE = (
        'MainResourceHasCacheControlNoCache')
    SUBRESOURCE_HAS_CACHE_CONTROL_NO_STORE = (
        'SubresourceHasCacheControlNoStore')
    SUBRESOURCE_HAS_CACHE_CONTROL_NO_CACHE = (
        'SubresourceHasCacheControlNoCache')
    CONTAINS_PLUGINS = 'ContainsPlugins'
    DOCUMENT_LOADED = 'DocumentLoaded'
    OUTSTANDING_NETWORK_REQUEST_OTHERS = 'OutstandingNetworkRequestOthers'
    REQUESTED_MIDI_PERMISSION = 'RequestedMIDIPermission'
    REQUESTED_AUDIO_CAPTURE_PERMISSION = 'RequestedAudioCapturePermission'
    REQUESTED_VIDEO_CAPTURE_PERMISSION = 'RequestedVideoCapturePermission'
    REQUESTED_BACK_FORWARD_CACHE_BLOCKED_SENSORS = (
        'RequestedBackForwardCacheBlockedSensors')
    REQUESTED_BACKGROUND_WORK_PERMISSION = 'RequestedBackgroundWorkPermission'
    BROADCAST_CHANNEL = 'BroadcastChannel'
    WEB_XR = 'WebXR'
    SHARED_WORKER = 'SharedWorker'
    WEB_LOCKS = 'WebLocks'
    WEB_HID = 'WebHID'
    WEB_SHARE = 'WebShare'
    REQUESTED_STORAGE_ACCESS_GRANT = 'RequestedStorageAccessGrant'
    WEB_NFC = 'WebNfc'
    OUTSTANDING_NETWORK_REQUEST_FETCH = 'OutstandingNetworkRequestFetch'
    OUTSTANDING_NETWORK_REQUEST_XHR = 'OutstandingNetworkRequestXHR'
    APP_BANNER = 'AppBanner'
    PRINTING = 'Printing'
    WEB_DATABASE = 'WebDatabase'
    PICTURE_IN_PICTURE = 'PictureInPicture'
    SPEECH_RECOGNIZER = 'SpeechRecognizer'
    IDLE_MANAGER = 'IdleManager'
    PAYMENT_MANAGER = 'PaymentManager'
    SPEECH_SYNTHESIS = 'SpeechSynthesis'
    KEYBOARD_LOCK = 'KeyboardLock'
    WEB_OTP_SERVICE = 'WebOTPService'
    OUTSTANDING_NETWORK_REQUEST_DIRECT_SOCKET = (
        'OutstandingNetworkRequestDirectSocket')
    INJECTED_JAVASCRIPT = 'InjectedJavascript'
    INJECTED_STYLE_SHEET = 'InjectedStyleSheet'
    KEEPALIVE_REQUEST = 'KeepaliveRequest'
    INDEXED_DB_EVENT = 'IndexedDBEvent'
    DUMMY = 'Dummy'
    JS_NETWORK_REQUEST_RECEIVED_CACHE_CONTROL_NO_STORE_RESOURCE = (
        'JsNetworkRequestReceivedCacheControlNoStoreResource')
    WEB_RTC_STICKY = 'WebRTCSticky'
    WEB_TRANSPORT_STICKY = 'WebTransportSticky'
    WEB_SOCKET_STICKY = 'WebSocketSticky'
    SMART_CARD = 'SmartCard'
    LIVE_MEDIA_STREAM_TRACK = 'LiveMediaStreamTrack'
    UNLOAD_HANDLER = 'UnloadHandler'
    PARSER_ABORTED = 'ParserAborted'
    CONTENT_SECURITY_HANDLER = 'ContentSecurityHandler'
    CONTENT_WEB_AUTHENTICATION_API = 'ContentWebAuthenticationAPI'
    CONTENT_FILE_CHOOSER = 'ContentFileChooser'
    CONTENT_SERIAL = 'ContentSerial'
    CONTENT_FILE_SYSTEM_ACCESS = 'ContentFileSystemAccess'
    CONTENT_MEDIA_DEVICES_DISPATCHER_HOST = 'ContentMediaDevicesDispatcherHost'
    CONTENT_WEB_BLUETOOTH = 'ContentWebBluetooth'
    CONTENT_WEB_USB = 'ContentWebUSB'
    CONTENT_MEDIA_SESSION_SERVICE = 'ContentMediaSessionService'
    CONTENT_SCREEN_READER = 'ContentScreenReader'
    CONTENT_DISCARDED = 'ContentDiscarded'
    EMBEDDER_POPUP_BLOCKER_TAB_HELPER = 'EmbedderPopupBlockerTabHelper'
    EMBEDDER_SAFE_BROWSING_TRIGGERED_POPUP_BLOCKER = (
        'EmbedderSafeBrowsingTriggeredPopupBlocker')
    EMBEDDER_SAFE_BROWSING_THREAT_DETAILS = 'EmbedderSafeBrowsingThreatDetails'
    EMBEDDER_APP_BANNER_MANAGER = 'EmbedderAppBannerManager'
    EMBEDDER_DOM_DISTILLER_VIEWER_SOURCE = 'EmbedderDomDistillerViewerSource'
    EMBEDDER_DOM_DISTILLER_SELF_DELETING_REQUEST_DELEGATE = (
        'EmbedderDomDistillerSelfDeletingRequestDelegate')
    EMBEDDER_OOM_INTERVENTION_TAB_HELPER = 'EmbedderOomInterventionTabHelper'
    EMBEDDER_OFFLINE_PAGE = 'EmbedderOfflinePage'
    EMBEDDER_CHROME_PASSWORD_MANAGER_CLIENT_BIND_CREDENTIAL_MANAGER = (
        'EmbedderChromePasswordManagerClientBindCredentialManager')
    EMBEDDER_PERMISSION_REQUEST_MANAGER = 'EmbedderPermissionRequestManager'
    EMBEDDER_MODAL_DIALOG = 'EmbedderModalDialog'
    EMBEDDER_EXTENSIONS = 'EmbedderExtensions'
    EMBEDDER_EXTENSION_MESSAGING = 'EmbedderExtensionMessaging'
    EMBEDDER_EXTENSION_MESSAGING_FOR_OPEN_PORT = (
        'EmbedderExtensionMessagingForOpenPort')
    EMBEDDER_EXTENSION_SENT_MESSAGE_TO_CACHED_FRAME = (
        'EmbedderExtensionSentMessageToCachedFrame')
    REQUESTED_BY_WEB_VIEW_CLIENT = 'RequestedByWebViewClient'
    POST_MESSAGE_BY_WEB_VIEW_CLIENT = 'PostMessageByWebViewClient'
    CACHE_CONTROL_NO_STORE_DEVICE_BOUND_SESSION_TERMINATED = (
        'CacheControlNoStoreDeviceBoundSessionTerminated')
    CACHE_LIMIT_PRUNED = 'CacheLimitPruned'

    @classmethod
    def from_json(cls, json: str) ->BackForwardCacheNotRestoredReason:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<BackForwardCacheNotRestoredReason.{}>'.format(self.value)


class BackForwardCacheNotRestoredReasonType(enum.Enum):
    """Types of not restored reasons for back-forward cache."""
    SUPPORT_PENDING = 'SupportPending'
    PAGE_SUPPORT_NEEDED = 'PageSupportNeeded'
    CIRCUMSTANTIAL = 'Circumstantial'

    @classmethod
    def from_json(cls, json: str) ->BackForwardCacheNotRestoredReasonType:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<BackForwardCacheNotRestoredReasonType.{}>'.format(self.value)


class ClientNavigationDisposition(enum.Enum):
    CURRENT_TAB = 'currentTab'
    NEW_TAB = 'newTab'
    NEW_WINDOW = 'newWindow'
    DOWNLOAD = 'download'

    @classmethod
    def from_json(cls, json: str) ->ClientNavigationDisposition:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<ClientNavigationDisposition.{}>'.format(self.value)


class ClientNavigationReason(enum.Enum):
    ANCHOR_CLICK = 'anchorClick'
    FORM_SUBMISSION_GET = 'formSubmissionGet'
    FORM_SUBMISSION_POST = 'formSubmissionPost'
    HTTP_HEADER_REFRESH = 'httpHeaderRefresh'
    INITIAL_FRAME_NAVIGATION = 'initialFrameNavigation'
    META_TAG_REFRESH = 'metaTagRefresh'
    OTHER = 'other'
    PAGE_BLOCK_INTERSTITIAL = 'pageBlockInterstitial'
    RELOAD = 'reload'
    SCRIPT_INITIATED = 'scriptInitiated'

    @classmethod
    def from_json(cls, json: str) ->ClientNavigationReason:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<ClientNavigationReason.{}>'.format(self.value)


class CrossOriginIsolatedContextType(enum.Enum):
    """Indicates whether the frame is cross-origin isolated and why it is the case."""
    ISOLATED = 'Isolated'
    NOT_ISOLATED = 'NotIsolated'
    NOT_ISOLATED_FEATURE_DISABLED = 'NotIsolatedFeatureDisabled'

    @classmethod
    def from_json(cls, json: str) ->CrossOriginIsolatedContextType:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<CrossOriginIsolatedContextType.{}>'.format(self.value)


class DialogType(enum.Enum):
    """Javascript dialog type."""
    ALERT = 'alert'
    CONFIRM = 'confirm'
    PROMPT = 'prompt'
    BEFOREUNLOAD = 'beforeunload'

    @classmethod
    def from_json(cls, json: str) ->DialogType:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<DialogType.{}>'.format(self.value)


class GatedAPIFeatures(enum.Enum):
    SHARED_ARRAY_BUFFERS = 'SharedArrayBuffers'
    SHARED_ARRAY_BUFFERS_TRANSFER_ALLOWED = 'SharedArrayBuffersTransferAllowed'
    PERFORMANCE_MEASURE_MEMORY = 'PerformanceMeasureMemory'
    PERFORMANCE_PROFILE = 'PerformanceProfile'

    @classmethod
    def from_json(cls, json: str) ->GatedAPIFeatures:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<GatedAPIFeatures.{}>'.format(self.value)


class NavigationType(enum.Enum):
    """The type of a frameNavigated event."""
    NAVIGATION = 'Navigation'
    BACK_FORWARD_CACHE_RESTORE = 'BackForwardCacheRestore'

    @classmethod
    def from_json(cls, json: str) ->NavigationType:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<NavigationType.{}>'.format(self.value)


class OriginTrialStatus(enum.Enum):
    """Status for an Origin Trial."""
    ENABLED = 'Enabled'
    VALID_TOKEN_NOT_PROVIDED = 'ValidTokenNotProvided'
    OS_NOT_SUPPORTED = 'OSNotSupported'
    TRIAL_NOT_ALLOWED = 'TrialNotAllowed'

    @classmethod
    def from_json(cls, json: str) ->OriginTrialStatus:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<OriginTrialStatus.{}>'.format(self.value)


class OriginTrialTokenStatus(enum.Enum):
    """Origin Trial(https://www.chromium.org/blink/origin-trials) support.
Status for an Origin Trial token."""
    SUCCESS = 'Success'
    NOT_SUPPORTED = 'NotSupported'
    INSECURE = 'Insecure'
    EXPIRED = 'Expired'
    WRONG_ORIGIN = 'WrongOrigin'
    INVALID_SIGNATURE = 'InvalidSignature'
    MALFORMED = 'Malformed'
    WRONG_VERSION = 'WrongVersion'
    FEATURE_DISABLED = 'FeatureDisabled'
    TOKEN_DISABLED = 'TokenDisabled'
    FEATURE_DISABLED_FOR_USER = 'FeatureDisabledForUser'
    UNKNOWN_TRIAL = 'UnknownTrial'

    @classmethod
    def from_json(cls, json: str) ->OriginTrialTokenStatus:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<OriginTrialTokenStatus.{}>'.format(self.value)


class OriginTrialUsageRestriction(enum.Enum):
    NONE = 'None'
    SUBSET = 'Subset'

    @classmethod
    def from_json(cls, json: str) ->OriginTrialUsageRestriction:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<OriginTrialUsageRestriction.{}>'.format(self.value)


class PermissionsPolicyBlockReason(enum.Enum):
    """Reason for a permissions policy feature to be disabled."""
    HEADER = 'Header'
    IFRAME_ATTRIBUTE = 'IframeAttribute'
    IN_FENCED_FRAME_TREE = 'InFencedFrameTree'
    IN_ISOLATED_APP = 'InIsolatedApp'

    @classmethod
    def from_json(cls, json: str) ->PermissionsPolicyBlockReason:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<PermissionsPolicyBlockReason.{}>'.format(self.value)


class PermissionsPolicyFeature(enum.Enum):
    """All Permissions Policy features. This enum should match the one defined
in services/network/public/cpp/permissions_policy/permissions_policy_features.json5."""
    ACCELEROMETER = 'accelerometer'
    ALL_SCREENS_CAPTURE = 'all-screens-capture'
    AMBIENT_LIGHT_SENSOR = 'ambient-light-sensor'
    ATTRIBUTION_REPORTING = 'attribution-reporting'
    AUTOPLAY = 'autoplay'
    BLUETOOTH = 'bluetooth'
    BROWSING_TOPICS = 'browsing-topics'
    CAMERA = 'camera'
    CAPTURED_SURFACE_CONTROL = 'captured-surface-control'
    CH_DPR = 'ch-dpr'
    CH_DEVICE_MEMORY = 'ch-device-memory'
    CH_DOWNLINK = 'ch-downlink'
    CH_ECT = 'ch-ect'
    CH_PREFERS_COLOR_SCHEME = 'ch-prefers-color-scheme'
    CH_PREFERS_REDUCED_MOTION = 'ch-prefers-reduced-motion'
    CH_PREFERS_REDUCED_TRANSPARENCY = 'ch-prefers-reduced-transparency'
    CH_RTT = 'ch-rtt'
    CH_SAVE_DATA = 'ch-save-data'
    CH_UA = 'ch-ua'
    CH_UA_ARCH = 'ch-ua-arch'
    CH_UA_BITNESS = 'ch-ua-bitness'
    CH_UA_HIGH_ENTROPY_VALUES = 'ch-ua-high-entropy-values'
    CH_UA_PLATFORM = 'ch-ua-platform'
    CH_UA_MODEL = 'ch-ua-model'
    CH_UA_MOBILE = 'ch-ua-mobile'
    CH_UA_FORM_FACTORS = 'ch-ua-form-factors'
    CH_UA_FULL_VERSION = 'ch-ua-full-version'
    CH_UA_FULL_VERSION_LIST = 'ch-ua-full-version-list'
    CH_UA_PLATFORM_VERSION = 'ch-ua-platform-version'
    CH_UA_WOW64 = 'ch-ua-wow64'
    CH_VIEWPORT_HEIGHT = 'ch-viewport-height'
    CH_VIEWPORT_WIDTH = 'ch-viewport-width'
    CH_WIDTH = 'ch-width'
    CLIPBOARD_READ = 'clipboard-read'
    CLIPBOARD_WRITE = 'clipboard-write'
    COMPUTE_PRESSURE = 'compute-pressure'
    CONTROLLED_FRAME = 'controlled-frame'
    CROSS_ORIGIN_ISOLATED = 'cross-origin-isolated'
    DEFERRED_FETCH = 'deferred-fetch'
    DEFERRED_FETCH_MINIMAL = 'deferred-fetch-minimal'
    DEVICE_ATTRIBUTES = 'device-attributes'
    DIGITAL_CREDENTIALS_GET = 'digital-credentials-get'
    DIRECT_SOCKETS = 'direct-sockets'
    DIRECT_SOCKETS_PRIVATE = 'direct-sockets-private'
    DISPLAY_CAPTURE = 'display-capture'
    DOCUMENT_DOMAIN = 'document-domain'
    ENCRYPTED_MEDIA = 'encrypted-media'
    EXECUTION_WHILE_OUT_OF_VIEWPORT = 'execution-while-out-of-viewport'
    EXECUTION_WHILE_NOT_RENDERED = 'execution-while-not-rendered'
    FENCED_UNPARTITIONED_STORAGE_READ = 'fenced-unpartitioned-storage-read'
    FOCUS_WITHOUT_USER_ACTIVATION = 'focus-without-user-activation'
    FULLSCREEN = 'fullscreen'
    FROBULATE = 'frobulate'
    GAMEPAD = 'gamepad'
    GEOLOCATION = 'geolocation'
    GYROSCOPE = 'gyroscope'
    HID = 'hid'
    IDENTITY_CREDENTIALS_GET = 'identity-credentials-get'
    IDLE_DETECTION = 'idle-detection'
    INTEREST_COHORT = 'interest-cohort'
    JOIN_AD_INTEREST_GROUP = 'join-ad-interest-group'
    KEYBOARD_MAP = 'keyboard-map'
    LANGUAGE_DETECTOR = 'language-detector'
    LOCAL_FONTS = 'local-fonts'
    MAGNETOMETER = 'magnetometer'
    MEDIA_PLAYBACK_WHILE_NOT_VISIBLE = 'media-playback-while-not-visible'
    MICROPHONE = 'microphone'
    MIDI = 'midi'
    OTP_CREDENTIALS = 'otp-credentials'
    PAYMENT = 'payment'
    PICTURE_IN_PICTURE = 'picture-in-picture'
    POPINS = 'popins'
    PRIVATE_AGGREGATION = 'private-aggregation'
    PRIVATE_STATE_TOKEN_ISSUANCE = 'private-state-token-issuance'
    PRIVATE_STATE_TOKEN_REDEMPTION = 'private-state-token-redemption'
    PUBLICKEY_CREDENTIALS_CREATE = 'publickey-credentials-create'
    PUBLICKEY_CREDENTIALS_GET = 'publickey-credentials-get'
    REWRITER = 'rewriter'
    RUN_AD_AUCTION = 'run-ad-auction'
    SCREEN_WAKE_LOCK = 'screen-wake-lock'
    SERIAL = 'serial'
    SHARED_AUTOFILL = 'shared-autofill'
    SHARED_STORAGE = 'shared-storage'
    SHARED_STORAGE_SELECT_URL = 'shared-storage-select-url'
    SMART_CARD = 'smart-card'
    SPEAKER_SELECTION = 'speaker-selection'
    STORAGE_ACCESS = 'storage-access'
    SUB_APPS = 'sub-apps'
    SUMMARIZER = 'summarizer'
    SYNC_XHR = 'sync-xhr'
    TRANSLATOR = 'translator'
    UNLOAD = 'unload'
    USB = 'usb'
    USB_UNRESTRICTED = 'usb-unrestricted'
    VERTICAL_SCROLL = 'vertical-scroll'
    WEB_APP_INSTALLATION = 'web-app-installation'
    WEB_PRINTING = 'web-printing'
    WEB_SHARE = 'web-share'
    WINDOW_MANAGEMENT = 'window-management'
    WRITER = 'writer'
    XR_SPATIAL_TRACKING = 'xr-spatial-tracking'

    @classmethod
    def from_json(cls, json: str) ->PermissionsPolicyFeature:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<PermissionsPolicyFeature.{}>'.format(self.value)


class ReferrerPolicy(enum.Enum):
    """The referring-policy used for the navigation."""
    NO_REFERRER = 'noReferrer'
    NO_REFERRER_WHEN_DOWNGRADE = 'noReferrerWhenDowngrade'
    ORIGIN = 'origin'
    ORIGIN_WHEN_CROSS_ORIGIN = 'originWhenCrossOrigin'
    SAME_ORIGIN = 'sameOrigin'
    STRICT_ORIGIN = 'strictOrigin'
    STRICT_ORIGIN_WHEN_CROSS_ORIGIN = 'strictOriginWhenCrossOrigin'
    UNSAFE_URL = 'unsafeUrl'

    @classmethod
    def from_json(cls, json: str) ->ReferrerPolicy:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<ReferrerPolicy.{}>'.format(self.value)


class SecureContextType(enum.Enum):
    """Indicates whether the frame is a secure context and why it is the case."""
    SECURE = 'Secure'
    SECURE_LOCALHOST = 'SecureLocalhost'
    INSECURE_SCHEME = 'InsecureScheme'
    INSECURE_ANCESTOR = 'InsecureAncestor'

    @classmethod
    def from_json(cls, json: str) ->SecureContextType:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<SecureContextType.{}>'.format(self.value)


class TransitionType(enum.Enum):
    """Transition type."""
    LINK = 'link'
    TYPED = 'typed'
    ADDRESS_BAR = 'address_bar'
    AUTO_BOOKMARK = 'auto_bookmark'
    AUTO_SUBFRAME = 'auto_subframe'
    MANUAL_SUBFRAME = 'manual_subframe'
    GENERATED = 'generated'
    AUTO_TOPLEVEL = 'auto_toplevel'
    FORM_SUBMIT = 'form_submit'
    RELOAD = 'reload'
    KEYWORD = 'keyword'
    KEYWORD_GENERATED = 'keyword_generated'
    OTHER = 'other'

    @classmethod
    def from_json(cls, json: str) ->TransitionType:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<TransitionType.{}>'.format(self.value)


class FrameId(str):
    """Unique frame identifier.

Represents the CDP type 'Page.FrameId'."""

    def to_json(self) ->str:
        return self

    @classmethod
    def from_json(cls, json: str) ->FrameId:
        return cls(json)

    def __repr__(self) ->str:
        return 'FrameId({})'.format(super().__repr__())


class ScriptIdentifier(str):
    """Unique script identifier.

Represents the CDP type 'Page.ScriptIdentifier'."""

    def to_json(self) ->str:
        return self

    @classmethod
    def from_json(cls, json: str) ->ScriptIdentifier:
        return cls(json)

    def __repr__(self) ->str:
        return 'ScriptIdentifier({})'.format(super().__repr__())


def add_compilation_cache(url: str, data: str) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, None]:
    """Seeds compilation cache for given url. Compilation cache does not survive
cross-process navigation.

**EXPERIMENTAL**

:param ...:

:param url:

:param data: Base64-encoded data (Encoded as a base64 string when passed over JSON)"""
    params_dict: T_JSON_DICT = dict()
    params_dict['url'] = url
    params_dict['data'] = data
    cmd_dict = {'method': 'Page.addCompilationCache', 'params': params_dict}
    json_result = yield cmd_dict
    return None


@deprecated(version='1.3')
def add_script_to_evaluate_on_load(script_source: str) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """Deprecated, please use addScriptToEvaluateOnNewDocument instead.

.. deprecated:: 1.3

**EXPERIMENTAL**

:param ...:

:param script_source:


:returns: Identifier of the added script."""
    params_dict: T_JSON_DICT = dict()
    params_dict['scriptSource'] = script_source
    cmd_dict = {'method': 'Page.addScriptToEvaluateOnLoad', 'params':
        params_dict}
    json_result = yield cmd_dict
    return ScriptIdentifier.from_json(json_result['identifier'])


def add_script_to_evaluate_on_new_document(source: str, world_name: typing.
    Optional[str]=None, include_command_line_api: typing.Optional[bool]=
    None, run_immediately: typing.Optional[bool]=None) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """Evaluates given script in every frame upon creation (before loading frame's scripts).

:param ...:

:param source:

:param world_name: **(EXPERIMENTAL)** *(Optional)* If specified, creates an isolated world with the given name and evaluates given script in it. This world name will be used as the ExecutionContextDescription::name when the corresponding event is emitted.

:param include_command_line_api: **(EXPERIMENTAL)** *(Optional)* Specifies whether command line API should be available to the script, defaults to false.

:param run_immediately: **(EXPERIMENTAL)** *(Optional)* If true, runs the script immediately on existing execution contexts or worlds. Default: false.


:returns: Identifier of the added script."""
    params_dict: T_JSON_DICT = dict()
    params_dict['source'] = source
    if world_name is not None:
        params_dict['worldName'] = world_name
    if include_command_line_api is not None:
        params_dict['includeCommandLineAPI'] = include_command_line_api
    if run_immediately is not None:
        params_dict['runImmediately'] = run_immediately
    cmd_dict = {'method': 'Page.addScriptToEvaluateOnNewDocument', 'params':
        params_dict}
    json_result = yield cmd_dict
    return ScriptIdentifier.from_json(json_result['identifier'])


def bring_to_front() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Brings page to front (activates tab)."""
    cmd_dict = {'method': 'Page.bringToFront'}
    json_result = yield cmd_dict
    return None


def capture_screenshot(format_: typing.Optional[str]=None, quality: typing.
    Optional[int]=None, clip: typing.Optional[Viewport]=None, from_surface:
    typing.Optional[bool]=None, capture_beyond_viewport: typing.Optional[
    bool]=None, optimize_for_speed: typing.Optional[bool]=None
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """Capture page screenshot.

:param ...:

:param format_: *(Optional)* Image compression format (defaults to png).

:param quality: *(Optional)* Compression quality from range [0..100] (jpeg only).

:param clip: *(Optional)* Capture the screenshot of a given region only.

:param from_surface: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot from the surface, rather than the view. Defaults to true.

:param capture_beyond_viewport: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot beyond the viewport. Defaults to false.

:param optimize_for_speed: **(EXPERIMENTAL)** *(Optional)* Optimize image encoding for speed, not for resulting size (defaults to false)


:returns: Base64-encoded image data. (Encoded as a base64 string when passed over JSON)"""
    params_dict: T_JSON_DICT = dict()
    if format_ is not None:
        params_dict['format'] = format_
    if quality is not None:
        params_dict['quality'] = quality
    if clip is not None:
        params_dict['clip'] = clip.to_json()
    if from_surface is not None:
        params_dict['fromSurface'] = from_surface
    if capture_beyond_viewport is not None:
        params_dict['captureBeyondViewport'] = capture_beyond_viewport
    if optimize_for_speed is not None:
        params_dict['optimizeForSpeed'] = optimize_for_speed
    cmd_dict = {'method': 'Page.captureScreenshot', 'params': params_dict}
    json_result = yield cmd_dict
    return json_result['data']


def capture_snapshot(format_: typing.Optional[str]=None) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, str]:
    """Returns a snapshot of the page as a string. For MHTML format, the serialization includes
iframes, shadow DOM, external resources, and element-inline styles.

**EXPERIMENTAL**

:param ...:

:param format_: *(Optional)* Format (defaults to mhtml).


:returns: Serialized page data."""
    params_dict: T_JSON_DICT = dict()
    if format_ is not None:
        params_dict['format'] = format_
    cmd_dict = {'method': 'Page.captureSnapshot', 'params': params_dict}
    json_result = yield cmd_dict
    return json_result['data']


def clear_compilation_cache() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None
    ]:
    """Clears seeded compilation cache.

**EXPERIMENTAL**"""
    cmd_dict = {'method': 'Page.clearCompilationCache'}
    json_result = yield cmd_dict
    return None


@deprecated(version='1.3')
def clear_device_metrics_override() ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, None]:
    """Clears the overridden device metrics.

Redirects to command 'Emulation'.

.. deprecated:: 1.3

**EXPERIMENTAL**"""
    cmd_dict = {'method': 'Page.clearDeviceMetricsOverride'}
    json_result = yield cmd_dict
    return None


@deprecated(version='1.3')
def clear_device_orientation_override() ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, None]:
    """Clears the overridden Device Orientation.

Redirects to command 'DeviceOrientation'.

.. deprecated:: 1.3

**EXPERIMENTAL**"""
    cmd_dict = {'method': 'Page.clearDeviceOrientationOverride'}
    json_result = yield cmd_dict
    return None


@deprecated(version='1.3')
def clear_geolocation_override() ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, None]:
    """Clears the overridden Geolocation Position and Error.

Redirects to command 'Emulation'.

.. deprecated:: 1.3"""
    cmd_dict = {'method': 'Page.clearGeolocationOverride'}
    json_result = yield cmd_dict
    return None


def close() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Tries to close page, running its beforeunload hooks, if any."""
    cmd_dict = {'method': 'Page.close'}
    json_result = yield cmd_dict
    return None


def crash() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Crashes renderer on the IO thread, generates minidumps.

**EXPERIMENTAL**"""
    cmd_dict = {'method': 'Page.crash'}
    json_result = yield cmd_dict
    return None


def create_isolated_world(frame_id: FrameId, world_name: typing.Optional[
    str]=None, grant_univeral_access: typing.Optional[bool]=None
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, runtime.ExecutionContextId]:
    """Creates an isolated world for the given frame.

:param ...:

:param frame_id: Id of the frame in which the isolated world should be created.

:param world_name: *(Optional)* An optional name which is reported in the Execution Context.

:param grant_univeral_access: *(Optional)* Whether or not universal access should be granted to the isolated world. This is a powerful option, use with caution.


:returns: Execution context of the isolated world."""
    params_dict: T_JSON_DICT = dict()
    params_dict['frameId'] = frame_id.to_json()
    if world_name is not None:
        params_dict['worldName'] = world_name
    if grant_univeral_access is not None:
        params_dict['grantUniveralAccess'] = grant_univeral_access
    cmd_dict = {'method': 'Page.createIsolatedWorld', 'params': params_dict}
    json_result = yield cmd_dict
    return runtime.ExecutionContextId.from_json(json_result[
        'executionContextId'])


@deprecated(version='1.3')
def delete_cookie(cookie_name: str, url: str) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, None]:
    """Deletes browser cookie with given name, domain and path.

Redirects to command 'Network'.

.. deprecated:: 1.3

**EXPERIMENTAL**

:param ...:

:param cookie_name: Name of the cookie to remove.

:param url: URL to match cooke domain and path."""
    params_dict: T_JSON_DICT = dict()
    params_dict['cookieName'] = cookie_name
    params_dict['url'] = url
    cmd_dict = {'method': 'Page.deleteCookie', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def disable() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Disables page domain notifications."""
    cmd_dict = {'method': 'Page.disable'}
    json_result = yield cmd_dict
    return None


def enable(enable_file_chooser_opened_event: typing.Optional[bool]=None
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Enables page domain notifications.

:param ...:

:param enable_file_chooser_opened_event: **(EXPERIMENTAL)** *(Optional)* If true, the ``Page.fileChooserOpened`` event will be emitted regardless of the state set by ``Page.setInterceptFileChooserDialog`` command (default: false)."""
    params_dict: T_JSON_DICT = dict()
    if enable_file_chooser_opened_event is not None:
        params_dict['enableFileChooserOpenedEvent'
            ] = enable_file_chooser_opened_event
    cmd_dict = {'method': 'Page.enable', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def generate_test_report(message: str, group: typing.Optional[str]=None
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Generates a report for testing.

**EXPERIMENTAL**

:param ...:

:param message: Message to be displayed in the report.

:param group: *(Optional)* Specifies the endpoint group to deliver the report to."""
    params_dict: T_JSON_DICT = dict()
    params_dict['message'] = message
    if group is not None:
        params_dict['group'] = group
    cmd_dict = {'method': 'Page.generateTestReport', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def get_ad_script_id(frame_id: FrameId) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, typing.Optional[AdScriptId]]:
    """**EXPERIMENTAL**


:param ...:

:param frame_id:


:returns: *(Optional)* Identifies the bottom-most script which caused the frame to be labelled as an ad. Only sent if frame is labelled as an ad and id is available."""
    params_dict: T_JSON_DICT = dict()
    params_dict['frameId'] = frame_id.to_json()
    cmd_dict = {'method': 'Page.getAdScriptId', 'params': params_dict}
    json_result = yield cmd_dict
    return AdScriptId.from_json(json_result['adScriptId']) if json_result.get(
        'adScriptId') is not None else None


def get_app_id() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, typing.Tuple[
    typing.Optional[str], typing.Optional[str]]]:
    """Returns the unique (PWA) app id.
Only returns values if the feature flag 'WebAppEnableManifestId' is enabled

**EXPERIMENTAL**


:returns: A tuple with the following items:

    1. **appId** - *(Optional)* App id, either from manifest's id attribute or computed from start_url
    2. **recommendedId** - *(Optional)* Recommendation for manifest's id attribute to match current id computed from start_url"""
    cmd_dict = {'method': 'Page.getAppId'}
    json_result = yield cmd_dict
    return json_result['appId'] if json_result.get('appId'
        ) is not None else None, json_result['recommendedId'
        ] if json_result.get('recommendedId') is not None else None


def get_app_manifest(manifest_id: typing.Optional[str]=None
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, typing.Tuple[str, typing
    .List[AppManifestError], typing.Optional[str], typing.Optional[
    AppManifestParsedProperties], WebAppManifest]]:
    """Gets the processed manifest for this current document.
  This API always waits for the manifest to be loaded.
  If manifestId is provided, and it does not match the manifest of the
    current document, this API errors out.
  If there is not a loaded page, this API errors out immediately.

:param ...:

:param manifest_id: *(Optional)*


:returns: A tuple with the following items:

    1. **url** - Manifest location.
    2. **errors** - 
    3. **data** - *(Optional)* Manifest content.
    4. **parsed** - *(Optional)* Parsed manifest properties. Deprecated, use manifest instead.
    5. **manifest** -"""
    params_dict: T_JSON_DICT = dict()
    if manifest_id is not None:
        params_dict['manifestId'] = manifest_id
    cmd_dict = {'method': 'Page.getAppManifest', 'params': params_dict}
    json_result = yield cmd_dict
    return json_result['url'], [AppManifestError.from_json(i) for i in
        json_result['errors']], json_result['data'] if json_result.get('data'
        ) is not None else None, AppManifestParsedProperties.from_json(
        json_result['parsed']) if json_result.get('parsed'
        ) is not None else None, WebAppManifest.from_json(json_result[
        'manifest'])


def get_frame_tree() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, FrameTree]:
    """Returns present frame tree structure.


:returns: Present frame tree structure."""
    cmd_dict = {'method': 'Page.getFrameTree'}
    json_result = yield cmd_dict
    return FrameTree.from_json(json_result['frameTree'])


def get_installability_errors() ->typing.Generator[T_JSON_DICT, T_JSON_DICT,
    typing.List[InstallabilityError]]:
    """**EXPERIMENTAL**


:returns:"""
    cmd_dict = {'method': 'Page.getInstallabilityErrors'}
    json_result = yield cmd_dict
    return [InstallabilityError.from_json(i) for i in json_result[
        'installabilityErrors']]


def get_layout_metrics() ->typing.Generator[T_JSON_DICT, T_JSON_DICT,
    typing.Tuple[LayoutViewport, VisualViewport, dom.Rect, LayoutViewport,
    VisualViewport, dom.Rect]]:
    """Returns metrics relating to the layouting of the page, such as viewport bounds/scale.


:returns: A tuple with the following items:

    1. **layoutViewport** - Deprecated metrics relating to the layout viewport. Is in device pixels. Use ``cssLayoutViewport`` instead.
    2. **visualViewport** - Deprecated metrics relating to the visual viewport. Is in device pixels. Use ``cssVisualViewport`` instead.
    3. **contentSize** - Deprecated size of scrollable area. Is in DP. Use ``cssContentSize`` instead.
    4. **cssLayoutViewport** - Metrics relating to the layout viewport in CSS pixels.
    5. **cssVisualViewport** - Metrics relating to the visual viewport in CSS pixels.
    6. **cssContentSize** - Size of scrollable area in CSS pixels."""
    cmd_dict = {'method': 'Page.getLayoutMetrics'}
    json_result = yield cmd_dict
    return LayoutViewport.from_json(json_result['layoutViewport']
        ), VisualViewport.from_json(json_result['visualViewport']
        ), dom.Rect.from_json(json_result['contentSize']
        ), LayoutViewport.from_json(json_result['cssLayoutViewport']
        ), VisualViewport.from_json(json_result['cssVisualViewport']
        ), dom.Rect.from_json(json_result['cssContentSize'])


@deprecated(version='1.3')
def get_manifest_icons() ->typing.Generator[T_JSON_DICT, T_JSON_DICT,
    typing.Optional[str]]:
    """Deprecated because it's not guaranteed that the returned icon is in fact the one used for PWA installation.

.. deprecated:: 1.3

**EXPERIMENTAL**


:returns: *(Optional)*"""
    cmd_dict = {'method': 'Page.getManifestIcons'}
    json_result = yield cmd_dict
    return json_result['primaryIcon'] if json_result.get('primaryIcon'
        ) is not None else None


def get_navigation_history() ->typing.Generator[T_JSON_DICT, T_JSON_DICT,
    typing.Tuple[int, typing.List[NavigationEntry]]]:
    """Returns navigation history for the current page.


:returns: A tuple with the following items:

    1. **currentIndex** - Index of the current navigation history entry.
    2. **entries** - Array of navigation history entries."""
    cmd_dict = {'method': 'Page.getNavigationHistory'}
    json_result = yield cmd_dict
    return json_result['currentIndex'], [NavigationEntry.from_json(i) for i in
        json_result['entries']]


def get_origin_trials(frame_id: FrameId) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, typing.List[OriginTrial]]:
    """Get Origin Trials on given frame.

**EXPERIMENTAL**

:param ...:

:param frame_id:


:returns:"""
    params_dict: T_JSON_DICT = dict()
    params_dict['frameId'] = frame_id.to_json()
    cmd_dict = {'method': 'Page.getOriginTrials', 'params': params_dict}
    json_result = yield cmd_dict
    return [OriginTrial.from_json(i) for i in json_result['originTrials']]


def get_permissions_policy_state(frame_id: FrameId) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, typing.List[PermissionsPolicyFeatureState]]:
    """Get Permissions Policy state on given frame.

**EXPERIMENTAL**

:param ...:

:param frame_id:


:returns:"""
    params_dict: T_JSON_DICT = dict()
    params_dict['frameId'] = frame_id.to_json()
    cmd_dict = {'method': 'Page.getPermissionsPolicyState', 'params':
        params_dict}
    json_result = yield cmd_dict
    return [PermissionsPolicyFeatureState.from_json(i) for i in json_result
        ['states']]


def get_resource_content(frame_id: FrameId, url: str) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, typing.Tuple[str, bool]]:
    """Returns content of the given resource.

**EXPERIMENTAL**

:param ...:

:param frame_id: Frame id to get resource for.

:param url: URL of the resource to get content for.


:returns: A tuple with the following items:

    1. **content** - Resource content.
    2. **base64Encoded** - True, if content was served as base64."""
    params_dict: T_JSON_DICT = dict()
    params_dict['frameId'] = frame_id.to_json()
    params_dict['url'] = url
    cmd_dict = {'method': 'Page.getResourceContent', 'params': params_dict}
    json_result = yield cmd_dict
    return json_result['content'], json_result['base64Encoded']


def get_resource_tree() ->typing.Generator[T_JSON_DICT, T_JSON_DICT,
    FrameResourceTree]:
    """Returns present frame / resource tree structure.

**EXPERIMENTAL**


:returns: Present frame / resource tree structure."""
    cmd_dict = {'method': 'Page.getResourceTree'}
    json_result = yield cmd_dict
    return FrameResourceTree.from_json(json_result['frameTree'])


def handle_java_script_dialog(accept: bool, prompt_text: typing.Optional[
    str]=None) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload).

:param ...:

:param accept: Whether to accept or dismiss the dialog.

:param prompt_text: *(Optional)* The text to enter into the dialog prompt before accepting. Used only if this is a prompt dialog."""
    params_dict: T_JSON_DICT = dict()
    params_dict['accept'] = accept
    if prompt_text is not None:
        params_dict['promptText'] = prompt_text
    cmd_dict = {'method': 'Page.handleJavaScriptDialog', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def navigate(url: str, referrer: typing.Optional[str]=None, transition_type:
    typing.Optional[TransitionType]=None, frame_id: typing.Optional[FrameId
    ]=None, referrer_policy: typing.Optional[ReferrerPolicy]=None
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, typing.Tuple[FrameId,
    typing.Optional[network.LoaderId], typing.Optional[str]]]:
    """Navigates current page to the given URL.

:param ...:

:param url: URL to navigate the page to.

:param referrer: *(Optional)* Referrer URL.

:param transition_type: *(Optional)* Intended transition type.

:param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.

:param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.


:returns: A tuple with the following items:

    1. **frameId** - Frame id that has navigated (or failed to navigate)
    2. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
    3. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed."""
    params_dict: T_JSON_DICT = dict()
    params_dict['url'] = url
    if referrer is not None:
        params_dict['referrer'] = referrer
    if transition_type is not None:
        params_dict['transitionType'] = transition_type.to_json()
    if frame_id is not None:
        params_dict['frameId'] = frame_id.to_json()
    if referrer_policy is not None:
        params_dict['referrerPolicy'] = referrer_policy.to_json()
    cmd_dict = {'method': 'Page.navigate', 'params': params_dict}
    json_result = yield cmd_dict
    return FrameId.from_json(json_result['frameId']
        ), network.LoaderId.from_json(json_result['loaderId']
        ) if json_result.get('loaderId') is not None else None, json_result[
        'errorText'] if json_result.get('errorText') is not None else None


def navigate_to_history_entry(entry_id: int) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, None]:
    """Navigates current page to the given history entry.

:param ...:

:param entry_id: Unique id of the entry to navigate to."""
    params_dict: T_JSON_DICT = dict()
    params_dict['entryId'] = entry_id
    cmd_dict = {'method': 'Page.navigateToHistoryEntry', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def print_to_pdf(landscape: typing.Optional[bool]=None,
    display_header_footer: typing.Optional[bool]=None, print_background:
    typing.Optional[bool]=None, scale: typing.Optional[float]=None,
    paper_width: typing.Optional[float]=None, paper_height: typing.Optional
    [float]=None, margin_top: typing.Optional[float]=None, margin_bottom:
    typing.Optional[float]=None, margin_left: typing.Optional[float]=None,
    margin_right: typing.Optional[float]=None, page_ranges: typing.Optional
    [str]=None, header_template: typing.Optional[str]=None, footer_template:
    typing.Optional[str]=None, prefer_css_page_size: typing.Optional[bool]=
    None, transfer_mode: typing.Optional[str]=None, generate_tagged_pdf:
    typing.Optional[bool]=None, generate_document_outline: typing.Optional[
    bool]=None) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, typing.Tuple[
    str, typing.Optional[io.StreamHandle]]]:
    """Print page as PDF.

:param ...:

:param landscape: *(Optional)* Paper orientation. Defaults to false.

:param display_header_footer: *(Optional)* Display header and footer. Defaults to false.

:param print_background: *(Optional)* Print background graphics. Defaults to false.

:param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.

:param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.

:param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.

:param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).

:param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).

:param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).

:param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).

:param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.

:param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ``date``: formatted print date - ``title``: document title - ``url``: document location - ``pageNumber``: current page number - ``totalPages``: total pages in the document  For example, ``<span class=title></span>`` would generate span containing the title.

:param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ``headerTemplate``.

:param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.

:param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream

:param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.

:param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.


:returns: A tuple with the following items:

    1. **data** - Base64-encoded pdf data. Empty if |returnAsStream| is specified. (Encoded as a base64 string when passed over JSON)
    2. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data."""
    params_dict: T_JSON_DICT = dict()
    if landscape is not None:
        params_dict['landscape'] = landscape
    if display_header_footer is not None:
        params_dict['displayHeaderFooter'] = display_header_footer
    if print_background is not None:
        params_dict['printBackground'] = print_background
    if scale is not None:
        params_dict['scale'] = scale
    if paper_width is not None:
        params_dict['paperWidth'] = paper_width
    if paper_height is not None:
        params_dict['paperHeight'] = paper_height
    if margin_top is not None:
        params_dict['marginTop'] = margin_top
    if margin_bottom is not None:
        params_dict['marginBottom'] = margin_bottom
    if margin_left is not None:
        params_dict['marginLeft'] = margin_left
    if margin_right is not None:
        params_dict['marginRight'] = margin_right
    if page_ranges is not None:
        params_dict['pageRanges'] = page_ranges
    if header_template is not None:
        params_dict['headerTemplate'] = header_template
    if footer_template is not None:
        params_dict['footerTemplate'] = footer_template
    if prefer_css_page_size is not None:
        params_dict['preferCSSPageSize'] = prefer_css_page_size
    if transfer_mode is not None:
        params_dict['transferMode'] = transfer_mode
    if generate_tagged_pdf is not None:
        params_dict['generateTaggedPDF'] = generate_tagged_pdf
    if generate_document_outline is not None:
        params_dict['generateDocumentOutline'] = generate_document_outline
    cmd_dict = {'method': 'Page.printToPDF', 'params': params_dict}
    json_result = yield cmd_dict
    return json_result['data'], io.StreamHandle.from_json(json_result['stream']
        ) if json_result.get('stream') is not None else None


def produce_compilation_cache(scripts: typing.List[CompilationCacheParams]
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Requests backend to produce compilation cache for the specified scripts.
``scripts`` are appended to the list of scripts for which the cache
would be produced. The list may be reset during page navigation.
When script with a matching URL is encountered, the cache is optionally
produced upon backend discretion, based on internal heuristics.
See also: ``Page.compilationCacheProduced``.

**EXPERIMENTAL**

:param ...:

:param scripts:"""
    params_dict: T_JSON_DICT = dict()
    params_dict['scripts'] = [i.to_json() for i in scripts]
    cmd_dict = {'method': 'Page.produceCompilationCache', 'params': params_dict
        }
    json_result = yield cmd_dict
    return None


def reload(ignore_cache: typing.Optional[bool]=None,
    script_to_evaluate_on_load: typing.Optional[str]=None, loader_id:
    typing.Optional[network.LoaderId]=None) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, None]:
    """Reloads given page optionally ignoring the cache.

:param ...:

:param ignore_cache: *(Optional)* If true, browser cache is ignored (as if the user pressed Shift+refresh).

:param script_to_evaluate_on_load: *(Optional)* If set, the script will be injected into all frames of the inspected page after reload. Argument will be ignored if reloading dataURL origin.

:param loader_id: **(EXPERIMENTAL)** *(Optional)* If set, an error will be thrown if the target page's main frame's loader id does not match the provided id. This prevents accidentally reloading an unintended target in case there's a racing navigation."""
    params_dict: T_JSON_DICT = dict()
    if ignore_cache is not None:
        params_dict['ignoreCache'] = ignore_cache
    if script_to_evaluate_on_load is not None:
        params_dict['scriptToEvaluateOnLoad'] = script_to_evaluate_on_load
    if loader_id is not None:
        params_dict['loaderId'] = loader_id.to_json()
    cmd_dict = {'method': 'Page.reload', 'params': params_dict}
    json_result = yield cmd_dict
    return None


@deprecated(version='1.3')
def remove_script_to_evaluate_on_load(identifier: ScriptIdentifier
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Deprecated, please use removeScriptToEvaluateOnNewDocument instead.

.. deprecated:: 1.3

**EXPERIMENTAL**

:param ...:

:param identifier:"""
    params_dict: T_JSON_DICT = dict()
    params_dict['identifier'] = identifier.to_json()
    cmd_dict = {'method': 'Page.removeScriptToEvaluateOnLoad', 'params':
        params_dict}
    json_result = yield cmd_dict
    return None


def remove_script_to_evaluate_on_new_document(identifier: ScriptIdentifier
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Removes given script from the list.

:param ...:

:param identifier:"""
    params_dict: T_JSON_DICT = dict()
    params_dict['identifier'] = identifier.to_json()
    cmd_dict = {'method': 'Page.removeScriptToEvaluateOnNewDocument',
        'params': params_dict}
    json_result = yield cmd_dict
    return None


def reset_navigation_history() ->typing.Generator[T_JSON_DICT, T_JSON_DICT,
    None]:
    """Resets navigation history for the current page."""
    cmd_dict = {'method': 'Page.resetNavigationHistory'}
    json_result = yield cmd_dict
    return None


def screencast_frame_ack(session_id: int) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, None]:
    """Acknowledges that a screencast frame has been received by the frontend.

**EXPERIMENTAL**

:param ...:

:param session_id: Frame number."""
    params_dict: T_JSON_DICT = dict()
    params_dict['sessionId'] = session_id
    cmd_dict = {'method': 'Page.screencastFrameAck', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def search_in_resource(frame_id: FrameId, url: str, query: str,
    case_sensitive: typing.Optional[bool]=None, is_regex: typing.Optional[
    bool]=None) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, typing.List[
    debugger.SearchMatch]]:
    """Searches for given string in resource content.

**EXPERIMENTAL**

:param ...:

:param frame_id: Frame id for resource to search in.

:param url: URL of the resource to search in.

:param query: String to search for.

:param case_sensitive: *(Optional)* If true, search is case sensitive.

:param is_regex: *(Optional)* If true, treats string parameter as regex.


:returns: List of search matches."""
    params_dict: T_JSON_DICT = dict()
    params_dict['frameId'] = frame_id.to_json()
    params_dict['url'] = url
    params_dict['query'] = query
    if case_sensitive is not None:
        params_dict['caseSensitive'] = case_sensitive
    if is_regex is not None:
        params_dict['isRegex'] = is_regex
    cmd_dict = {'method': 'Page.searchInResource', 'params': params_dict}
    json_result = yield cmd_dict
    return [debugger.SearchMatch.from_json(i) for i in json_result['result']]


def set_ad_blocking_enabled(enabled: bool) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, None]:
    """Enable Chrome's experimental ad filter on all sites.

**EXPERIMENTAL**

:param ...:

:param enabled: Whether to block ads."""
    params_dict: T_JSON_DICT = dict()
    params_dict['enabled'] = enabled
    cmd_dict = {'method': 'Page.setAdBlockingEnabled', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def set_bypass_csp(enabled: bool) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, None]:
    """Enable page Content Security Policy by-passing.

:param ...:

:param enabled: Whether to bypass page CSP."""
    params_dict: T_JSON_DICT = dict()
    params_dict['enabled'] = enabled
    cmd_dict = {'method': 'Page.setBypassCSP', 'params': params_dict}
    json_result = yield cmd_dict
    return None


@deprecated(version='1.3')
def set_device_metrics_override(width: int, height: int,
    device_scale_factor: float, mobile: bool, scale: typing.Optional[float]
    =None, screen_width: typing.Optional[int]=None, screen_height: typing.
    Optional[int]=None, position_x: typing.Optional[int]=None, position_y:
    typing.Optional[int]=None, dont_set_visible_size: typing.Optional[bool]
    =None, screen_orientation: typing.Optional[emulation.ScreenOrientation]
    =None, viewport: typing.Optional[Viewport]=None) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, None]:
    """Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
query results).

Redirects to command 'Emulation'.

.. deprecated:: 1.3

**EXPERIMENTAL**

:param ...:

:param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.

:param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.

:param device_scale_factor: Overriding device scale factor value. 0 disables the override.

:param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.

:param scale: *(Optional)* Scale to apply to resulting view image.

:param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).

:param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).

:param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).

:param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).

:param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.

:param screen_orientation: *(Optional)* Screen orientation override.

:param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared."""
    params_dict: T_JSON_DICT = dict()
    params_dict['width'] = width
    params_dict['height'] = height
    params_dict['deviceScaleFactor'] = device_scale_factor
    params_dict['mobile'] = mobile
    if scale is not None:
        params_dict['scale'] = scale
    if screen_width is not None:
        params_dict['screenWidth'] = screen_width
    if screen_height is not None:
        params_dict['screenHeight'] = screen_height
    if position_x is not None:
        params_dict['positionX'] = position_x
    if position_y is not None:
        params_dict['positionY'] = position_y
    if dont_set_visible_size is not None:
        params_dict['dontSetVisibleSize'] = dont_set_visible_size
    if screen_orientation is not None:
        params_dict['screenOrientation'] = screen_orientation.to_json()
    if viewport is not None:
        params_dict['viewport'] = viewport.to_json()
    cmd_dict = {'method': 'Page.setDeviceMetricsOverride', 'params':
        params_dict}
    json_result = yield cmd_dict
    return None


@deprecated(version='1.3')
def set_device_orientation_override(alpha: float, beta: float, gamma: float
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Overrides the Device Orientation.

Redirects to command 'DeviceOrientation'.

.. deprecated:: 1.3

**EXPERIMENTAL**

:param ...:

:param alpha: Mock alpha

:param beta: Mock beta

:param gamma: Mock gamma"""
    params_dict: T_JSON_DICT = dict()
    params_dict['alpha'] = alpha
    params_dict['beta'] = beta
    params_dict['gamma'] = gamma
    cmd_dict = {'method': 'Page.setDeviceOrientationOverride', 'params':
        params_dict}
    json_result = yield cmd_dict
    return None


def set_document_content(frame_id: FrameId, html: str) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, None]:
    """Sets given markup as the document's HTML.

:param ...:

:param frame_id: Frame id to set HTML for.

:param html: HTML content to set."""
    params_dict: T_JSON_DICT = dict()
    params_dict['frameId'] = frame_id.to_json()
    params_dict['html'] = html
    cmd_dict = {'method': 'Page.setDocumentContent', 'params': params_dict}
    json_result = yield cmd_dict
    return None


@deprecated(version='1.3')
def set_download_behavior(behavior: str, download_path: typing.Optional[str
    ]=None) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Set the behavior when downloading a file.

.. deprecated:: 1.3

**EXPERIMENTAL**

:param ...:

:param behavior: Whether to allow all or deny all download requests, or use default Chrome behavior if available (otherwise deny).

:param download_path: *(Optional)* The default path to save downloaded files to. This is required if behavior is set to 'allow'"""
    params_dict: T_JSON_DICT = dict()
    params_dict['behavior'] = behavior
    if download_path is not None:
        params_dict['downloadPath'] = download_path
    cmd_dict = {'method': 'Page.setDownloadBehavior', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def set_font_families(font_families: FontFamilies, for_scripts: typing.
    Optional[typing.List[ScriptFontFamilies]]=None) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, None]:
    """Set generic font families.

**EXPERIMENTAL**

:param ...:

:param font_families: Specifies font families to set. If a font family is not specified, it won't be changed.

:param for_scripts: *(Optional)* Specifies font families to set for individual scripts."""
    params_dict: T_JSON_DICT = dict()
    params_dict['fontFamilies'] = font_families.to_json()
    if for_scripts is not None:
        params_dict['forScripts'] = [i.to_json() for i in for_scripts]
    cmd_dict = {'method': 'Page.setFontFamilies', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def set_font_sizes(font_sizes: FontSizes) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, None]:
    """Set default font sizes.

**EXPERIMENTAL**

:param ...:

:param font_sizes: Specifies font sizes to set. If a font size is not specified, it won't be changed."""
    params_dict: T_JSON_DICT = dict()
    params_dict['fontSizes'] = font_sizes.to_json()
    cmd_dict = {'method': 'Page.setFontSizes', 'params': params_dict}
    json_result = yield cmd_dict
    return None


@deprecated(version='1.3')
def set_geolocation_override(latitude: typing.Optional[float]=None,
    longitude: typing.Optional[float]=None, accuracy: typing.Optional[float
    ]=None) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
unavailable.

Redirects to command 'Emulation'.

.. deprecated:: 1.3

:param ...:

:param latitude: *(Optional)* Mock latitude

:param longitude: *(Optional)* Mock longitude

:param accuracy: *(Optional)* Mock accuracy"""
    params_dict: T_JSON_DICT = dict()
    if latitude is not None:
        params_dict['latitude'] = latitude
    if longitude is not None:
        params_dict['longitude'] = longitude
    if accuracy is not None:
        params_dict['accuracy'] = accuracy
    cmd_dict = {'method': 'Page.setGeolocationOverride', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def set_intercept_file_chooser_dialog(enabled: bool, cancel: typing.
    Optional[bool]=None) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Intercept file chooser requests and transfer control to protocol clients.
When file chooser interception is enabled, native file chooser dialog is not shown.
Instead, a protocol event ``Page.fileChooserOpened`` is emitted.

:param ...:

:param enabled:

:param cancel: **(EXPERIMENTAL)** *(Optional)* If true, cancels the dialog by emitting relevant events (if any) in addition to not showing it if the interception is enabled (default: false)."""
    params_dict: T_JSON_DICT = dict()
    params_dict['enabled'] = enabled
    if cancel is not None:
        params_dict['cancel'] = cancel
    cmd_dict = {'method': 'Page.setInterceptFileChooserDialog', 'params':
        params_dict}
    json_result = yield cmd_dict
    return None


def set_lifecycle_events_enabled(enabled: bool) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, None]:
    """Controls whether page will emit lifecycle events.

:param ...:

:param enabled: If true, starts emitting lifecycle events."""
    params_dict: T_JSON_DICT = dict()
    params_dict['enabled'] = enabled
    cmd_dict = {'method': 'Page.setLifecycleEventsEnabled', 'params':
        params_dict}
    json_result = yield cmd_dict
    return None


def set_prerendering_allowed(is_allowed: bool) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, None]:
    """Enable/disable prerendering manually.

This command is a short-term solution for https://crbug.com/1440085.
See https://docs.google.com/document/d/12HVmFxYj5Jc-eJr5OmWsa2bqTJsbgGLKI6ZIyx0_wpA
for more details.

TODO(https://crbug.com/1440085): Remove this once Puppeteer supports tab targets.

**EXPERIMENTAL**

:param ...:

:param is_allowed:"""
    params_dict: T_JSON_DICT = dict()
    params_dict['isAllowed'] = is_allowed
    cmd_dict = {'method': 'Page.setPrerenderingAllowed', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def set_rph_registration_mode(mode: AutoResponseMode) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, None]:
    """Extensions for Custom Handlers API:
https://html.spec.whatwg.org/multipage/system-state.html#rph-automation

**EXPERIMENTAL**

:param ...:

:param mode:"""
    params_dict: T_JSON_DICT = dict()
    params_dict['mode'] = mode.to_json()
    cmd_dict = {'method': 'Page.setRPHRegistrationMode', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def set_spc_transaction_mode(mode: AutoResponseMode) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, None]:
    """Sets the Secure Payment Confirmation transaction mode.
https://w3c.github.io/secure-payment-confirmation/#sctn-automation-set-spc-transaction-mode

**EXPERIMENTAL**

:param ...:

:param mode:"""
    params_dict: T_JSON_DICT = dict()
    params_dict['mode'] = mode.to_json()
    cmd_dict = {'method': 'Page.setSPCTransactionMode', 'params': params_dict}
    json_result = yield cmd_dict
    return None


@deprecated(version='1.3')
def set_touch_emulation_enabled(enabled: bool, configuration: typing.
    Optional[str]=None) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Toggles mouse event-based touch event emulation.

Redirects to command 'Emulation'.

.. deprecated:: 1.3

**EXPERIMENTAL**

:param ...:

:param enabled: Whether the touch event emulation should be enabled.

:param configuration: *(Optional)* Touch/gesture events configuration. Default: current platform."""
    params_dict: T_JSON_DICT = dict()
    params_dict['enabled'] = enabled
    if configuration is not None:
        params_dict['configuration'] = configuration
    cmd_dict = {'method': 'Page.setTouchEmulationEnabled', 'params':
        params_dict}
    json_result = yield cmd_dict
    return None


def set_web_lifecycle_state(state: str) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, None]:
    """Tries to update the web lifecycle state of the page.
It will transition the page to the given state according to:
https://github.com/WICG/web-lifecycle/

**EXPERIMENTAL**

:param ...:

:param state: Target lifecycle state"""
    params_dict: T_JSON_DICT = dict()
    params_dict['state'] = state
    cmd_dict = {'method': 'Page.setWebLifecycleState', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def start_screencast(format_: typing.Optional[str]=None, quality: typing.
    Optional[int]=None, max_width: typing.Optional[int]=None, max_height:
    typing.Optional[int]=None, every_nth_frame: typing.Optional[int]=None
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Starts sending each frame using the ``screencastFrame`` event.

**EXPERIMENTAL**

:param ...:

:param format_: *(Optional)* Image compression format.

:param quality: *(Optional)* Compression quality from range [0..100].

:param max_width: *(Optional)* Maximum screenshot width.

:param max_height: *(Optional)* Maximum screenshot height.

:param every_nth_frame: *(Optional)* Send every n-th frame."""
    params_dict: T_JSON_DICT = dict()
    if format_ is not None:
        params_dict['format'] = format_
    if quality is not None:
        params_dict['quality'] = quality
    if max_width is not None:
        params_dict['maxWidth'] = max_width
    if max_height is not None:
        params_dict['maxHeight'] = max_height
    if every_nth_frame is not None:
        params_dict['everyNthFrame'] = every_nth_frame
    cmd_dict = {'method': 'Page.startScreencast', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def stop_loading() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Force the page stop all navigations and pending resource fetches."""
    cmd_dict = {'method': 'Page.stopLoading'}
    json_result = yield cmd_dict
    return None


def stop_screencast() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Stops sending each frame in the ``screencastFrame``.

**EXPERIMENTAL**"""
    cmd_dict = {'method': 'Page.stopScreencast'}
    json_result = yield cmd_dict
    return None


def wait_for_debugger() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Pauses page execution. Can be resumed using generic Runtime.runIfWaitingForDebugger.

**EXPERIMENTAL**"""
    cmd_dict = {'method': 'Page.waitForDebugger'}
    json_result = yield cmd_dict
    return None


@event_class('Page.backForwardCacheNotUsed')
@dataclass
class BackForwardCacheNotUsed:
    """**EXPERIMENTAL**

Fired for failed bfcache history navigations if BackForwardCache feature is enabled. Do
not assume any ordering with the Page.frameNavigated event. This event is fired only for
main-frame history navigation where the document changes (non-same-document navigations),
when bfcache navigation fails."""
    loader_id: network.LoaderId
    frame_id: FrameId
    not_restored_explanations: typing.List[
        BackForwardCacheNotRestoredExplanation]
    not_restored_explanations_tree: typing.Optional[
        BackForwardCacheNotRestoredExplanationTree] = None

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->BackForwardCacheNotUsed:
        return cls(loader_id=network.LoaderId.from_json(json_obj['loaderId'
            ]), frame_id=FrameId.from_json(json_obj['frameId']),
            not_restored_explanations=[
            BackForwardCacheNotRestoredExplanation.from_json(i) for i in
            json_obj['notRestoredExplanations']],
            not_restored_explanations_tree=
            BackForwardCacheNotRestoredExplanationTree.from_json(json_obj[
            'notRestoredExplanationsTree']) if json_obj.get(
            'notRestoredExplanationsTree') is not None else None)


@event_class('Page.compilationCacheProduced')
@dataclass
class CompilationCacheProduced:
    """**EXPERIMENTAL**

Issued for every compilation cache generated. Is only available
if Page.setGenerateCompilationCache is enabled."""
    url: str
    data: str

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->CompilationCacheProduced:
        return cls(url=json_obj['url'], data=json_obj['data'])


@event_class('Page.documentOpened')
@dataclass
class DocumentOpened:
    """**EXPERIMENTAL**

Fired when opening document to write to."""
    frame: Frame

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->DocumentOpened:
        return cls(frame=Frame.from_json(json_obj['frame']))


@event_class('Page.domContentEventFired')
@dataclass
class DomContentEventFired:
    timestamp: network.MonotonicTime

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->DomContentEventFired:
        return cls(timestamp=network.MonotonicTime.from_json(json_obj[
            'timestamp']))


@deprecated(version='1.3')
@event_class('Page.downloadProgress')
@dataclass
class DownloadProgress:
    """**EXPERIMENTAL**

Fired when download makes progress. Last call has |done| == true.
Deprecated. Use Browser.downloadProgress instead.

.. deprecated:: 1.3"""
    guid: str
    total_bytes: float
    received_bytes: float
    state: str

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->DownloadProgress:
        return cls(guid=json_obj['guid'], total_bytes=json_obj['totalBytes'
            ], received_bytes=json_obj['receivedBytes'], state=json_obj[
            'state'])


@deprecated(version='1.3')
@event_class('Page.downloadWillBegin')
@dataclass
class DownloadWillBegin:
    """**EXPERIMENTAL**

Fired when page is about to start a download.
Deprecated. Use Browser.downloadWillBegin instead.

.. deprecated:: 1.3"""
    frame_id: FrameId
    guid: str
    url: str
    suggested_filename: str

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->DownloadWillBegin:
        return cls(frame_id=FrameId.from_json(json_obj['frameId']), guid=
            json_obj['guid'], url=json_obj['url'], suggested_filename=
            json_obj['suggestedFilename'])


@event_class('Page.fileChooserOpened')
@dataclass
class FileChooserOpened:
    """Emitted only when ``page.interceptFileChooser`` is enabled."""
    frame_id: FrameId
    mode: str
    backend_node_id: typing.Optional[dom.BackendNodeId] = None

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->FileChooserOpened:
        return cls(frame_id=FrameId.from_json(json_obj['frameId']), mode=
            json_obj['mode'], backend_node_id=dom.BackendNodeId.from_json(
            json_obj['backendNodeId']) if json_obj.get('backendNodeId') is not
            None else None)


@event_class('Page.frameAttached')
@dataclass
class FrameAttached:
    """Fired when frame has been attached to its parent."""
    frame_id: FrameId
    parent_frame_id: FrameId
    stack: typing.Optional[runtime.StackTrace] = None

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->FrameAttached:
        return cls(frame_id=FrameId.from_json(json_obj['frameId']),
            parent_frame_id=FrameId.from_json(json_obj['parentFrameId']),
            stack=runtime.StackTrace.from_json(json_obj['stack']) if 
            json_obj.get('stack') is not None else None)


@deprecated(version='1.3')
@event_class('Page.frameClearedScheduledNavigation')
@dataclass
class FrameClearedScheduledNavigation:
    """Fired when frame no longer has a scheduled navigation.

.. deprecated:: 1.3"""
    frame_id: FrameId

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT
        ) ->FrameClearedScheduledNavigation:
        return cls(frame_id=FrameId.from_json(json_obj['frameId']))


@event_class('Page.frameDetached')
@dataclass
class FrameDetached:
    """Fired when frame has been detached from its parent."""
    frame_id: FrameId
    reason: str

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->FrameDetached:
        return cls(frame_id=FrameId.from_json(json_obj['frameId']), reason=
            json_obj['reason'])


@event_class('Page.frameNavigated')
@dataclass
class FrameNavigated:
    """Fired once navigation of the frame has completed. Frame is now associated with the new loader."""
    frame: Frame
    type_: NavigationType

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->FrameNavigated:
        return cls(frame=Frame.from_json(json_obj['frame']), type_=
            NavigationType.from_json(json_obj['type']))


@event_class('Page.frameRequestedNavigation')
@dataclass
class FrameRequestedNavigation:
    """**EXPERIMENTAL**

Fired when a renderer-initiated navigation is requested.
Navigation may still be cancelled after the event is issued."""
    frame_id: FrameId
    reason: ClientNavigationReason
    url: str
    disposition: ClientNavigationDisposition

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->FrameRequestedNavigation:
        return cls(frame_id=FrameId.from_json(json_obj['frameId']), reason=
            ClientNavigationReason.from_json(json_obj['reason']), url=
            json_obj['url'], disposition=ClientNavigationDisposition.
            from_json(json_obj['disposition']))


@event_class('Page.frameResized')
@dataclass
class FrameResized:
    """**EXPERIMENTAL**"""
    pass

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->FrameResized:
        return cls()


@deprecated(version='1.3')
@event_class('Page.frameScheduledNavigation')
@dataclass
class FrameScheduledNavigation:
    """Fired when frame schedules a potential navigation.

.. deprecated:: 1.3"""
    frame_id: FrameId
    delay: float
    reason: ClientNavigationReason
    url: str

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->FrameScheduledNavigation:
        return cls(frame_id=FrameId.from_json(json_obj['frameId']), delay=
            json_obj['delay'], reason=ClientNavigationReason.from_json(
            json_obj['reason']), url=json_obj['url'])


@event_class('Page.frameStartedLoading')
@dataclass
class FrameStartedLoading:
    """**EXPERIMENTAL**

Fired when frame has started loading."""
    frame_id: FrameId

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->FrameStartedLoading:
        return cls(frame_id=FrameId.from_json(json_obj['frameId']))


@event_class('Page.frameStartedNavigating')
@dataclass
class FrameStartedNavigating:
    """**EXPERIMENTAL**

Fired when a navigation starts. This event is fired for both
renderer-initiated and browser-initiated navigations. For renderer-initiated
navigations, the event is fired after ``frameRequestedNavigation``.
Navigation may still be cancelled after the event is issued. Multiple events
can be fired for a single navigation, for example, when a same-document
navigation becomes a cross-document navigation (such as in the case of a
frameset)."""
    frame_id: FrameId
    url: str
    loader_id: network.LoaderId
    navigation_type: str

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->FrameStartedNavigating:
        return cls(frame_id=FrameId.from_json(json_obj['frameId']), url=
            json_obj['url'], loader_id=network.LoaderId.from_json(json_obj[
            'loaderId']), navigation_type=json_obj['navigationType'])


@event_class('Page.frameStoppedLoading')
@dataclass
class FrameStoppedLoading:
    """**EXPERIMENTAL**

Fired when frame has stopped loading."""
    frame_id: FrameId

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->FrameStoppedLoading:
        return cls(frame_id=FrameId.from_json(json_obj['frameId']))


@event_class('Page.frameSubtreeWillBeDetached')
@dataclass
class FrameSubtreeWillBeDetached:
    """**EXPERIMENTAL**

Fired before frame subtree is detached. Emitted before any frame of the
subtree is actually detached."""
    frame_id: FrameId

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->FrameSubtreeWillBeDetached:
        return cls(frame_id=FrameId.from_json(json_obj['frameId']))


@event_class('Page.interstitialHidden')
@dataclass
class InterstitialHidden:
    """Fired when interstitial page was hidden"""
    pass

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->InterstitialHidden:
        return cls()


@event_class('Page.interstitialShown')
@dataclass
class InterstitialShown:
    """Fired when interstitial page was shown"""
    pass

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->InterstitialShown:
        return cls()


@event_class('Page.javascriptDialogClosed')
@dataclass
class JavascriptDialogClosed:
    """Fired when a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload) has been
closed."""
    result: bool
    user_input: str

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->JavascriptDialogClosed:
        return cls(result=json_obj['result'], user_input=json_obj['userInput'])


@event_class('Page.javascriptDialogOpening')
@dataclass
class JavascriptDialogOpening:
    """Fired when a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload) is about to
open."""
    url: str
    message: str
    type_: DialogType
    has_browser_handler: bool
    default_prompt: typing.Optional[str] = None

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->JavascriptDialogOpening:
        return cls(url=json_obj['url'], message=json_obj['message'], type_=
            DialogType.from_json(json_obj['type']), has_browser_handler=
            json_obj['hasBrowserHandler'], default_prompt=json_obj[
            'defaultPrompt'] if json_obj.get('defaultPrompt') is not None else
            None)


@event_class('Page.lifecycleEvent')
@dataclass
class LifecycleEvent:
    """Fired for lifecycle events (navigation, load, paint, etc) in the current
target (including local frames)."""
    frame_id: FrameId
    loader_id: network.LoaderId
    name: str
    timestamp: network.MonotonicTime

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->LifecycleEvent:
        return cls(frame_id=FrameId.from_json(json_obj['frameId']),
            loader_id=network.LoaderId.from_json(json_obj['loaderId']),
            name=json_obj['name'], timestamp=network.MonotonicTime.
            from_json(json_obj['timestamp']))


@event_class('Page.loadEventFired')
@dataclass
class LoadEventFired:
    timestamp: network.MonotonicTime

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->LoadEventFired:
        return cls(timestamp=network.MonotonicTime.from_json(json_obj[
            'timestamp']))


@event_class('Page.navigatedWithinDocument')
@dataclass
class NavigatedWithinDocument:
    """**EXPERIMENTAL**

Fired when same-document navigation happens, e.g. due to history API usage or anchor navigation."""
    frame_id: FrameId
    url: str
    navigation_type: str

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->NavigatedWithinDocument:
        return cls(frame_id=FrameId.from_json(json_obj['frameId']), url=
            json_obj['url'], navigation_type=json_obj['navigationType'])


@event_class('Page.screencastFrame')
@dataclass
class ScreencastFrame:
    """**EXPERIMENTAL**

Compressed image data requested by the ``startScreencast``."""
    data: str
    metadata: ScreencastFrameMetadata
    session_id: int

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->ScreencastFrame:
        return cls(data=json_obj['data'], metadata=ScreencastFrameMetadata.
            from_json(json_obj['metadata']), session_id=json_obj['sessionId'])


@event_class('Page.screencastVisibilityChanged')
@dataclass
class ScreencastVisibilityChanged:
    """**EXPERIMENTAL**

Fired when the page with currently enabled screencast was shown or hidden ``."""
    visible: bool

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->ScreencastVisibilityChanged:
        return cls(visible=json_obj['visible'])


@event_class('Page.windowOpen')
@dataclass
class WindowOpen:
    """Fired when a new window is going to be opened, via window.open(), link click, form submission,
etc."""
    url: str
    window_name: str
    window_features: typing.List[str]
    user_gesture: bool

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->WindowOpen:
        return cls(url=json_obj['url'], window_name=json_obj['windowName'],
            window_features=[i for i in json_obj['windowFeatures']],
            user_gesture=json_obj['userGesture'])
