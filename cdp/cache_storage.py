# # DO NOT EDIT THIS FILE!
# #
# # This file is generated from the CDP specification using AST. If you need to make
# # changes, edit the generator and regenerate all of the modules.

from __future__ import annotations
"""CDP domain: CacheStorage (experimental)"""
import typing
import enum
from dataclasses import dataclass
from .util import T_JSON_DICT
from . import storage
None


@dataclass
class Cache:
    """Cache identifier."""
    cache_id: CacheId
    security_origin: str
    storage_key: str
    cache_name: str
    storage_bucket: typing.Optional[storage.StorageBucket] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['cacheId'] = self.cache_id.to_json()
        json_data['securityOrigin'] = self.security_origin
        json_data['storageKey'] = self.storage_key
        json_data['cacheName'] = self.cache_name
        if self.storage_bucket is not None:
            json_data['storageBucket'] = self.storage_bucket.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->Cache:
        return cls(cache_id=CacheId.from_json(json_obj['cacheId']),
            security_origin=json_obj['securityOrigin'], storage_key=
            json_obj['storageKey'], cache_name=json_obj['cacheName'],
            storage_bucket=storage.StorageBucket.from_json(json_obj[
            'storageBucket']) if json_obj.get('storageBucket') is not None else
            None)


@dataclass
class CachedResponse:
    """Cached response"""
    body: str

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['body'] = self.body
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->CachedResponse:
        return cls(body=json_obj['body'])


@dataclass
class DataEntry:
    """Data entry."""
    request_url: str
    request_method: str
    request_headers: typing.List[Header]
    response_time: float
    response_status: int
    response_status_text: str
    response_type: CachedResponseType
    response_headers: typing.List[Header]

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['requestURL'] = self.request_url
        json_data['requestMethod'] = self.request_method
        json_data['requestHeaders'] = [i.to_json() for i in self.
            request_headers]
        json_data['responseTime'] = self.response_time
        json_data['responseStatus'] = self.response_status
        json_data['responseStatusText'] = self.response_status_text
        json_data['responseType'] = self.response_type.to_json()
        json_data['responseHeaders'] = [i.to_json() for i in self.
            response_headers]
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->DataEntry:
        return cls(request_url=json_obj['requestURL'], request_method=
            json_obj['requestMethod'], request_headers=[Header.from_json(i) for
            i in json_obj['requestHeaders']], response_time=json_obj[
            'responseTime'], response_status=json_obj['responseStatus'],
            response_status_text=json_obj['responseStatusText'],
            response_type=CachedResponseType.from_json(json_obj[
            'responseType']), response_headers=[Header.from_json(i) for i in
            json_obj['responseHeaders']])


@dataclass
class Header:
    name: str
    value: str

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['name'] = self.name
        json_data['value'] = self.value
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->Header:
        return cls(name=json_obj['name'], value=json_obj['value'])


class CachedResponseType(enum.Enum):
    """type of HTTP response cached"""
    BASIC = 'basic'
    CORS = 'cors'
    DEFAULT = 'default'
    ERROR = 'error'
    OPAQUE_RESPONSE = 'opaqueResponse'
    OPAQUE_REDIRECT = 'opaqueRedirect'

    @classmethod
    def from_json(cls, json: str) ->CachedResponseType:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<CachedResponseType.{}>'.format(self.value)


class CacheId(str):
    """Unique identifier of the Cache object.

Represents the CDP type 'CacheStorage.CacheId'."""

    def to_json(self) ->str:
        return self

    @classmethod
    def from_json(cls, json: str) ->CacheId:
        return cls(json)

    def __repr__(self) ->str:
        return 'CacheId({})'.format(super().__repr__())


def delete_cache(cache_id: CacheId) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, None]:
    """Deletes a cache.

:param ...:

:param cache_id: Id of cache for deletion."""
    params_dict: T_JSON_DICT = dict()
    params_dict['cacheId'] = cache_id.to_json()
    cmd_dict = {'method': 'CacheStorage.deleteCache', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def delete_entry(cache_id: CacheId, request: str) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, None]:
    """Deletes a cache entry.

:param ...:

:param cache_id: Id of cache where the entry will be deleted.

:param request: URL spec of the request."""
    params_dict: T_JSON_DICT = dict()
    params_dict['cacheId'] = cache_id.to_json()
    params_dict['request'] = request
    cmd_dict = {'method': 'CacheStorage.deleteEntry', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def request_cache_names(security_origin: typing.Optional[str]=None,
    storage_key: typing.Optional[str]=None, storage_bucket: typing.Optional
    [storage.StorageBucket]=None) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, typing.List[Cache]]:
    """Requests cache names.

:param ...:

:param security_origin: *(Optional)* At least and at most one of securityOrigin, storageKey, storageBucket must be specified. Security origin.

:param storage_key: *(Optional)* Storage key.

:param storage_bucket: *(Optional)* Storage bucket. If not specified, it uses the default bucket.


:returns: Caches for the security origin."""
    params_dict: T_JSON_DICT = dict()
    if security_origin is not None:
        params_dict['securityOrigin'] = security_origin
    if storage_key is not None:
        params_dict['storageKey'] = storage_key
    if storage_bucket is not None:
        params_dict['storageBucket'] = storage_bucket.to_json()
    cmd_dict = {'method': 'CacheStorage.requestCacheNames', 'params':
        params_dict}
    json_result = yield cmd_dict
    return [Cache.from_json(i) for i in json_result['caches']]


def request_cached_response(cache_id: CacheId, request_url: str,
    request_headers: typing.List[Header]) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, CachedResponse]:
    """Fetches cache entry.

:param ...:

:param cache_id: Id of cache that contains the entry.

:param request_url: URL spec of the request.

:param request_headers: headers of the request.


:returns: Response read from the cache."""
    params_dict: T_JSON_DICT = dict()
    params_dict['cacheId'] = cache_id.to_json()
    params_dict['requestURL'] = request_url
    params_dict['requestHeaders'] = [i.to_json() for i in request_headers]
    cmd_dict = {'method': 'CacheStorage.requestCachedResponse', 'params':
        params_dict}
    json_result = yield cmd_dict
    return CachedResponse.from_json(json_result['response'])


def request_entries(cache_id: CacheId, skip_count: typing.Optional[int]=
    None, page_size: typing.Optional[int]=None, path_filter: typing.
    Optional[str]=None) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, typing
    .Tuple[typing.List[DataEntry], float]]:
    """Requests data from cache.

:param ...:

:param cache_id: ID of cache to get entries from.

:param skip_count: *(Optional)* Number of records to skip.

:param page_size: *(Optional)* Number of records to fetch.

:param path_filter: *(Optional)* If present, only return the entries containing this substring in the path


:returns: A tuple with the following items:

    1. **cacheDataEntries** - Array of object store data entries.
    2. **returnCount** - Count of returned entries from this storage. If pathFilter is empty, it is the count of all entries from this storage."""
    params_dict: T_JSON_DICT = dict()
    params_dict['cacheId'] = cache_id.to_json()
    if skip_count is not None:
        params_dict['skipCount'] = skip_count
    if page_size is not None:
        params_dict['pageSize'] = page_size
    if path_filter is not None:
        params_dict['pathFilter'] = path_filter
    cmd_dict = {'method': 'CacheStorage.requestEntries', 'params': params_dict}
    json_result = yield cmd_dict
    return [DataEntry.from_json(i) for i in json_result['cacheDataEntries']
        ], json_result['returnCount']
