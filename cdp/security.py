# # DO NOT EDIT THIS FILE!
# #
# # This file is generated from the CDP specification using AST. If you need to make
# # changes, edit the generator and regenerate all of the modules.

from __future__ import annotations
"""CDP domain: Security

Security"""
import typing
import enum
from dataclasses import dataclass
from .util import T_JSON_DICT, event_class
from deprecated.sphinx import deprecated
from . import network
None


@dataclass
class CertificateSecurityState:
    """Details about the security state of the page certificate."""
    protocol: str
    key_exchange: str
    cipher: str
    certificate: typing.List[str]
    subject_name: str
    issuer: str
    valid_from: network.TimeSinceEpoch
    valid_to: network.TimeSinceEpoch
    certificate_has_weak_signature: bool
    certificate_has_sha1_signature: bool
    modern_ssl: bool
    obsolete_ssl_protocol: bool
    obsolete_ssl_key_exchange: bool
    obsolete_ssl_cipher: bool
    obsolete_ssl_signature: bool
    key_exchange_group: typing.Optional[str] = None
    mac: typing.Optional[str] = None
    certificate_network_error: typing.Optional[str] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['protocol'] = self.protocol
        json_data['keyExchange'] = self.key_exchange
        json_data['cipher'] = self.cipher
        json_data['certificate'] = [i for i in self.certificate]
        json_data['subjectName'] = self.subject_name
        json_data['issuer'] = self.issuer
        json_data['validFrom'] = self.valid_from.to_json()
        json_data['validTo'] = self.valid_to.to_json()
        json_data['certificateHasWeakSignature'
            ] = self.certificate_has_weak_signature
        json_data['certificateHasSha1Signature'
            ] = self.certificate_has_sha1_signature
        json_data['modernSSL'] = self.modern_ssl
        json_data['obsoleteSslProtocol'] = self.obsolete_ssl_protocol
        json_data['obsoleteSslKeyExchange'] = self.obsolete_ssl_key_exchange
        json_data['obsoleteSslCipher'] = self.obsolete_ssl_cipher
        json_data['obsoleteSslSignature'] = self.obsolete_ssl_signature
        if self.key_exchange_group is not None:
            json_data['keyExchangeGroup'] = self.key_exchange_group
        if self.mac is not None:
            json_data['mac'] = self.mac
        if self.certificate_network_error is not None:
            json_data['certificateNetworkError'
                ] = self.certificate_network_error
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->CertificateSecurityState:
        return cls(protocol=json_obj['protocol'], key_exchange=json_obj[
            'keyExchange'], cipher=json_obj['cipher'], certificate=[i for i in
            json_obj['certificate']], subject_name=json_obj['subjectName'],
            issuer=json_obj['issuer'], valid_from=network.TimeSinceEpoch.
            from_json(json_obj['validFrom']), valid_to=network.
            TimeSinceEpoch.from_json(json_obj['validTo']),
            certificate_has_weak_signature=json_obj[
            'certificateHasWeakSignature'], certificate_has_sha1_signature=
            json_obj['certificateHasSha1Signature'], modern_ssl=json_obj[
            'modernSSL'], obsolete_ssl_protocol=json_obj[
            'obsoleteSslProtocol'], obsolete_ssl_key_exchange=json_obj[
            'obsoleteSslKeyExchange'], obsolete_ssl_cipher=json_obj[
            'obsoleteSslCipher'], obsolete_ssl_signature=json_obj[
            'obsoleteSslSignature'], key_exchange_group=json_obj[
            'keyExchangeGroup'] if json_obj.get('keyExchangeGroup') is not
            None else None, mac=json_obj['mac'] if json_obj.get('mac') is not
            None else None, certificate_network_error=json_obj[
            'certificateNetworkError'] if json_obj.get(
            'certificateNetworkError') is not None else None)


@dataclass
@deprecated(version='1.3')
class InsecureContentStatus:
    """Information about insecure content on the page."""
    ran_mixed_content: bool
    displayed_mixed_content: bool
    contained_mixed_form: bool
    ran_content_with_cert_errors: bool
    displayed_content_with_cert_errors: bool
    ran_insecure_content_style: SecurityState
    displayed_insecure_content_style: SecurityState

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['ranMixedContent'] = self.ran_mixed_content
        json_data['displayedMixedContent'] = self.displayed_mixed_content
        json_data['containedMixedForm'] = self.contained_mixed_form
        json_data['ranContentWithCertErrors'
            ] = self.ran_content_with_cert_errors
        json_data['displayedContentWithCertErrors'
            ] = self.displayed_content_with_cert_errors
        json_data['ranInsecureContentStyle'
            ] = self.ran_insecure_content_style.to_json()
        json_data['displayedInsecureContentStyle'
            ] = self.displayed_insecure_content_style.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->InsecureContentStatus:
        return cls(ran_mixed_content=json_obj['ranMixedContent'],
            displayed_mixed_content=json_obj['displayedMixedContent'],
            contained_mixed_form=json_obj['containedMixedForm'],
            ran_content_with_cert_errors=json_obj[
            'ranContentWithCertErrors'], displayed_content_with_cert_errors
            =json_obj['displayedContentWithCertErrors'],
            ran_insecure_content_style=SecurityState.from_json(json_obj[
            'ranInsecureContentStyle']), displayed_insecure_content_style=
            SecurityState.from_json(json_obj['displayedInsecureContentStyle']))


@dataclass
class SafetyTipInfo:
    safety_tip_status: SafetyTipStatus
    safe_url: typing.Optional[str] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['safetyTipStatus'] = self.safety_tip_status.to_json()
        if self.safe_url is not None:
            json_data['safeUrl'] = self.safe_url
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->SafetyTipInfo:
        return cls(safety_tip_status=SafetyTipStatus.from_json(json_obj[
            'safetyTipStatus']), safe_url=json_obj['safeUrl'] if json_obj.
            get('safeUrl') is not None else None)


@dataclass
class SecurityStateExplanation:
    """An explanation of an factor contributing to the security state."""
    security_state: SecurityState
    title: str
    summary: str
    description: str
    mixed_content_type: MixedContentType
    certificate: typing.List[str]
    recommendations: typing.Optional[typing.List[str]] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['securityState'] = self.security_state.to_json()
        json_data['title'] = self.title
        json_data['summary'] = self.summary
        json_data['description'] = self.description
        json_data['mixedContentType'] = self.mixed_content_type.to_json()
        json_data['certificate'] = [i for i in self.certificate]
        if self.recommendations is not None:
            json_data['recommendations'] = [i for i in self.recommendations]
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->SecurityStateExplanation:
        return cls(security_state=SecurityState.from_json(json_obj[
            'securityState']), title=json_obj['title'], summary=json_obj[
            'summary'], description=json_obj['description'],
            mixed_content_type=MixedContentType.from_json(json_obj[
            'mixedContentType']), certificate=[i for i in json_obj[
            'certificate']], recommendations=[i for i in json_obj[
            'recommendations']] if json_obj.get('recommendations') is not
            None else None)


@dataclass
class VisibleSecurityState:
    """Security state information about the page."""
    security_state: SecurityState
    security_state_issue_ids: typing.List[str]
    certificate_security_state: typing.Optional[CertificateSecurityState
        ] = None
    safety_tip_info: typing.Optional[SafetyTipInfo] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['securityState'] = self.security_state.to_json()
        json_data['securityStateIssueIds'] = [i for i in self.
            security_state_issue_ids]
        if self.certificate_security_state is not None:
            json_data['certificateSecurityState'
                ] = self.certificate_security_state.to_json()
        if self.safety_tip_info is not None:
            json_data['safetyTipInfo'] = self.safety_tip_info.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->VisibleSecurityState:
        return cls(security_state=SecurityState.from_json(json_obj[
            'securityState']), security_state_issue_ids=[i for i in
            json_obj['securityStateIssueIds']], certificate_security_state=
            CertificateSecurityState.from_json(json_obj[
            'certificateSecurityState']) if json_obj.get(
            'certificateSecurityState') is not None else None,
            safety_tip_info=SafetyTipInfo.from_json(json_obj[
            'safetyTipInfo']) if json_obj.get('safetyTipInfo') is not None else
            None)


class CertificateErrorAction(enum.Enum):
    """The action to take when a certificate error occurs. continue will continue processing the
request and cancel will cancel the request."""
    CONTINUE = 'continue'
    CANCEL = 'cancel'

    @classmethod
    def from_json(cls, json: str) ->CertificateErrorAction:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<CertificateErrorAction.{}>'.format(self.value)


class MixedContentType(enum.Enum):
    """A description of mixed content (HTTP resources on HTTPS pages), as defined by
https://www.w3.org/TR/mixed-content/#categories"""
    BLOCKABLE = 'blockable'
    OPTIONALLY_BLOCKABLE = 'optionally-blockable'
    NONE = 'none'

    @classmethod
    def from_json(cls, json: str) ->MixedContentType:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<MixedContentType.{}>'.format(self.value)


class SafetyTipStatus(enum.Enum):
    BAD_REPUTATION = 'badReputation'
    LOOKALIKE = 'lookalike'

    @classmethod
    def from_json(cls, json: str) ->SafetyTipStatus:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<SafetyTipStatus.{}>'.format(self.value)


class SecurityState(enum.Enum):
    """The security level of a page or resource."""
    UNKNOWN = 'unknown'
    NEUTRAL = 'neutral'
    INSECURE = 'insecure'
    SECURE = 'secure'
    INFO = 'info'
    INSECURE_BROKEN = 'insecure-broken'

    @classmethod
    def from_json(cls, json: str) ->SecurityState:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<SecurityState.{}>'.format(self.value)


class CertificateId(int):
    """An internal certificate ID value.

Represents the CDP type 'Security.CertificateId'."""

    def to_json(self) ->int:
        return self

    @classmethod
    def from_json(cls, json: int) ->CertificateId:
        return cls(json)

    def __repr__(self) ->str:
        return 'CertificateId({})'.format(super().__repr__())


def disable() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Disables tracking security state changes."""
    cmd_dict = {'method': 'Security.disable'}
    json_result = yield cmd_dict
    return None


def enable() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Enables tracking security state changes."""
    cmd_dict = {'method': 'Security.enable'}
    json_result = yield cmd_dict
    return None


@deprecated(version='1.3')
def handle_certificate_error(event_id: int, action: CertificateErrorAction
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Handles a certificate error that fired a certificateError event.

.. deprecated:: 1.3

:param ...:

:param event_id: The ID of the event.

:param action: The action to take on the certificate error."""
    params_dict: T_JSON_DICT = dict()
    params_dict['eventId'] = event_id
    params_dict['action'] = action.to_json()
    cmd_dict = {'method': 'Security.handleCertificateError', 'params':
        params_dict}
    json_result = yield cmd_dict
    return None


def set_ignore_certificate_errors(ignore: bool) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, None]:
    """Enable/disable whether all certificate errors should be ignored.

:param ...:

:param ignore: If true, all certificate errors will be ignored."""
    params_dict: T_JSON_DICT = dict()
    params_dict['ignore'] = ignore
    cmd_dict = {'method': 'Security.setIgnoreCertificateErrors', 'params':
        params_dict}
    json_result = yield cmd_dict
    return None


@deprecated(version='1.3')
def set_override_certificate_errors(override: bool) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, None]:
    """Enable/disable overriding certificate errors. If enabled, all certificate error events need to
be handled by the DevTools client and should be answered with ``handleCertificateError`` commands.

.. deprecated:: 1.3

:param ...:

:param override: If true, certificate errors will be overridden."""
    params_dict: T_JSON_DICT = dict()
    params_dict['override'] = override
    cmd_dict = {'method': 'Security.setOverrideCertificateErrors', 'params':
        params_dict}
    json_result = yield cmd_dict
    return None


@deprecated(version='1.3')
@event_class('Security.certificateError')
@dataclass
class CertificateError:
    """There is a certificate error. If overriding certificate errors is enabled, then it should be
handled with the ``handleCertificateError`` command. Note: this event does not fire if the
certificate error has been allowed internally. Only one client per target should override
certificate errors at the same time.

.. deprecated:: 1.3"""
    event_id: int
    error_type: str
    request_url: str

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->CertificateError:
        return cls(event_id=json_obj['eventId'], error_type=json_obj[
            'errorType'], request_url=json_obj['requestURL'])


@deprecated(version='1.3')
@event_class('Security.securityStateChanged')
@dataclass
class SecurityStateChanged:
    """The security state of the page changed. No longer being sent.

.. deprecated:: 1.3"""
    security_state: SecurityState
    scheme_is_cryptographic: bool
    explanations: typing.List[SecurityStateExplanation]
    insecure_content_status: InsecureContentStatus
    summary: typing.Optional[str] = None

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->SecurityStateChanged:
        return cls(security_state=SecurityState.from_json(json_obj[
            'securityState']), scheme_is_cryptographic=json_obj[
            'schemeIsCryptographic'], explanations=[
            SecurityStateExplanation.from_json(i) for i in json_obj[
            'explanations']], insecure_content_status=InsecureContentStatus
            .from_json(json_obj['insecureContentStatus']), summary=json_obj
            ['summary'] if json_obj.get('summary') is not None else None)


@event_class('Security.visibleSecurityStateChanged')
@dataclass
class VisibleSecurityStateChanged:
    """**EXPERIMENTAL**

The security state of the page changed."""
    visible_security_state: VisibleSecurityState

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->VisibleSecurityStateChanged:
        return cls(visible_security_state=VisibleSecurityState.from_json(
            json_obj['visibleSecurityState']))
