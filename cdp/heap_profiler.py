# # DO NOT EDIT THIS FILE!
# #
# # This file is generated from the CDP specification using AST. If you need to make
# # changes, edit the generator and regenerate all of the modules.

from __future__ import annotations
"""CDP domain: HeapProfiler (experimental)"""
import typing
import enum
from dataclasses import dataclass
from .util import T_JSON_DICT, event_class
from . import runtime
None


@dataclass
class SamplingHeapProfile:
    """Sampling profile."""
    head: SamplingHeapProfileNode
    samples: typing.List[SamplingHeapProfileSample]

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['head'] = self.head.to_json()
        json_data['samples'] = [i.to_json() for i in self.samples]
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->SamplingHeapProfile:
        return cls(head=SamplingHeapProfileNode.from_json(json_obj['head']),
            samples=[SamplingHeapProfileSample.from_json(i) for i in
            json_obj['samples']])


@dataclass
class SamplingHeapProfileNode:
    """Sampling Heap Profile node. Holds callsite information, allocation statistics and child nodes."""
    call_frame: runtime.CallFrame
    self_size: float
    id_: int
    children: typing.List[SamplingHeapProfileNode]

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['callFrame'] = self.call_frame.to_json()
        json_data['selfSize'] = self.self_size
        json_data['id'] = self.id_
        json_data['children'] = [i.to_json() for i in self.children]
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->SamplingHeapProfileNode:
        return cls(call_frame=runtime.CallFrame.from_json(json_obj[
            'callFrame']), self_size=json_obj['selfSize'], id_=json_obj[
            'id'], children=[SamplingHeapProfileNode.from_json(i) for i in
            json_obj['children']])


@dataclass
class SamplingHeapProfileSample:
    """A single sample from a sampling profile."""
    size: float
    node_id: int
    ordinal: float

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['size'] = self.size
        json_data['nodeId'] = self.node_id
        json_data['ordinal'] = self.ordinal
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->SamplingHeapProfileSample:
        return cls(size=json_obj['size'], node_id=json_obj['nodeId'],
            ordinal=json_obj['ordinal'])


class HeapSnapshotObjectId(str):
    """Heap snapshot object id.

Represents the CDP type 'HeapProfiler.HeapSnapshotObjectId'."""

    def to_json(self) ->str:
        return self

    @classmethod
    def from_json(cls, json: str) ->HeapSnapshotObjectId:
        return cls(json)

    def __repr__(self) ->str:
        return 'HeapSnapshotObjectId({})'.format(super().__repr__())


def add_inspected_heap_object(heap_object_id: HeapSnapshotObjectId
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Enables console to refer to the node with given id via $x (see Command Line API for more details
$x functions).

:param ...:

:param heap_object_id: Heap snapshot object id to be accessible by means of $x command line API."""
    params_dict: T_JSON_DICT = dict()
    params_dict['heapObjectId'] = heap_object_id.to_json()
    cmd_dict = {'method': 'HeapProfiler.addInspectedHeapObject', 'params':
        params_dict}
    json_result = yield cmd_dict
    return None


def collect_garbage() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    cmd_dict = {'method': 'HeapProfiler.collectGarbage'}
    json_result = yield cmd_dict
    return None


def disable() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    cmd_dict = {'method': 'HeapProfiler.disable'}
    json_result = yield cmd_dict
    return None


def enable() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    cmd_dict = {'method': 'HeapProfiler.enable'}
    json_result = yield cmd_dict
    return None


def get_heap_object_id(object_id: runtime.RemoteObjectId) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, HeapSnapshotObjectId]:
    """:param ...:

:param object_id: Identifier of the object to get heap object id for.


:returns: Id of the heap snapshot object corresponding to the passed remote object id."""
    params_dict: T_JSON_DICT = dict()
    params_dict['objectId'] = object_id.to_json()
    cmd_dict = {'method': 'HeapProfiler.getHeapObjectId', 'params': params_dict
        }
    json_result = yield cmd_dict
    return HeapSnapshotObjectId.from_json(json_result['heapSnapshotObjectId'])


def get_object_by_heap_object_id(object_id: HeapSnapshotObjectId,
    object_group: typing.Optional[str]=None) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, runtime.RemoteObject]:
    """:param ...:

:param object_id:

:param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.


:returns: Evaluation result."""
    params_dict: T_JSON_DICT = dict()
    params_dict['objectId'] = object_id.to_json()
    if object_group is not None:
        params_dict['objectGroup'] = object_group
    cmd_dict = {'method': 'HeapProfiler.getObjectByHeapObjectId', 'params':
        params_dict}
    json_result = yield cmd_dict
    return runtime.RemoteObject.from_json(json_result['result'])


def get_sampling_profile() ->typing.Generator[T_JSON_DICT, T_JSON_DICT,
    SamplingHeapProfile]:
    """:returns: Return the sampling profile being collected."""
    cmd_dict = {'method': 'HeapProfiler.getSamplingProfile'}
    json_result = yield cmd_dict
    return SamplingHeapProfile.from_json(json_result['profile'])


def start_sampling(sampling_interval: typing.Optional[float]=None,
    include_objects_collected_by_major_gc: typing.Optional[bool]=None,
    include_objects_collected_by_minor_gc: typing.Optional[bool]=None
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """:param ...:

:param sampling_interval: *(Optional)* Average sample interval in bytes. Poisson distribution is used for the intervals. The default value is 32768 bytes.

:param include_objects_collected_by_major_gc: *(Optional)* By default, the sampling heap profiler reports only objects which are still alive when the profile is returned via getSamplingProfile or stopSampling, which is useful for determining what functions contribute the most to steady-state memory usage. This flag instructs the sampling heap profiler to also include information about objects discarded by major GC, which will show which functions cause large temporary memory usage or long GC pauses.

:param include_objects_collected_by_minor_gc: *(Optional)* By default, the sampling heap profiler reports only objects which are still alive when the profile is returned via getSamplingProfile or stopSampling, which is useful for determining what functions contribute the most to steady-state memory usage. This flag instructs the sampling heap profiler to also include information about objects discarded by minor GC, which is useful when tuning a latency-sensitive application for minimal GC activity."""
    params_dict: T_JSON_DICT = dict()
    if sampling_interval is not None:
        params_dict['samplingInterval'] = sampling_interval
    if include_objects_collected_by_major_gc is not None:
        params_dict['includeObjectsCollectedByMajorGC'
            ] = include_objects_collected_by_major_gc
    if include_objects_collected_by_minor_gc is not None:
        params_dict['includeObjectsCollectedByMinorGC'
            ] = include_objects_collected_by_minor_gc
    cmd_dict = {'method': 'HeapProfiler.startSampling', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def start_tracking_heap_objects(track_allocations: typing.Optional[bool]=None
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """:param ...:

:param track_allocations: *(Optional)*"""
    params_dict: T_JSON_DICT = dict()
    if track_allocations is not None:
        params_dict['trackAllocations'] = track_allocations
    cmd_dict = {'method': 'HeapProfiler.startTrackingHeapObjects', 'params':
        params_dict}
    json_result = yield cmd_dict
    return None


def stop_sampling() ->typing.Generator[T_JSON_DICT, T_JSON_DICT,
    SamplingHeapProfile]:
    """:returns: Recorded sampling heap profile."""
    cmd_dict = {'method': 'HeapProfiler.stopSampling'}
    json_result = yield cmd_dict
    return SamplingHeapProfile.from_json(json_result['profile'])


def stop_tracking_heap_objects(report_progress: typing.Optional[bool]=None,
    treat_global_objects_as_roots: typing.Optional[bool]=None,
    capture_numeric_value: typing.Optional[bool]=None, expose_internals:
    typing.Optional[bool]=None) ->typing.Generator[T_JSON_DICT, T_JSON_DICT,
    None]:
    """:param ...:

:param report_progress: *(Optional)* If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken when the tracking is stopped.

:param treat_global_objects_as_roots: **(DEPRECATED)** *(Optional)* Deprecated in favor of ``exposeInternals``.

:param capture_numeric_value: *(Optional)* If true, numerical values are included in the snapshot

:param expose_internals: **(EXPERIMENTAL)** *(Optional)* If true, exposes internals of the snapshot."""
    params_dict: T_JSON_DICT = dict()
    if report_progress is not None:
        params_dict['reportProgress'] = report_progress
    if treat_global_objects_as_roots is not None:
        params_dict['treatGlobalObjectsAsRoots'
            ] = treat_global_objects_as_roots
    if capture_numeric_value is not None:
        params_dict['captureNumericValue'] = capture_numeric_value
    if expose_internals is not None:
        params_dict['exposeInternals'] = expose_internals
    cmd_dict = {'method': 'HeapProfiler.stopTrackingHeapObjects', 'params':
        params_dict}
    json_result = yield cmd_dict
    return None


def take_heap_snapshot(report_progress: typing.Optional[bool]=None,
    treat_global_objects_as_roots: typing.Optional[bool]=None,
    capture_numeric_value: typing.Optional[bool]=None, expose_internals:
    typing.Optional[bool]=None) ->typing.Generator[T_JSON_DICT, T_JSON_DICT,
    None]:
    """:param ...:

:param report_progress: *(Optional)* If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken.

:param treat_global_objects_as_roots: **(DEPRECATED)** *(Optional)* If true, a raw snapshot without artificial roots will be generated. Deprecated in favor of ``exposeInternals``.

:param capture_numeric_value: *(Optional)* If true, numerical values are included in the snapshot

:param expose_internals: **(EXPERIMENTAL)** *(Optional)* If true, exposes internals of the snapshot."""
    params_dict: T_JSON_DICT = dict()
    if report_progress is not None:
        params_dict['reportProgress'] = report_progress
    if treat_global_objects_as_roots is not None:
        params_dict['treatGlobalObjectsAsRoots'
            ] = treat_global_objects_as_roots
    if capture_numeric_value is not None:
        params_dict['captureNumericValue'] = capture_numeric_value
    if expose_internals is not None:
        params_dict['exposeInternals'] = expose_internals
    cmd_dict = {'method': 'HeapProfiler.takeHeapSnapshot', 'params':
        params_dict}
    json_result = yield cmd_dict
    return None


@event_class('HeapProfiler.addHeapSnapshotChunk')
@dataclass
class AddHeapSnapshotChunk:
    chunk: str

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->AddHeapSnapshotChunk:
        return cls(chunk=json_obj['chunk'])


@event_class('HeapProfiler.heapStatsUpdate')
@dataclass
class HeapStatsUpdate:
    """If heap objects tracking has been started then backend may send update for one or more fragments"""
    stats_update: typing.List[int]

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->HeapStatsUpdate:
        return cls(stats_update=[i for i in json_obj['statsUpdate']])


@event_class('HeapProfiler.lastSeenObjectId')
@dataclass
class LastSeenObjectId:
    """If heap objects tracking has been started then backend regularly sends a current value for last
seen object id and corresponding timestamp. If the were changes in the heap since last event
then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event."""
    last_seen_object_id: int
    timestamp: float

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->LastSeenObjectId:
        return cls(last_seen_object_id=json_obj['lastSeenObjectId'],
            timestamp=json_obj['timestamp'])


@event_class('HeapProfiler.reportHeapSnapshotProgress')
@dataclass
class ReportHeapSnapshotProgress:
    done: int
    total: int
    finished: typing.Optional[bool] = None

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->ReportHeapSnapshotProgress:
        return cls(done=json_obj['done'], total=json_obj['total'], finished
            =json_obj['finished'] if json_obj.get('finished') is not None else
            None)


@event_class('HeapProfiler.resetProfiles')
@dataclass
class ResetProfiles:
    pass

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->ResetProfiles:
        return cls()
