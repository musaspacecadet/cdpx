# # DO NOT EDIT THIS FILE!
# #
# # This file is generated from the CDP specification using AST. If you need to make
# # changes, edit the generator and regenerate all of the modules.

from __future__ import annotations
"""CDP domain: LayerTree (experimental)"""
import typing
import enum
from dataclasses import dataclass
from .util import T_JSON_DICT, event_class
from . import dom
None


@dataclass
class Layer:
    """Information about a compositing layer."""
    layer_id: LayerId
    offset_x: float
    offset_y: float
    width: float
    height: float
    paint_count: int
    draws_content: bool
    parent_layer_id: typing.Optional[LayerId] = None
    backend_node_id: typing.Optional[dom.BackendNodeId] = None
    transform: typing.Optional[typing.List[float]] = None
    anchor_x: typing.Optional[float] = None
    anchor_y: typing.Optional[float] = None
    anchor_z: typing.Optional[float] = None
    invisible: typing.Optional[bool] = None
    scroll_rects: typing.Optional[typing.List[ScrollRect]] = None
    sticky_position_constraint: typing.Optional[StickyPositionConstraint
        ] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['layerId'] = self.layer_id.to_json()
        json_data['offsetX'] = self.offset_x
        json_data['offsetY'] = self.offset_y
        json_data['width'] = self.width
        json_data['height'] = self.height
        json_data['paintCount'] = self.paint_count
        json_data['drawsContent'] = self.draws_content
        if self.parent_layer_id is not None:
            json_data['parentLayerId'] = self.parent_layer_id.to_json()
        if self.backend_node_id is not None:
            json_data['backendNodeId'] = self.backend_node_id.to_json()
        if self.transform is not None:
            json_data['transform'] = [i for i in self.transform]
        if self.anchor_x is not None:
            json_data['anchorX'] = self.anchor_x
        if self.anchor_y is not None:
            json_data['anchorY'] = self.anchor_y
        if self.anchor_z is not None:
            json_data['anchorZ'] = self.anchor_z
        if self.invisible is not None:
            json_data['invisible'] = self.invisible
        if self.scroll_rects is not None:
            json_data['scrollRects'] = [i.to_json() for i in self.scroll_rects]
        if self.sticky_position_constraint is not None:
            json_data['stickyPositionConstraint'
                ] = self.sticky_position_constraint.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->Layer:
        return cls(layer_id=LayerId.from_json(json_obj['layerId']),
            offset_x=json_obj['offsetX'], offset_y=json_obj['offsetY'],
            width=json_obj['width'], height=json_obj['height'], paint_count
            =json_obj['paintCount'], draws_content=json_obj['drawsContent'],
            parent_layer_id=LayerId.from_json(json_obj['parentLayerId']) if
            json_obj.get('parentLayerId') is not None else None,
            backend_node_id=dom.BackendNodeId.from_json(json_obj[
            'backendNodeId']) if json_obj.get('backendNodeId') is not None else
            None, transform=[i for i in json_obj['transform']] if json_obj.
            get('transform') is not None else None, anchor_x=json_obj[
            'anchorX'] if json_obj.get('anchorX') is not None else None,
            anchor_y=json_obj['anchorY'] if json_obj.get('anchorY') is not
            None else None, anchor_z=json_obj['anchorZ'] if json_obj.get(
            'anchorZ') is not None else None, invisible=json_obj[
            'invisible'] if json_obj.get('invisible') is not None else None,
            scroll_rects=[ScrollRect.from_json(i) for i in json_obj[
            'scrollRects']] if json_obj.get('scrollRects') is not None else
            None, sticky_position_constraint=StickyPositionConstraint.
            from_json(json_obj['stickyPositionConstraint']) if json_obj.get
            ('stickyPositionConstraint') is not None else None)


@dataclass
class PictureTile:
    """Serialized fragment of layer picture along with its offset within the layer."""
    x: float
    y: float
    picture: str

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['x'] = self.x
        json_data['y'] = self.y
        json_data['picture'] = self.picture
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->PictureTile:
        return cls(x=json_obj['x'], y=json_obj['y'], picture=json_obj[
            'picture'])


@dataclass
class ScrollRect:
    """Rectangle where scrolling happens on the main thread."""
    rect: dom.Rect
    type_: str

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['rect'] = self.rect.to_json()
        json_data['type'] = self.type_
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->ScrollRect:
        return cls(rect=dom.Rect.from_json(json_obj['rect']), type_=
            json_obj['type'])


@dataclass
class StickyPositionConstraint:
    """Sticky position constraints."""
    sticky_box_rect: dom.Rect
    containing_block_rect: dom.Rect
    nearest_layer_shifting_sticky_box: typing.Optional[LayerId] = None
    nearest_layer_shifting_containing_block: typing.Optional[LayerId] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['stickyBoxRect'] = self.sticky_box_rect.to_json()
        json_data['containingBlockRect'] = self.containing_block_rect.to_json()
        if self.nearest_layer_shifting_sticky_box is not None:
            json_data['nearestLayerShiftingStickyBox'
                ] = self.nearest_layer_shifting_sticky_box.to_json()
        if self.nearest_layer_shifting_containing_block is not None:
            json_data['nearestLayerShiftingContainingBlock'
                ] = self.nearest_layer_shifting_containing_block.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->StickyPositionConstraint:
        return cls(sticky_box_rect=dom.Rect.from_json(json_obj[
            'stickyBoxRect']), containing_block_rect=dom.Rect.from_json(
            json_obj['containingBlockRect']),
            nearest_layer_shifting_sticky_box=LayerId.from_json(json_obj[
            'nearestLayerShiftingStickyBox']) if json_obj.get(
            'nearestLayerShiftingStickyBox') is not None else None,
            nearest_layer_shifting_containing_block=LayerId.from_json(
            json_obj['nearestLayerShiftingContainingBlock']) if json_obj.
            get('nearestLayerShiftingContainingBlock') is not None else None)


class LayerId(str):
    """Unique Layer identifier.

Represents the CDP type 'LayerTree.LayerId'."""

    def to_json(self) ->str:
        return self

    @classmethod
    def from_json(cls, json: str) ->LayerId:
        return cls(json)

    def __repr__(self) ->str:
        return 'LayerId({})'.format(super().__repr__())


class SnapshotId(str):
    """Unique snapshot identifier.

Represents the CDP type 'LayerTree.SnapshotId'."""

    def to_json(self) ->str:
        return self

    @classmethod
    def from_json(cls, json: str) ->SnapshotId:
        return cls(json)

    def __repr__(self) ->str:
        return 'SnapshotId({})'.format(super().__repr__())


class PaintProfile(list):
    """Array of timings, one per paint step.

Represents the CDP array type 'LayerTree.PaintProfile'."""

    def to_json(self) ->typing.List[float]:
        return self

    @classmethod
    def from_json(cls, json: typing.List[float]) ->PaintProfile:
        return cls(json)

    def __repr__(self) ->str:
        return 'PaintProfile({})'.format(super().__repr__())


def compositing_reasons(layer_id: LayerId) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, typing.Tuple[typing.List[str], typing.List[str]]]:
    """Provides the reasons why the given layer was composited.

:param ...:

:param layer_id: The id of the layer for which we want to get the reasons it was composited.


:returns: A tuple with the following items:

    1. **compositingReasons** - A list of strings specifying reasons for the given layer to become composited.
    2. **compositingReasonIds** - A list of strings specifying reason IDs for the given layer to become composited."""
    params_dict: T_JSON_DICT = dict()
    params_dict['layerId'] = layer_id.to_json()
    cmd_dict = {'method': 'LayerTree.compositingReasons', 'params': params_dict
        }
    json_result = yield cmd_dict
    return [i for i in json_result['compositingReasons']], [i for i in
        json_result['compositingReasonIds']]


def disable() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Disables compositing tree inspection."""
    cmd_dict = {'method': 'LayerTree.disable'}
    json_result = yield cmd_dict
    return None


def enable() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Enables compositing tree inspection."""
    cmd_dict = {'method': 'LayerTree.enable'}
    json_result = yield cmd_dict
    return None


def load_snapshot(tiles: typing.List[PictureTile]) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, SnapshotId]:
    """Returns the snapshot identifier.

:param ...:

:param tiles: An array of tiles composing the snapshot.


:returns: The id of the snapshot."""
    params_dict: T_JSON_DICT = dict()
    params_dict['tiles'] = [i.to_json() for i in tiles]
    cmd_dict = {'method': 'LayerTree.loadSnapshot', 'params': params_dict}
    json_result = yield cmd_dict
    return SnapshotId.from_json(json_result['snapshotId'])


def make_snapshot(layer_id: LayerId) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, SnapshotId]:
    """Returns the layer snapshot identifier.

:param ...:

:param layer_id: The id of the layer.


:returns: The id of the layer snapshot."""
    params_dict: T_JSON_DICT = dict()
    params_dict['layerId'] = layer_id.to_json()
    cmd_dict = {'method': 'LayerTree.makeSnapshot', 'params': params_dict}
    json_result = yield cmd_dict
    return SnapshotId.from_json(json_result['snapshotId'])


def profile_snapshot(snapshot_id: SnapshotId, min_repeat_count: typing.
    Optional[int]=None, min_duration: typing.Optional[float]=None,
    clip_rect: typing.Optional[dom.Rect]=None) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, typing.List[PaintProfile]]:
    """:param ...:

:param snapshot_id: The id of the layer snapshot.

:param min_repeat_count: *(Optional)* The maximum number of times to replay the snapshot (1, if not specified).

:param min_duration: *(Optional)* The minimum duration (in seconds) to replay the snapshot.

:param clip_rect: *(Optional)* The clip rectangle to apply when replaying the snapshot.


:returns: The array of paint profiles, one per run."""
    params_dict: T_JSON_DICT = dict()
    params_dict['snapshotId'] = snapshot_id.to_json()
    if min_repeat_count is not None:
        params_dict['minRepeatCount'] = min_repeat_count
    if min_duration is not None:
        params_dict['minDuration'] = min_duration
    if clip_rect is not None:
        params_dict['clipRect'] = clip_rect.to_json()
    cmd_dict = {'method': 'LayerTree.profileSnapshot', 'params': params_dict}
    json_result = yield cmd_dict
    return [PaintProfile.from_json(i) for i in json_result['timings']]


def release_snapshot(snapshot_id: SnapshotId) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, None]:
    """Releases layer snapshot captured by the back-end.

:param ...:

:param snapshot_id: The id of the layer snapshot."""
    params_dict: T_JSON_DICT = dict()
    params_dict['snapshotId'] = snapshot_id.to_json()
    cmd_dict = {'method': 'LayerTree.releaseSnapshot', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def replay_snapshot(snapshot_id: SnapshotId, from_step: typing.Optional[int
    ]=None, to_step: typing.Optional[int]=None, scale: typing.Optional[
    float]=None) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """Replays the layer snapshot and returns the resulting bitmap.

:param ...:

:param snapshot_id: The id of the layer snapshot.

:param from_step: *(Optional)* The first step to replay from (replay from the very start if not specified).

:param to_step: *(Optional)* The last step to replay to (replay till the end if not specified).

:param scale: *(Optional)* The scale to apply while replaying (defaults to 1).


:returns: A data: URL for resulting image."""
    params_dict: T_JSON_DICT = dict()
    params_dict['snapshotId'] = snapshot_id.to_json()
    if from_step is not None:
        params_dict['fromStep'] = from_step
    if to_step is not None:
        params_dict['toStep'] = to_step
    if scale is not None:
        params_dict['scale'] = scale
    cmd_dict = {'method': 'LayerTree.replaySnapshot', 'params': params_dict}
    json_result = yield cmd_dict
    return json_result['dataURL']


def snapshot_command_log(snapshot_id: SnapshotId) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, typing.List[T_JSON_DICT]]:
    """Replays the layer snapshot and returns canvas log.

:param ...:

:param snapshot_id: The id of the layer snapshot.


:returns: The array of canvas function calls."""
    params_dict: T_JSON_DICT = dict()
    params_dict['snapshotId'] = snapshot_id.to_json()
    cmd_dict = {'method': 'LayerTree.snapshotCommandLog', 'params': params_dict
        }
    json_result = yield cmd_dict
    return [i for i in json_result['commandLog']]


@event_class('LayerTree.layerPainted')
@dataclass
class LayerPainted:
    layer_id: LayerId
    clip: dom.Rect

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->LayerPainted:
        return cls(layer_id=LayerId.from_json(json_obj['layerId']), clip=
            dom.Rect.from_json(json_obj['clip']))


@event_class('LayerTree.layerTreeDidChange')
@dataclass
class LayerTreeDidChange:
    layers: typing.Optional[typing.List[Layer]] = None

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->LayerTreeDidChange:
        return cls(layers=[Layer.from_json(i) for i in json_obj['layers']] if
            json_obj.get('layers') is not None else None)
