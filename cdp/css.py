# # DO NOT EDIT THIS FILE!
# #
# # This file is generated from the CDP specification using AST. If you need to make
# # changes, edit the generator and regenerate all of the modules.

from __future__ import annotations
"""CDP domain: CSS (experimental)

This domain exposes CSS read/write operations. All CSS objects (stylesheets, rules, and styles)
have an associated ``id`` used in subsequent operations on the related object. Each object type has
a specific ``id`` structure, and those are not interchangeable between objects of different types.
CSS objects can be loaded using the ``get*ForNode()`` calls (which accept a DOM node id). A client
can also keep track of stylesheets via the ``styleSheetAdded``/``styleSheetRemoved`` events and
subsequently load the required stylesheet contents using the ``getStyleSheet[Text]()`` methods."""
import typing
import enum
from dataclasses import dataclass
from .util import T_JSON_DICT, event_class
from . import dom
from . import page
None


@dataclass
class CSSAnimationStyle:
    """CSS style coming from animations with the name of the animation."""
    style: CSSStyle
    name: typing.Optional[str] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['style'] = self.style.to_json()
        if self.name is not None:
            json_data['name'] = self.name
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->CSSAnimationStyle:
        return cls(style=CSSStyle.from_json(json_obj['style']), name=
            json_obj['name'] if json_obj.get('name') is not None else None)


@dataclass
class CSSComputedStyleProperty:
    name: str
    value: str

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['name'] = self.name
        json_data['value'] = self.value
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->CSSComputedStyleProperty:
        return cls(name=json_obj['name'], value=json_obj['value'])


@dataclass
class CSSContainerQuery:
    """CSS container query rule descriptor."""
    text: str
    range_: typing.Optional[SourceRange] = None
    style_sheet_id: typing.Optional[StyleSheetId] = None
    name: typing.Optional[str] = None
    physical_axes: typing.Optional[dom.PhysicalAxes] = None
    logical_axes: typing.Optional[dom.LogicalAxes] = None
    queries_scroll_state: typing.Optional[bool] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['text'] = self.text
        if self.range_ is not None:
            json_data['range'] = self.range_.to_json()
        if self.style_sheet_id is not None:
            json_data['styleSheetId'] = self.style_sheet_id.to_json()
        if self.name is not None:
            json_data['name'] = self.name
        if self.physical_axes is not None:
            json_data['physicalAxes'] = self.physical_axes.to_json()
        if self.logical_axes is not None:
            json_data['logicalAxes'] = self.logical_axes.to_json()
        if self.queries_scroll_state is not None:
            json_data['queriesScrollState'] = self.queries_scroll_state
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->CSSContainerQuery:
        return cls(text=json_obj['text'], range_=SourceRange.from_json(
            json_obj['range']) if json_obj.get('range') is not None else
            None, style_sheet_id=StyleSheetId.from_json(json_obj[
            'styleSheetId']) if json_obj.get('styleSheetId') is not None else
            None, name=json_obj['name'] if json_obj.get('name') is not None
             else None, physical_axes=dom.PhysicalAxes.from_json(json_obj[
            'physicalAxes']) if json_obj.get('physicalAxes') is not None else
            None, logical_axes=dom.LogicalAxes.from_json(json_obj[
            'logicalAxes']) if json_obj.get('logicalAxes') is not None else
            None, queries_scroll_state=json_obj['queriesScrollState'] if 
            json_obj.get('queriesScrollState') is not None else None)


@dataclass
class CSSFontPaletteValuesRule:
    """CSS font-palette-values rule representation."""
    origin: StyleSheetOrigin
    font_palette_name: Value
    style: CSSStyle
    style_sheet_id: typing.Optional[StyleSheetId] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['origin'] = self.origin.to_json()
        json_data['fontPaletteName'] = self.font_palette_name.to_json()
        json_data['style'] = self.style.to_json()
        if self.style_sheet_id is not None:
            json_data['styleSheetId'] = self.style_sheet_id.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->CSSFontPaletteValuesRule:
        return cls(origin=StyleSheetOrigin.from_json(json_obj['origin']),
            font_palette_name=Value.from_json(json_obj['fontPaletteName']),
            style=CSSStyle.from_json(json_obj['style']), style_sheet_id=
            StyleSheetId.from_json(json_obj['styleSheetId']) if json_obj.
            get('styleSheetId') is not None else None)


@dataclass
class CSSFunctionConditionNode:
    """CSS function conditional block representation."""
    children: typing.List[CSSFunctionNode]
    condition_text: str
    media: typing.Optional[CSSMedia] = None
    container_queries: typing.Optional[CSSContainerQuery] = None
    supports: typing.Optional[CSSSupports] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['children'] = [i.to_json() for i in self.children]
        json_data['conditionText'] = self.condition_text
        if self.media is not None:
            json_data['media'] = self.media.to_json()
        if self.container_queries is not None:
            json_data['containerQueries'] = self.container_queries.to_json()
        if self.supports is not None:
            json_data['supports'] = self.supports.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->CSSFunctionConditionNode:
        return cls(children=[CSSFunctionNode.from_json(i) for i in json_obj
            ['children']], condition_text=json_obj['conditionText'], media=
            CSSMedia.from_json(json_obj['media']) if json_obj.get('media')
             is not None else None, container_queries=CSSContainerQuery.
            from_json(json_obj['containerQueries']) if json_obj.get(
            'containerQueries') is not None else None, supports=CSSSupports
            .from_json(json_obj['supports']) if json_obj.get('supports') is not
            None else None)


@dataclass
class CSSFunctionNode:
    """Section of the body of a CSS function rule."""
    condition: typing.Optional[CSSFunctionConditionNode] = None
    style: typing.Optional[CSSStyle] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        if self.condition is not None:
            json_data['condition'] = self.condition.to_json()
        if self.style is not None:
            json_data['style'] = self.style.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->CSSFunctionNode:
        return cls(condition=CSSFunctionConditionNode.from_json(json_obj[
            'condition']) if json_obj.get('condition') is not None else
            None, style=CSSStyle.from_json(json_obj['style']) if json_obj.
            get('style') is not None else None)


@dataclass
class CSSFunctionParameter:
    """CSS function argument representation."""
    name: str
    type_: str

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['name'] = self.name
        json_data['type'] = self.type_
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->CSSFunctionParameter:
        return cls(name=json_obj['name'], type_=json_obj['type'])


@dataclass
class CSSFunctionRule:
    """CSS function at-rule representation."""
    name: Value
    origin: StyleSheetOrigin
    parameters: typing.List[CSSFunctionParameter]
    children: typing.List[CSSFunctionNode]
    style_sheet_id: typing.Optional[StyleSheetId] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['name'] = self.name.to_json()
        json_data['origin'] = self.origin.to_json()
        json_data['parameters'] = [i.to_json() for i in self.parameters]
        json_data['children'] = [i.to_json() for i in self.children]
        if self.style_sheet_id is not None:
            json_data['styleSheetId'] = self.style_sheet_id.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->CSSFunctionRule:
        return cls(name=Value.from_json(json_obj['name']), origin=
            StyleSheetOrigin.from_json(json_obj['origin']), parameters=[
            CSSFunctionParameter.from_json(i) for i in json_obj[
            'parameters']], children=[CSSFunctionNode.from_json(i) for i in
            json_obj['children']], style_sheet_id=StyleSheetId.from_json(
            json_obj['styleSheetId']) if json_obj.get('styleSheetId') is not
            None else None)


@dataclass
class CSSKeyframeRule:
    """CSS keyframe rule representation."""
    origin: StyleSheetOrigin
    key_text: Value
    style: CSSStyle
    style_sheet_id: typing.Optional[StyleSheetId] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['origin'] = self.origin.to_json()
        json_data['keyText'] = self.key_text.to_json()
        json_data['style'] = self.style.to_json()
        if self.style_sheet_id is not None:
            json_data['styleSheetId'] = self.style_sheet_id.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->CSSKeyframeRule:
        return cls(origin=StyleSheetOrigin.from_json(json_obj['origin']),
            key_text=Value.from_json(json_obj['keyText']), style=CSSStyle.
            from_json(json_obj['style']), style_sheet_id=StyleSheetId.
            from_json(json_obj['styleSheetId']) if json_obj.get(
            'styleSheetId') is not None else None)


@dataclass
class CSSKeyframesRule:
    """CSS keyframes rule representation."""
    animation_name: Value
    keyframes: typing.List[CSSKeyframeRule]

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['animationName'] = self.animation_name.to_json()
        json_data['keyframes'] = [i.to_json() for i in self.keyframes]
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->CSSKeyframesRule:
        return cls(animation_name=Value.from_json(json_obj['animationName']
            ), keyframes=[CSSKeyframeRule.from_json(i) for i in json_obj[
            'keyframes']])


@dataclass
class CSSLayer:
    """CSS Layer at-rule descriptor."""
    text: str
    range_: typing.Optional[SourceRange] = None
    style_sheet_id: typing.Optional[StyleSheetId] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['text'] = self.text
        if self.range_ is not None:
            json_data['range'] = self.range_.to_json()
        if self.style_sheet_id is not None:
            json_data['styleSheetId'] = self.style_sheet_id.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->CSSLayer:
        return cls(text=json_obj['text'], range_=SourceRange.from_json(
            json_obj['range']) if json_obj.get('range') is not None else
            None, style_sheet_id=StyleSheetId.from_json(json_obj[
            'styleSheetId']) if json_obj.get('styleSheetId') is not None else
            None)


@dataclass
class CSSLayerData:
    """CSS Layer data."""
    name: str
    order: float
    sub_layers: typing.Optional[typing.List[CSSLayerData]] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['name'] = self.name
        json_data['order'] = self.order
        if self.sub_layers is not None:
            json_data['subLayers'] = [i.to_json() for i in self.sub_layers]
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->CSSLayerData:
        return cls(name=json_obj['name'], order=json_obj['order'],
            sub_layers=[CSSLayerData.from_json(i) for i in json_obj[
            'subLayers']] if json_obj.get('subLayers') is not None else None)


@dataclass
class CSSMedia:
    """CSS media rule descriptor."""
    text: str
    source: str
    source_url: typing.Optional[str] = None
    range_: typing.Optional[SourceRange] = None
    style_sheet_id: typing.Optional[StyleSheetId] = None
    media_list: typing.Optional[typing.List[MediaQuery]] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['text'] = self.text
        json_data['source'] = self.source
        if self.source_url is not None:
            json_data['sourceURL'] = self.source_url
        if self.range_ is not None:
            json_data['range'] = self.range_.to_json()
        if self.style_sheet_id is not None:
            json_data['styleSheetId'] = self.style_sheet_id.to_json()
        if self.media_list is not None:
            json_data['mediaList'] = [i.to_json() for i in self.media_list]
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->CSSMedia:
        return cls(text=json_obj['text'], source=json_obj['source'],
            source_url=json_obj['sourceURL'] if json_obj.get('sourceURL')
             is not None else None, range_=SourceRange.from_json(json_obj[
            'range']) if json_obj.get('range') is not None else None,
            style_sheet_id=StyleSheetId.from_json(json_obj['styleSheetId']) if
            json_obj.get('styleSheetId') is not None else None, media_list=
            [MediaQuery.from_json(i) for i in json_obj['mediaList']] if 
            json_obj.get('mediaList') is not None else None)


@dataclass
class CSSPositionTryRule:
    """CSS @position-try rule representation."""
    name: Value
    origin: StyleSheetOrigin
    style: CSSStyle
    active: bool
    style_sheet_id: typing.Optional[StyleSheetId] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['name'] = self.name.to_json()
        json_data['origin'] = self.origin.to_json()
        json_data['style'] = self.style.to_json()
        json_data['active'] = self.active
        if self.style_sheet_id is not None:
            json_data['styleSheetId'] = self.style_sheet_id.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->CSSPositionTryRule:
        return cls(name=Value.from_json(json_obj['name']), origin=
            StyleSheetOrigin.from_json(json_obj['origin']), style=CSSStyle.
            from_json(json_obj['style']), active=json_obj['active'],
            style_sheet_id=StyleSheetId.from_json(json_obj['styleSheetId']) if
            json_obj.get('styleSheetId') is not None else None)


@dataclass
class CSSProperty:
    """CSS property declaration data."""
    name: str
    value: str
    important: typing.Optional[bool] = None
    implicit: typing.Optional[bool] = None
    text: typing.Optional[str] = None
    parsed_ok: typing.Optional[bool] = None
    disabled: typing.Optional[bool] = None
    range_: typing.Optional[SourceRange] = None
    longhand_properties: typing.Optional[typing.List[CSSProperty]] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['name'] = self.name
        json_data['value'] = self.value
        if self.important is not None:
            json_data['important'] = self.important
        if self.implicit is not None:
            json_data['implicit'] = self.implicit
        if self.text is not None:
            json_data['text'] = self.text
        if self.parsed_ok is not None:
            json_data['parsedOk'] = self.parsed_ok
        if self.disabled is not None:
            json_data['disabled'] = self.disabled
        if self.range_ is not None:
            json_data['range'] = self.range_.to_json()
        if self.longhand_properties is not None:
            json_data['longhandProperties'] = [i.to_json() for i in self.
                longhand_properties]
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->CSSProperty:
        return cls(name=json_obj['name'], value=json_obj['value'],
            important=json_obj['important'] if json_obj.get('important') is not
            None else None, implicit=json_obj['implicit'] if json_obj.get(
            'implicit') is not None else None, text=json_obj['text'] if 
            json_obj.get('text') is not None else None, parsed_ok=json_obj[
            'parsedOk'] if json_obj.get('parsedOk') is not None else None,
            disabled=json_obj['disabled'] if json_obj.get('disabled') is not
            None else None, range_=SourceRange.from_json(json_obj['range']) if
            json_obj.get('range') is not None else None,
            longhand_properties=[CSSProperty.from_json(i) for i in json_obj
            ['longhandProperties']] if json_obj.get('longhandProperties')
             is not None else None)


@dataclass
class CSSPropertyRegistration:
    """Representation of a custom property registration through CSS.registerProperty"""
    property_name: str
    inherits: bool
    syntax: str
    initial_value: typing.Optional[Value] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['propertyName'] = self.property_name
        json_data['inherits'] = self.inherits
        json_data['syntax'] = self.syntax
        if self.initial_value is not None:
            json_data['initialValue'] = self.initial_value.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->CSSPropertyRegistration:
        return cls(property_name=json_obj['propertyName'], inherits=
            json_obj['inherits'], syntax=json_obj['syntax'], initial_value=
            Value.from_json(json_obj['initialValue']) if json_obj.get(
            'initialValue') is not None else None)


@dataclass
class CSSPropertyRule:
    """CSS property at-rule representation."""
    origin: StyleSheetOrigin
    property_name: Value
    style: CSSStyle
    style_sheet_id: typing.Optional[StyleSheetId] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['origin'] = self.origin.to_json()
        json_data['propertyName'] = self.property_name.to_json()
        json_data['style'] = self.style.to_json()
        if self.style_sheet_id is not None:
            json_data['styleSheetId'] = self.style_sheet_id.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->CSSPropertyRule:
        return cls(origin=StyleSheetOrigin.from_json(json_obj['origin']),
            property_name=Value.from_json(json_obj['propertyName']), style=
            CSSStyle.from_json(json_obj['style']), style_sheet_id=
            StyleSheetId.from_json(json_obj['styleSheetId']) if json_obj.
            get('styleSheetId') is not None else None)


@dataclass
class CSSRule:
    """CSS rule representation."""
    selector_list: SelectorList
    origin: StyleSheetOrigin
    style: CSSStyle
    style_sheet_id: typing.Optional[StyleSheetId] = None
    nesting_selectors: typing.Optional[typing.List[str]] = None
    media: typing.Optional[typing.List[CSSMedia]] = None
    container_queries: typing.Optional[typing.List[CSSContainerQuery]] = None
    supports: typing.Optional[typing.List[CSSSupports]] = None
    layers: typing.Optional[typing.List[CSSLayer]] = None
    scopes: typing.Optional[typing.List[CSSScope]] = None
    rule_types: typing.Optional[typing.List[CSSRuleType]] = None
    starting_styles: typing.Optional[typing.List[CSSStartingStyle]] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['selectorList'] = self.selector_list.to_json()
        json_data['origin'] = self.origin.to_json()
        json_data['style'] = self.style.to_json()
        if self.style_sheet_id is not None:
            json_data['styleSheetId'] = self.style_sheet_id.to_json()
        if self.nesting_selectors is not None:
            json_data['nestingSelectors'] = [i for i in self.nesting_selectors]
        if self.media is not None:
            json_data['media'] = [i.to_json() for i in self.media]
        if self.container_queries is not None:
            json_data['containerQueries'] = [i.to_json() for i in self.
                container_queries]
        if self.supports is not None:
            json_data['supports'] = [i.to_json() for i in self.supports]
        if self.layers is not None:
            json_data['layers'] = [i.to_json() for i in self.layers]
        if self.scopes is not None:
            json_data['scopes'] = [i.to_json() for i in self.scopes]
        if self.rule_types is not None:
            json_data['ruleTypes'] = [i.to_json() for i in self.rule_types]
        if self.starting_styles is not None:
            json_data['startingStyles'] = [i.to_json() for i in self.
                starting_styles]
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->CSSRule:
        return cls(selector_list=SelectorList.from_json(json_obj[
            'selectorList']), origin=StyleSheetOrigin.from_json(json_obj[
            'origin']), style=CSSStyle.from_json(json_obj['style']),
            style_sheet_id=StyleSheetId.from_json(json_obj['styleSheetId']) if
            json_obj.get('styleSheetId') is not None else None,
            nesting_selectors=[i for i in json_obj['nestingSelectors']] if 
            json_obj.get('nestingSelectors') is not None else None, media=[
            CSSMedia.from_json(i) for i in json_obj['media']] if json_obj.
            get('media') is not None else None, container_queries=[
            CSSContainerQuery.from_json(i) for i in json_obj[
            'containerQueries']] if json_obj.get('containerQueries') is not
            None else None, supports=[CSSSupports.from_json(i) for i in
            json_obj['supports']] if json_obj.get('supports') is not None else
            None, layers=[CSSLayer.from_json(i) for i in json_obj['layers']
            ] if json_obj.get('layers') is not None else None, scopes=[
            CSSScope.from_json(i) for i in json_obj['scopes']] if json_obj.
            get('scopes') is not None else None, rule_types=[CSSRuleType.
            from_json(i) for i in json_obj['ruleTypes']] if json_obj.get(
            'ruleTypes') is not None else None, starting_styles=[
            CSSStartingStyle.from_json(i) for i in json_obj[
            'startingStyles']] if json_obj.get('startingStyles') is not
            None else None)


@dataclass
class CSSScope:
    """CSS Scope at-rule descriptor."""
    text: str
    range_: typing.Optional[SourceRange] = None
    style_sheet_id: typing.Optional[StyleSheetId] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['text'] = self.text
        if self.range_ is not None:
            json_data['range'] = self.range_.to_json()
        if self.style_sheet_id is not None:
            json_data['styleSheetId'] = self.style_sheet_id.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->CSSScope:
        return cls(text=json_obj['text'], range_=SourceRange.from_json(
            json_obj['range']) if json_obj.get('range') is not None else
            None, style_sheet_id=StyleSheetId.from_json(json_obj[
            'styleSheetId']) if json_obj.get('styleSheetId') is not None else
            None)


@dataclass
class CSSStartingStyle:
    """CSS Starting Style at-rule descriptor."""
    range_: typing.Optional[SourceRange] = None
    style_sheet_id: typing.Optional[StyleSheetId] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        if self.range_ is not None:
            json_data['range'] = self.range_.to_json()
        if self.style_sheet_id is not None:
            json_data['styleSheetId'] = self.style_sheet_id.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->CSSStartingStyle:
        return cls(range_=SourceRange.from_json(json_obj['range']) if 
            json_obj.get('range') is not None else None, style_sheet_id=
            StyleSheetId.from_json(json_obj['styleSheetId']) if json_obj.
            get('styleSheetId') is not None else None)


@dataclass
class CSSStyle:
    """CSS style representation."""
    css_properties: typing.List[CSSProperty]
    shorthand_entries: typing.List[ShorthandEntry]
    style_sheet_id: typing.Optional[StyleSheetId] = None
    css_text: typing.Optional[str] = None
    range_: typing.Optional[SourceRange] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['cssProperties'] = [i.to_json() for i in self.css_properties]
        json_data['shorthandEntries'] = [i.to_json() for i in self.
            shorthand_entries]
        if self.style_sheet_id is not None:
            json_data['styleSheetId'] = self.style_sheet_id.to_json()
        if self.css_text is not None:
            json_data['cssText'] = self.css_text
        if self.range_ is not None:
            json_data['range'] = self.range_.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->CSSStyle:
        return cls(css_properties=[CSSProperty.from_json(i) for i in
            json_obj['cssProperties']], shorthand_entries=[ShorthandEntry.
            from_json(i) for i in json_obj['shorthandEntries']],
            style_sheet_id=StyleSheetId.from_json(json_obj['styleSheetId']) if
            json_obj.get('styleSheetId') is not None else None, css_text=
            json_obj['cssText'] if json_obj.get('cssText') is not None else
            None, range_=SourceRange.from_json(json_obj['range']) if 
            json_obj.get('range') is not None else None)


@dataclass
class CSSStyleSheetHeader:
    """CSS stylesheet metainformation."""
    style_sheet_id: StyleSheetId
    frame_id: page.FrameId
    source_url: str
    origin: StyleSheetOrigin
    title: str
    disabled: bool
    is_inline: bool
    is_mutable: bool
    is_constructed: bool
    start_line: float
    start_column: float
    length: float
    end_line: float
    end_column: float
    source_map_url: typing.Optional[str] = None
    owner_node: typing.Optional[dom.BackendNodeId] = None
    has_source_url: typing.Optional[bool] = None
    loading_failed: typing.Optional[bool] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['styleSheetId'] = self.style_sheet_id.to_json()
        json_data['frameId'] = self.frame_id.to_json()
        json_data['sourceURL'] = self.source_url
        json_data['origin'] = self.origin.to_json()
        json_data['title'] = self.title
        json_data['disabled'] = self.disabled
        json_data['isInline'] = self.is_inline
        json_data['isMutable'] = self.is_mutable
        json_data['isConstructed'] = self.is_constructed
        json_data['startLine'] = self.start_line
        json_data['startColumn'] = self.start_column
        json_data['length'] = self.length
        json_data['endLine'] = self.end_line
        json_data['endColumn'] = self.end_column
        if self.source_map_url is not None:
            json_data['sourceMapURL'] = self.source_map_url
        if self.owner_node is not None:
            json_data['ownerNode'] = self.owner_node.to_json()
        if self.has_source_url is not None:
            json_data['hasSourceURL'] = self.has_source_url
        if self.loading_failed is not None:
            json_data['loadingFailed'] = self.loading_failed
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->CSSStyleSheetHeader:
        return cls(style_sheet_id=StyleSheetId.from_json(json_obj[
            'styleSheetId']), frame_id=page.FrameId.from_json(json_obj[
            'frameId']), source_url=json_obj['sourceURL'], origin=
            StyleSheetOrigin.from_json(json_obj['origin']), title=json_obj[
            'title'], disabled=json_obj['disabled'], is_inline=json_obj[
            'isInline'], is_mutable=json_obj['isMutable'], is_constructed=
            json_obj['isConstructed'], start_line=json_obj['startLine'],
            start_column=json_obj['startColumn'], length=json_obj['length'],
            end_line=json_obj['endLine'], end_column=json_obj['endColumn'],
            source_map_url=json_obj['sourceMapURL'] if json_obj.get(
            'sourceMapURL') is not None else None, owner_node=dom.
            BackendNodeId.from_json(json_obj['ownerNode']) if json_obj.get(
            'ownerNode') is not None else None, has_source_url=json_obj[
            'hasSourceURL'] if json_obj.get('hasSourceURL') is not None else
            None, loading_failed=json_obj['loadingFailed'] if json_obj.get(
            'loadingFailed') is not None else None)


@dataclass
class CSSSupports:
    """CSS Supports at-rule descriptor."""
    text: str
    active: bool
    range_: typing.Optional[SourceRange] = None
    style_sheet_id: typing.Optional[StyleSheetId] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['text'] = self.text
        json_data['active'] = self.active
        if self.range_ is not None:
            json_data['range'] = self.range_.to_json()
        if self.style_sheet_id is not None:
            json_data['styleSheetId'] = self.style_sheet_id.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->CSSSupports:
        return cls(text=json_obj['text'], active=json_obj['active'], range_
            =SourceRange.from_json(json_obj['range']) if json_obj.get(
            'range') is not None else None, style_sheet_id=StyleSheetId.
            from_json(json_obj['styleSheetId']) if json_obj.get(
            'styleSheetId') is not None else None)


@dataclass
class CSSTryRule:
    """CSS try rule representation."""
    origin: StyleSheetOrigin
    style: CSSStyle
    style_sheet_id: typing.Optional[StyleSheetId] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['origin'] = self.origin.to_json()
        json_data['style'] = self.style.to_json()
        if self.style_sheet_id is not None:
            json_data['styleSheetId'] = self.style_sheet_id.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->CSSTryRule:
        return cls(origin=StyleSheetOrigin.from_json(json_obj['origin']),
            style=CSSStyle.from_json(json_obj['style']), style_sheet_id=
            StyleSheetId.from_json(json_obj['styleSheetId']) if json_obj.
            get('styleSheetId') is not None else None)


@dataclass
class FontFace:
    """Properties of a web font: https://www.w3.org/TR/2008/REC-CSS2-20080411/fonts.html#font-descriptions
and additional information such as platformFontFamily and fontVariationAxes."""
    font_family: str
    font_style: str
    font_variant: str
    font_weight: str
    font_stretch: str
    font_display: str
    unicode_range: str
    src: str
    platform_font_family: str
    font_variation_axes: typing.Optional[typing.List[FontVariationAxis]] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['fontFamily'] = self.font_family
        json_data['fontStyle'] = self.font_style
        json_data['fontVariant'] = self.font_variant
        json_data['fontWeight'] = self.font_weight
        json_data['fontStretch'] = self.font_stretch
        json_data['fontDisplay'] = self.font_display
        json_data['unicodeRange'] = self.unicode_range
        json_data['src'] = self.src
        json_data['platformFontFamily'] = self.platform_font_family
        if self.font_variation_axes is not None:
            json_data['fontVariationAxes'] = [i.to_json() for i in self.
                font_variation_axes]
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->FontFace:
        return cls(font_family=json_obj['fontFamily'], font_style=json_obj[
            'fontStyle'], font_variant=json_obj['fontVariant'], font_weight
            =json_obj['fontWeight'], font_stretch=json_obj['fontStretch'],
            font_display=json_obj['fontDisplay'], unicode_range=json_obj[
            'unicodeRange'], src=json_obj['src'], platform_font_family=
            json_obj['platformFontFamily'], font_variation_axes=[
            FontVariationAxis.from_json(i) for i in json_obj[
            'fontVariationAxes']] if json_obj.get('fontVariationAxes') is not
            None else None)


@dataclass
class FontVariationAxis:
    """Information about font variation axes for variable fonts"""
    tag: str
    name: str
    min_value: float
    max_value: float
    default_value: float

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['tag'] = self.tag
        json_data['name'] = self.name
        json_data['minValue'] = self.min_value
        json_data['maxValue'] = self.max_value
        json_data['defaultValue'] = self.default_value
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->FontVariationAxis:
        return cls(tag=json_obj['tag'], name=json_obj['name'], min_value=
            json_obj['minValue'], max_value=json_obj['maxValue'],
            default_value=json_obj['defaultValue'])


@dataclass
class InheritedAnimatedStyleEntry:
    """Inherited CSS style collection for animated styles from ancestor node."""
    animation_styles: typing.Optional[typing.List[CSSAnimationStyle]] = None
    transitions_style: typing.Optional[CSSStyle] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        if self.animation_styles is not None:
            json_data['animationStyles'] = [i.to_json() for i in self.
                animation_styles]
        if self.transitions_style is not None:
            json_data['transitionsStyle'] = self.transitions_style.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->InheritedAnimatedStyleEntry:
        return cls(animation_styles=[CSSAnimationStyle.from_json(i) for i in
            json_obj['animationStyles']] if json_obj.get('animationStyles')
             is not None else None, transitions_style=CSSStyle.from_json(
            json_obj['transitionsStyle']) if json_obj.get(
            'transitionsStyle') is not None else None)


@dataclass
class InheritedPseudoElementMatches:
    """Inherited pseudo element matches from pseudos of an ancestor node."""
    pseudo_elements: typing.List[PseudoElementMatches]

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['pseudoElements'] = [i.to_json() for i in self.
            pseudo_elements]
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->InheritedPseudoElementMatches:
        return cls(pseudo_elements=[PseudoElementMatches.from_json(i) for i in
            json_obj['pseudoElements']])


@dataclass
class InheritedStyleEntry:
    """Inherited CSS rule collection from ancestor node."""
    matched_css_rules: typing.List[RuleMatch]
    inline_style: typing.Optional[CSSStyle] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['matchedCSSRules'] = [i.to_json() for i in self.
            matched_css_rules]
        if self.inline_style is not None:
            json_data['inlineStyle'] = self.inline_style.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->InheritedStyleEntry:
        return cls(matched_css_rules=[RuleMatch.from_json(i) for i in
            json_obj['matchedCSSRules']], inline_style=CSSStyle.from_json(
            json_obj['inlineStyle']) if json_obj.get('inlineStyle') is not
            None else None)


@dataclass
class MediaQuery:
    """Media query descriptor."""
    expressions: typing.List[MediaQueryExpression]
    active: bool

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['expressions'] = [i.to_json() for i in self.expressions]
        json_data['active'] = self.active
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->MediaQuery:
        return cls(expressions=[MediaQueryExpression.from_json(i) for i in
            json_obj['expressions']], active=json_obj['active'])


@dataclass
class MediaQueryExpression:
    """Media query expression descriptor."""
    value: float
    unit: str
    feature: str
    value_range: typing.Optional[SourceRange] = None
    computed_length: typing.Optional[float] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['value'] = self.value
        json_data['unit'] = self.unit
        json_data['feature'] = self.feature
        if self.value_range is not None:
            json_data['valueRange'] = self.value_range.to_json()
        if self.computed_length is not None:
            json_data['computedLength'] = self.computed_length
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->MediaQueryExpression:
        return cls(value=json_obj['value'], unit=json_obj['unit'], feature=
            json_obj['feature'], value_range=SourceRange.from_json(json_obj
            ['valueRange']) if json_obj.get('valueRange') is not None else
            None, computed_length=json_obj['computedLength'] if json_obj.
            get('computedLength') is not None else None)


@dataclass
class PlatformFontUsage:
    """Information about amount of glyphs that were rendered with given font."""
    family_name: str
    post_script_name: str
    is_custom_font: bool
    glyph_count: float

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['familyName'] = self.family_name
        json_data['postScriptName'] = self.post_script_name
        json_data['isCustomFont'] = self.is_custom_font
        json_data['glyphCount'] = self.glyph_count
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->PlatformFontUsage:
        return cls(family_name=json_obj['familyName'], post_script_name=
            json_obj['postScriptName'], is_custom_font=json_obj[
            'isCustomFont'], glyph_count=json_obj['glyphCount'])


@dataclass
class PseudoElementMatches:
    """CSS rule collection for a single pseudo style."""
    pseudo_type: dom.PseudoType
    matches: typing.List[RuleMatch]
    pseudo_identifier: typing.Optional[str] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['pseudoType'] = self.pseudo_type.to_json()
        json_data['matches'] = [i.to_json() for i in self.matches]
        if self.pseudo_identifier is not None:
            json_data['pseudoIdentifier'] = self.pseudo_identifier
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->PseudoElementMatches:
        return cls(pseudo_type=dom.PseudoType.from_json(json_obj[
            'pseudoType']), matches=[RuleMatch.from_json(i) for i in
            json_obj['matches']], pseudo_identifier=json_obj[
            'pseudoIdentifier'] if json_obj.get('pseudoIdentifier') is not
            None else None)


@dataclass
class RuleMatch:
    """Match data for a CSS rule."""
    rule: CSSRule
    matching_selectors: typing.List[int]

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['rule'] = self.rule.to_json()
        json_data['matchingSelectors'] = [i for i in self.matching_selectors]
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->RuleMatch:
        return cls(rule=CSSRule.from_json(json_obj['rule']),
            matching_selectors=[i for i in json_obj['matchingSelectors']])


@dataclass
class RuleUsage:
    """CSS coverage information."""
    style_sheet_id: StyleSheetId
    start_offset: float
    end_offset: float
    used: bool

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['styleSheetId'] = self.style_sheet_id.to_json()
        json_data['startOffset'] = self.start_offset
        json_data['endOffset'] = self.end_offset
        json_data['used'] = self.used
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->RuleUsage:
        return cls(style_sheet_id=StyleSheetId.from_json(json_obj[
            'styleSheetId']), start_offset=json_obj['startOffset'],
            end_offset=json_obj['endOffset'], used=json_obj['used'])


@dataclass
class SelectorList:
    """Selector list data."""
    selectors: typing.List[Value]
    text: str

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['selectors'] = [i.to_json() for i in self.selectors]
        json_data['text'] = self.text
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->SelectorList:
        return cls(selectors=[Value.from_json(i) for i in json_obj[
            'selectors']], text=json_obj['text'])


@dataclass
class ShorthandEntry:
    name: str
    value: str
    important: typing.Optional[bool] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['name'] = self.name
        json_data['value'] = self.value
        if self.important is not None:
            json_data['important'] = self.important
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->ShorthandEntry:
        return cls(name=json_obj['name'], value=json_obj['value'],
            important=json_obj['important'] if json_obj.get('important') is not
            None else None)


@dataclass
class SourceRange:
    """Text range within a resource. All numbers are zero-based."""
    start_line: int
    start_column: int
    end_line: int
    end_column: int

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['startLine'] = self.start_line
        json_data['startColumn'] = self.start_column
        json_data['endLine'] = self.end_line
        json_data['endColumn'] = self.end_column
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->SourceRange:
        return cls(start_line=json_obj['startLine'], start_column=json_obj[
            'startColumn'], end_line=json_obj['endLine'], end_column=
            json_obj['endColumn'])


@dataclass
class Specificity:
    """Specificity:
https://drafts.csswg.org/selectors/#specificity-rules"""
    a: int
    b: int
    c: int

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['a'] = self.a
        json_data['b'] = self.b
        json_data['c'] = self.c
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->Specificity:
        return cls(a=json_obj['a'], b=json_obj['b'], c=json_obj['c'])


@dataclass
class StyleDeclarationEdit:
    """A descriptor of operation to mutate style declaration text."""
    style_sheet_id: StyleSheetId
    range_: SourceRange
    text: str

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['styleSheetId'] = self.style_sheet_id.to_json()
        json_data['range'] = self.range_.to_json()
        json_data['text'] = self.text
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->StyleDeclarationEdit:
        return cls(style_sheet_id=StyleSheetId.from_json(json_obj[
            'styleSheetId']), range_=SourceRange.from_json(json_obj['range'
            ]), text=json_obj['text'])


@dataclass
class Value:
    """Data for a simple selector (these are delimited by commas in a selector list)."""
    text: str
    range_: typing.Optional[SourceRange] = None
    specificity: typing.Optional[Specificity] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['text'] = self.text
        if self.range_ is not None:
            json_data['range'] = self.range_.to_json()
        if self.specificity is not None:
            json_data['specificity'] = self.specificity.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->Value:
        return cls(text=json_obj['text'], range_=SourceRange.from_json(
            json_obj['range']) if json_obj.get('range') is not None else
            None, specificity=Specificity.from_json(json_obj['specificity']
            ) if json_obj.get('specificity') is not None else None)


class CSSRuleType(enum.Enum):
    """Enum indicating the type of a CSS rule, used to represent the order of a style rule's ancestors.
This list only contains rule types that are collected during the ancestor rule collection."""
    MEDIA_RULE = 'MediaRule'
    SUPPORTS_RULE = 'SupportsRule'
    CONTAINER_RULE = 'ContainerRule'
    LAYER_RULE = 'LayerRule'
    SCOPE_RULE = 'ScopeRule'
    STYLE_RULE = 'StyleRule'
    STARTING_STYLE_RULE = 'StartingStyleRule'

    @classmethod
    def from_json(cls, json: str) ->CSSRuleType:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<CSSRuleType.{}>'.format(self.value)


class StyleSheetOrigin(enum.Enum):
    """Stylesheet type: "injected" for stylesheets injected via extension, "user-agent" for user-agent
stylesheets, "inspector" for stylesheets created by the inspector (i.e. those holding the "via
inspector" rules), "regular" for regular stylesheets."""
    INJECTED = 'injected'
    USER_AGENT = 'user-agent'
    INSPECTOR = 'inspector'
    REGULAR = 'regular'

    @classmethod
    def from_json(cls, json: str) ->StyleSheetOrigin:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<StyleSheetOrigin.{}>'.format(self.value)


class StyleSheetId(str):
    """Represents the CDP type 'CSS.StyleSheetId'."""

    def to_json(self) ->str:
        return self

    @classmethod
    def from_json(cls, json: str) ->StyleSheetId:
        return cls(json)

    def __repr__(self) ->str:
        return 'StyleSheetId({})'.format(super().__repr__())


def add_rule(style_sheet_id: StyleSheetId, rule_text: str, location:
    SourceRange, node_for_property_syntax_validation: typing.Optional[dom.
    NodeId]=None) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, CSSRule]:
    """Inserts a new rule with the given ``ruleText`` in a stylesheet with given ``styleSheetId``, at the
position specified by ``location``.

:param ...:

:param style_sheet_id: The css style sheet identifier where a new rule should be inserted.

:param rule_text: The text of a new rule.

:param location: Text position of a new rule in the target style sheet.

:param node_for_property_syntax_validation: **(EXPERIMENTAL)** *(Optional)* NodeId for the DOM node in whose context custom property declarations for registered properties should be validated. If omitted, declarations in the new rule text can only be validated statically, which may produce incorrect results if the declaration contains a var() for example.


:returns: The newly created rule."""
    params_dict: T_JSON_DICT = dict()
    params_dict['styleSheetId'] = style_sheet_id.to_json()
    params_dict['ruleText'] = rule_text
    params_dict['location'] = location.to_json()
    if node_for_property_syntax_validation is not None:
        params_dict['nodeForPropertySyntaxValidation'
            ] = node_for_property_syntax_validation.to_json()
    cmd_dict = {'method': 'CSS.addRule', 'params': params_dict}
    json_result = yield cmd_dict
    return CSSRule.from_json(json_result['rule'])


def collect_class_names(style_sheet_id: StyleSheetId) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, typing.List[str]]:
    """Returns all class names from specified stylesheet.

:param ...:

:param style_sheet_id:


:returns: Class name list."""
    params_dict: T_JSON_DICT = dict()
    params_dict['styleSheetId'] = style_sheet_id.to_json()
    cmd_dict = {'method': 'CSS.collectClassNames', 'params': params_dict}
    json_result = yield cmd_dict
    return [i for i in json_result['classNames']]


def create_style_sheet(frame_id: page.FrameId, force: typing.Optional[bool]
    =None) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, StyleSheetId]:
    """Creates a new special "via-inspector" stylesheet in the frame with given ``frameId``.

:param ...:

:param frame_id: Identifier of the frame where "via-inspector" stylesheet should be created.

:param force: *(Optional)* If true, creates a new stylesheet for every call. If false, returns a stylesheet previously created by a call with force=false for the frame's document if it exists or creates a new stylesheet (default: false).


:returns: Identifier of the created "via-inspector" stylesheet."""
    params_dict: T_JSON_DICT = dict()
    params_dict['frameId'] = frame_id.to_json()
    if force is not None:
        params_dict['force'] = force
    cmd_dict = {'method': 'CSS.createStyleSheet', 'params': params_dict}
    json_result = yield cmd_dict
    return StyleSheetId.from_json(json_result['styleSheetId'])


def disable() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Disables the CSS agent for the given page."""
    cmd_dict = {'method': 'CSS.disable'}
    json_result = yield cmd_dict
    return None


def enable() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Enables the CSS agent for the given page. Clients should not assume that the CSS agent has been
enabled until the result of this command is received."""
    cmd_dict = {'method': 'CSS.enable'}
    json_result = yield cmd_dict
    return None


def force_pseudo_state(node_id: dom.NodeId, forced_pseudo_classes: typing.
    List[str]) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Ensures that the given node will have specified pseudo-classes whenever its style is computed by
the browser.

:param ...:

:param node_id: The element id for which to force the pseudo state.

:param forced_pseudo_classes: Element pseudo classes to force when computing the element's style."""
    params_dict: T_JSON_DICT = dict()
    params_dict['nodeId'] = node_id.to_json()
    params_dict['forcedPseudoClasses'] = [i for i in forced_pseudo_classes]
    cmd_dict = {'method': 'CSS.forcePseudoState', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def force_starting_style(node_id: dom.NodeId, forced: bool) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, None]:
    """Ensures that the given node is in its starting-style state.

:param ...:

:param node_id: The element id for which to force the starting-style state.

:param forced: Boolean indicating if this is on or off."""
    params_dict: T_JSON_DICT = dict()
    params_dict['nodeId'] = node_id.to_json()
    params_dict['forced'] = forced
    cmd_dict = {'method': 'CSS.forceStartingStyle', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def get_animated_styles_for_node(node_id: dom.NodeId) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, typing.Tuple[typing.Optional[typing.List[
    CSSAnimationStyle]], typing.Optional[CSSStyle], typing.Optional[typing.
    List[InheritedAnimatedStyleEntry]]]]:
    """Returns the styles coming from animations & transitions
including the animation & transition styles coming from inheritance chain.

**EXPERIMENTAL**

:param ...:

:param node_id:


:returns: A tuple with the following items:

    1. **animationStyles** - *(Optional)* Styles coming from animations.
    2. **transitionsStyle** - *(Optional)* Style coming from transitions.
    3. **inherited** - *(Optional)* Inherited style entries for animationsStyle and transitionsStyle from the inheritance chain of the element."""
    params_dict: T_JSON_DICT = dict()
    params_dict['nodeId'] = node_id.to_json()
    cmd_dict = {'method': 'CSS.getAnimatedStylesForNode', 'params': params_dict
        }
    json_result = yield cmd_dict
    return [CSSAnimationStyle.from_json(i) for i in json_result[
        'animationStyles']] if json_result.get('animationStyles'
        ) is not None else None, CSSStyle.from_json(json_result[
        'transitionsStyle']) if json_result.get('transitionsStyle'
        ) is not None else None, [InheritedAnimatedStyleEntry.from_json(i) for
        i in json_result['inherited']] if json_result.get('inherited'
        ) is not None else None


def get_background_colors(node_id: dom.NodeId) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, typing.Tuple[typing.Optional[typing.List[str]
    ], typing.Optional[str], typing.Optional[str]]]:
    """:param ...:

:param node_id: Id of the node to get background colors for.


:returns: A tuple with the following items:

    1. **backgroundColors** - *(Optional)* The range of background colors behind this element, if it contains any visible text. If no visible text is present, this will be undefined. In the case of a flat background color, this will consist of simply that color. In the case of a gradient, this will consist of each of the color stops. For anything more complicated, this will be an empty array. Images will be ignored (as if the image had failed to load).
    2. **computedFontSize** - *(Optional)* The computed font size for this node, as a CSS computed value string (e.g. '12px').
    3. **computedFontWeight** - *(Optional)* The computed font weight for this node, as a CSS computed value string (e.g. 'normal' or '100')."""
    params_dict: T_JSON_DICT = dict()
    params_dict['nodeId'] = node_id.to_json()
    cmd_dict = {'method': 'CSS.getBackgroundColors', 'params': params_dict}
    json_result = yield cmd_dict
    return [i for i in json_result['backgroundColors']] if json_result.get(
        'backgroundColors') is not None else None, json_result[
        'computedFontSize'] if json_result.get('computedFontSize'
        ) is not None else None, json_result['computedFontWeight'
        ] if json_result.get('computedFontWeight') is not None else None


def get_computed_style_for_node(node_id: dom.NodeId) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, typing.List[CSSComputedStyleProperty]]:
    """Returns the computed style for a DOM node identified by ``nodeId``.

:param ...:

:param node_id:


:returns: Computed style for the specified DOM node."""
    params_dict: T_JSON_DICT = dict()
    params_dict['nodeId'] = node_id.to_json()
    cmd_dict = {'method': 'CSS.getComputedStyleForNode', 'params': params_dict}
    json_result = yield cmd_dict
    return [CSSComputedStyleProperty.from_json(i) for i in json_result[
        'computedStyle']]


def get_inline_styles_for_node(node_id: dom.NodeId) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, typing.Tuple[typing.Optional[CSSStyle],
    typing.Optional[CSSStyle]]]:
    """Returns the styles defined inline (explicitly in the "style" attribute and implicitly, using DOM
attributes) for a DOM node identified by ``nodeId``.

:param ...:

:param node_id:


:returns: A tuple with the following items:

    1. **inlineStyle** - *(Optional)* Inline style for the specified DOM node.
    2. **attributesStyle** - *(Optional)* Attribute-defined element style (e.g. resulting from "width=20 height=100%")."""
    params_dict: T_JSON_DICT = dict()
    params_dict['nodeId'] = node_id.to_json()
    cmd_dict = {'method': 'CSS.getInlineStylesForNode', 'params': params_dict}
    json_result = yield cmd_dict
    return CSSStyle.from_json(json_result['inlineStyle']) if json_result.get(
        'inlineStyle') is not None else None, CSSStyle.from_json(json_result
        ['attributesStyle']) if json_result.get('attributesStyle'
        ) is not None else None


def get_layers_for_node(node_id: dom.NodeId) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, CSSLayerData]:
    """Returns all layers parsed by the rendering engine for the tree scope of a node.
Given a DOM element identified by nodeId, getLayersForNode returns the root
layer for the nearest ancestor document or shadow root. The layer root contains
the full layer tree for the tree scope and their ordering.

**EXPERIMENTAL**

:param ...:

:param node_id:


:returns:"""
    params_dict: T_JSON_DICT = dict()
    params_dict['nodeId'] = node_id.to_json()
    cmd_dict = {'method': 'CSS.getLayersForNode', 'params': params_dict}
    json_result = yield cmd_dict
    return CSSLayerData.from_json(json_result['rootLayer'])


def get_location_for_selector(style_sheet_id: StyleSheetId, selector_text: str
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, typing.List[SourceRange]]:
    """Given a CSS selector text and a style sheet ID, getLocationForSelector
returns an array of locations of the CSS selector in the style sheet.

**EXPERIMENTAL**

:param ...:

:param style_sheet_id:

:param selector_text:


:returns:"""
    params_dict: T_JSON_DICT = dict()
    params_dict['styleSheetId'] = style_sheet_id.to_json()
    params_dict['selectorText'] = selector_text
    cmd_dict = {'method': 'CSS.getLocationForSelector', 'params': params_dict}
    json_result = yield cmd_dict
    return [SourceRange.from_json(i) for i in json_result['ranges']]


def get_longhand_properties(shorthand_name: str, value: str
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, typing.List[CSSProperty]]:
    """**EXPERIMENTAL**


:param ...:

:param shorthand_name:

:param value:


:returns:"""
    params_dict: T_JSON_DICT = dict()
    params_dict['shorthandName'] = shorthand_name
    params_dict['value'] = value
    cmd_dict = {'method': 'CSS.getLonghandProperties', 'params': params_dict}
    json_result = yield cmd_dict
    return [CSSProperty.from_json(i) for i in json_result['longhandProperties']
        ]


def get_matched_styles_for_node(node_id: dom.NodeId) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, typing.Tuple[typing.Optional[CSSStyle],
    typing.Optional[CSSStyle], typing.Optional[typing.List[RuleMatch]],
    typing.Optional[typing.List[PseudoElementMatches]], typing.Optional[
    typing.List[InheritedStyleEntry]], typing.Optional[typing.List[
    InheritedPseudoElementMatches]], typing.Optional[typing.List[
    CSSKeyframesRule]], typing.Optional[typing.List[CSSPositionTryRule]],
    typing.Optional[int], typing.Optional[typing.List[CSSPropertyRule]],
    typing.Optional[typing.List[CSSPropertyRegistration]], typing.Optional[
    CSSFontPaletteValuesRule], typing.Optional[dom.NodeId], typing.Optional
    [typing.List[CSSFunctionRule]]]]:
    """Returns requested styles for a DOM node identified by ``nodeId``.

:param ...:

:param node_id:


:returns: A tuple with the following items:

    1. **inlineStyle** - *(Optional)* Inline style for the specified DOM node.
    2. **attributesStyle** - *(Optional)* Attribute-defined element style (e.g. resulting from "width=20 height=100%").
    3. **matchedCSSRules** - *(Optional)* CSS rules matching this node, from all applicable stylesheets.
    4. **pseudoElements** - *(Optional)* Pseudo style matches for this node.
    5. **inherited** - *(Optional)* A chain of inherited styles (from the immediate node parent up to the DOM tree root).
    6. **inheritedPseudoElements** - *(Optional)* A chain of inherited pseudo element styles (from the immediate node parent up to the DOM tree root).
    7. **cssKeyframesRules** - *(Optional)* A list of CSS keyframed animations matching this node.
    8. **cssPositionTryRules** - *(Optional)* A list of CSS @position-try rules matching this node, based on the position-try-fallbacks property.
    9. **activePositionFallbacTypeex** - *(Optional)* Index of the active fallback in the applied position-try-fallback property, will not be set if there is no active position-try fallback.
    10. **cssPropertyRules** - *(Optional)* A list of CSS at-property rules matching this node.
    11. **cssPropertyRegistrations** - *(Optional)* A list of CSS property registrations matching this node.
    12. **cssFontPaletteValuesRule** - *(Optional)* A font-palette-values rule matching this node.
    13. **parentLayoutNodeId** - *(Optional)* Id of the first parent element that does not have display: contents.
    14. **cssFunctionRules** - *(Optional)* A list of CSS at-function rules referenced by styles of this node."""
    params_dict: T_JSON_DICT = dict()
    params_dict['nodeId'] = node_id.to_json()
    cmd_dict = {'method': 'CSS.getMatchedStylesForNode', 'params': params_dict}
    json_result = yield cmd_dict
    return CSSStyle.from_json(json_result['inlineStyle']) if json_result.get(
        'inlineStyle') is not None else None, CSSStyle.from_json(json_result
        ['attributesStyle']) if json_result.get('attributesStyle'
        ) is not None else None, [RuleMatch.from_json(i) for i in
        json_result['matchedCSSRules']] if json_result.get('matchedCSSRules'
        ) is not None else None, [PseudoElementMatches.from_json(i) for i in
        json_result['pseudoElements']] if json_result.get('pseudoElements'
        ) is not None else None, [InheritedStyleEntry.from_json(i) for i in
        json_result['inherited']] if json_result.get('inherited'
        ) is not None else None, [InheritedPseudoElementMatches.from_json(i
        ) for i in json_result['inheritedPseudoElements']] if json_result.get(
        'inheritedPseudoElements') is not None else None, [CSSKeyframesRule
        .from_json(i) for i in json_result['cssKeyframesRules']
        ] if json_result.get('cssKeyframesRules') is not None else None, [
        CSSPositionTryRule.from_json(i) for i in json_result[
        'cssPositionTryRules']] if json_result.get('cssPositionTryRules'
        ) is not None else None, json_result['activePositionFallbacTypeex'
        ] if json_result.get('activePositionFallbacTypeex'
        ) is not None else None, [CSSPropertyRule.from_json(i) for i in
        json_result['cssPropertyRules']] if json_result.get('cssPropertyRules'
        ) is not None else None, [CSSPropertyRegistration.from_json(i) for
        i in json_result['cssPropertyRegistrations']] if json_result.get(
        'cssPropertyRegistrations'
        ) is not None else None, CSSFontPaletteValuesRule.from_json(json_result
        ['cssFontPaletteValuesRule']) if json_result.get(
        'cssFontPaletteValuesRule'
        ) is not None else None, dom.NodeId.from_json(json_result[
        'parentLayoutNodeId']) if json_result.get('parentLayoutNodeId'
        ) is not None else None, [CSSFunctionRule.from_json(i) for i in
        json_result['cssFunctionRules']] if json_result.get('cssFunctionRules'
        ) is not None else None


def get_media_queries() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, typing
    .List[CSSMedia]]:
    """Returns all media queries parsed by the rendering engine.


:returns:"""
    cmd_dict = {'method': 'CSS.getMediaQueries'}
    json_result = yield cmd_dict
    return [CSSMedia.from_json(i) for i in json_result['medias']]


def get_platform_fonts_for_node(node_id: dom.NodeId) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, typing.List[PlatformFontUsage]]:
    """Requests information about platform fonts which we used to render child TextNodes in the given
node.

:param ...:

:param node_id:


:returns: Usage statistics for every employed platform font."""
    params_dict: T_JSON_DICT = dict()
    params_dict['nodeId'] = node_id.to_json()
    cmd_dict = {'method': 'CSS.getPlatformFontsForNode', 'params': params_dict}
    json_result = yield cmd_dict
    return [PlatformFontUsage.from_json(i) for i in json_result['fonts']]


def get_style_sheet_text(style_sheet_id: StyleSheetId) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, str]:
    """Returns the current textual content for a stylesheet.

:param ...:

:param style_sheet_id:


:returns: The stylesheet text."""
    params_dict: T_JSON_DICT = dict()
    params_dict['styleSheetId'] = style_sheet_id.to_json()
    cmd_dict = {'method': 'CSS.getStyleSheetText', 'params': params_dict}
    json_result = yield cmd_dict
    return json_result['text']


def resolve_values(values: typing.List[str], node_id: dom.NodeId,
    property_name: typing.Optional[str]=None, pseudo_type: typing.Optional[
    dom.PseudoType]=None, pseudo_identifier: typing.Optional[str]=None
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, typing.List[str]]:
    """Resolve the specified values in the context of the provided element.
For example, a value of '1em' is evaluated according to the computed
'font-size' of the element and a value 'calc(1px + 2px)' will be
resolved to '3px'.
If the ``propertyName`` was specified the ``values`` are resolved as if
they were property's declaration. If a value cannot be parsed according
to the provided property syntax, the value is parsed using combined
syntax as if null ``propertyName`` was provided. If the value cannot be
resolved even then, return the provided value without any changes.

**EXPERIMENTAL**

:param ...:

:param values: Substitution functions (var()/env()/attr()) and cascade-dependent keywords (revert/revert-layer) do not work.

:param node_id: Id of the node in whose context the expression is evaluated

:param property_name: *(Optional)* Only longhands and custom property names are accepted.

:param pseudo_type: *(Optional)* Pseudo element type, only works for pseudo elements that generate elements in the tree, such as ::before and ::after.

:param pseudo_identifier: *(Optional)* Pseudo element custom ident.


:returns:"""
    params_dict: T_JSON_DICT = dict()
    params_dict['values'] = [i for i in values]
    params_dict['nodeId'] = node_id.to_json()
    if property_name is not None:
        params_dict['propertyName'] = property_name
    if pseudo_type is not None:
        params_dict['pseudoType'] = pseudo_type.to_json()
    if pseudo_identifier is not None:
        params_dict['pseudoIdentifier'] = pseudo_identifier
    cmd_dict = {'method': 'CSS.resolveValues', 'params': params_dict}
    json_result = yield cmd_dict
    return [i for i in json_result['results']]


def set_container_query_text(style_sheet_id: StyleSheetId, range_:
    SourceRange, text: str) ->typing.Generator[T_JSON_DICT, T_JSON_DICT,
    CSSContainerQuery]:
    """Modifies the expression of a container query.

**EXPERIMENTAL**

:param ...:

:param style_sheet_id:

:param range_:

:param text:


:returns: The resulting CSS container query rule after modification."""
    params_dict: T_JSON_DICT = dict()
    params_dict['styleSheetId'] = style_sheet_id.to_json()
    params_dict['range'] = range_.to_json()
    params_dict['text'] = text
    cmd_dict = {'method': 'CSS.setContainerQueryText', 'params': params_dict}
    json_result = yield cmd_dict
    return CSSContainerQuery.from_json(json_result['containerQuery'])


def set_effective_property_value_for_node(node_id: dom.NodeId,
    property_name: str, value: str) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, None]:
    """Find a rule with the given active property for the given node and set the new value for this
property

:param ...:

:param node_id: The element id for which to set property.

:param property_name:

:param value:"""
    params_dict: T_JSON_DICT = dict()
    params_dict['nodeId'] = node_id.to_json()
    params_dict['propertyName'] = property_name
    params_dict['value'] = value
    cmd_dict = {'method': 'CSS.setEffectivePropertyValueForNode', 'params':
        params_dict}
    json_result = yield cmd_dict
    return None


def set_keyframe_key(style_sheet_id: StyleSheetId, range_: SourceRange,
    key_text: str) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, Value]:
    """Modifies the keyframe rule key text.

:param ...:

:param style_sheet_id:

:param range_:

:param key_text:


:returns: The resulting key text after modification."""
    params_dict: T_JSON_DICT = dict()
    params_dict['styleSheetId'] = style_sheet_id.to_json()
    params_dict['range'] = range_.to_json()
    params_dict['keyText'] = key_text
    cmd_dict = {'method': 'CSS.setKeyframeKey', 'params': params_dict}
    json_result = yield cmd_dict
    return Value.from_json(json_result['keyText'])


def set_local_fonts_enabled(enabled: bool) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, None]:
    """Enables/disables rendering of local CSS fonts (enabled by default).

**EXPERIMENTAL**

:param ...:

:param enabled: Whether rendering of local fonts is enabled."""
    params_dict: T_JSON_DICT = dict()
    params_dict['enabled'] = enabled
    cmd_dict = {'method': 'CSS.setLocalFontsEnabled', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def set_media_text(style_sheet_id: StyleSheetId, range_: SourceRange, text: str
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, CSSMedia]:
    """Modifies the rule selector.

:param ...:

:param style_sheet_id:

:param range_:

:param text:


:returns: The resulting CSS media rule after modification."""
    params_dict: T_JSON_DICT = dict()
    params_dict['styleSheetId'] = style_sheet_id.to_json()
    params_dict['range'] = range_.to_json()
    params_dict['text'] = text
    cmd_dict = {'method': 'CSS.setMediaText', 'params': params_dict}
    json_result = yield cmd_dict
    return CSSMedia.from_json(json_result['media'])


def set_property_rule_property_name(style_sheet_id: StyleSheetId, range_:
    SourceRange, property_name: str) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, Value]:
    """Modifies the property rule property name.

:param ...:

:param style_sheet_id:

:param range_:

:param property_name:


:returns: The resulting key text after modification."""
    params_dict: T_JSON_DICT = dict()
    params_dict['styleSheetId'] = style_sheet_id.to_json()
    params_dict['range'] = range_.to_json()
    params_dict['propertyName'] = property_name
    cmd_dict = {'method': 'CSS.setPropertyRulePropertyName', 'params':
        params_dict}
    json_result = yield cmd_dict
    return Value.from_json(json_result['propertyName'])


def set_rule_selector(style_sheet_id: StyleSheetId, range_: SourceRange,
    selector: str) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, SelectorList]:
    """Modifies the rule selector.

:param ...:

:param style_sheet_id:

:param range_:

:param selector:


:returns: The resulting selector list after modification."""
    params_dict: T_JSON_DICT = dict()
    params_dict['styleSheetId'] = style_sheet_id.to_json()
    params_dict['range'] = range_.to_json()
    params_dict['selector'] = selector
    cmd_dict = {'method': 'CSS.setRuleSelector', 'params': params_dict}
    json_result = yield cmd_dict
    return SelectorList.from_json(json_result['selectorList'])


def set_scope_text(style_sheet_id: StyleSheetId, range_: SourceRange, text: str
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, CSSScope]:
    """Modifies the expression of a scope at-rule.

**EXPERIMENTAL**

:param ...:

:param style_sheet_id:

:param range_:

:param text:


:returns: The resulting CSS Scope rule after modification."""
    params_dict: T_JSON_DICT = dict()
    params_dict['styleSheetId'] = style_sheet_id.to_json()
    params_dict['range'] = range_.to_json()
    params_dict['text'] = text
    cmd_dict = {'method': 'CSS.setScopeText', 'params': params_dict}
    json_result = yield cmd_dict
    return CSSScope.from_json(json_result['scope'])


def set_style_sheet_text(style_sheet_id: StyleSheetId, text: str
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, typing.Optional[str]]:
    """Sets the new stylesheet text.

:param ...:

:param style_sheet_id:

:param text:


:returns: *(Optional)* URL of source map associated with script (if any)."""
    params_dict: T_JSON_DICT = dict()
    params_dict['styleSheetId'] = style_sheet_id.to_json()
    params_dict['text'] = text
    cmd_dict = {'method': 'CSS.setStyleSheetText', 'params': params_dict}
    json_result = yield cmd_dict
    return json_result['sourceMapURL'] if json_result.get('sourceMapURL'
        ) is not None else None


def set_style_texts(edits: typing.List[StyleDeclarationEdit],
    node_for_property_syntax_validation: typing.Optional[dom.NodeId]=None
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, typing.List[CSSStyle]]:
    """Applies specified style edits one after another in the given order.

:param ...:

:param edits:

:param node_for_property_syntax_validation: **(EXPERIMENTAL)** *(Optional)* NodeId for the DOM node in whose context custom property declarations for registered properties should be validated. If omitted, declarations in the new rule text can only be validated statically, which may produce incorrect results if the declaration contains a var() for example.


:returns: The resulting styles after modification."""
    params_dict: T_JSON_DICT = dict()
    params_dict['edits'] = [i.to_json() for i in edits]
    if node_for_property_syntax_validation is not None:
        params_dict['nodeForPropertySyntaxValidation'
            ] = node_for_property_syntax_validation.to_json()
    cmd_dict = {'method': 'CSS.setStyleTexts', 'params': params_dict}
    json_result = yield cmd_dict
    return [CSSStyle.from_json(i) for i in json_result['styles']]


def set_supports_text(style_sheet_id: StyleSheetId, range_: SourceRange,
    text: str) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, CSSSupports]:
    """Modifies the expression of a supports at-rule.

**EXPERIMENTAL**

:param ...:

:param style_sheet_id:

:param range_:

:param text:


:returns: The resulting CSS Supports rule after modification."""
    params_dict: T_JSON_DICT = dict()
    params_dict['styleSheetId'] = style_sheet_id.to_json()
    params_dict['range'] = range_.to_json()
    params_dict['text'] = text
    cmd_dict = {'method': 'CSS.setSupportsText', 'params': params_dict}
    json_result = yield cmd_dict
    return CSSSupports.from_json(json_result['supports'])


def start_rule_usage_tracking() ->typing.Generator[T_JSON_DICT, T_JSON_DICT,
    None]:
    """Enables the selector recording."""
    cmd_dict = {'method': 'CSS.startRuleUsageTracking'}
    json_result = yield cmd_dict
    return None


def stop_rule_usage_tracking() ->typing.Generator[T_JSON_DICT, T_JSON_DICT,
    typing.List[RuleUsage]]:
    """Stop tracking rule usage and return the list of rules that were used since last call to
``takeCoverageDelta`` (or since start of coverage instrumentation).


:returns:"""
    cmd_dict = {'method': 'CSS.stopRuleUsageTracking'}
    json_result = yield cmd_dict
    return [RuleUsage.from_json(i) for i in json_result['ruleUsage']]


def take_computed_style_updates() ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, typing.List[dom.NodeId]]:
    """Polls the next batch of computed style updates.

**EXPERIMENTAL**


:returns: The list of node Ids that have their tracked computed styles updated."""
    cmd_dict = {'method': 'CSS.takeComputedStyleUpdates'}
    json_result = yield cmd_dict
    return [dom.NodeId.from_json(i) for i in json_result['nodeIds']]


def take_coverage_delta() ->typing.Generator[T_JSON_DICT, T_JSON_DICT,
    typing.Tuple[typing.List[RuleUsage], float]]:
    """Obtain list of rules that became used since last call to this method (or since start of coverage
instrumentation).


:returns: A tuple with the following items:

    1. **coverage** - 
    2. **timestamp** - Monotonically increasing time, in seconds."""
    cmd_dict = {'method': 'CSS.takeCoverageDelta'}
    json_result = yield cmd_dict
    return [RuleUsage.from_json(i) for i in json_result['coverage']
        ], json_result['timestamp']


def track_computed_style_updates(properties_to_track: typing.List[
    CSSComputedStyleProperty]) ->typing.Generator[T_JSON_DICT, T_JSON_DICT,
    None]:
    """Starts tracking the given computed styles for updates. The specified array of properties
replaces the one previously specified. Pass empty array to disable tracking.
Use takeComputedStyleUpdates to retrieve the list of nodes that had properties modified.
The changes to computed style properties are only tracked for nodes pushed to the front-end
by the DOM agent. If no changes to the tracked properties occur after the node has been pushed
to the front-end, no updates will be issued for the node.

**EXPERIMENTAL**

:param ...:

:param properties_to_track:"""
    params_dict: T_JSON_DICT = dict()
    params_dict['propertiesToTrack'] = [i.to_json() for i in
        properties_to_track]
    cmd_dict = {'method': 'CSS.trackComputedStyleUpdates', 'params':
        params_dict}
    json_result = yield cmd_dict
    return None


def track_computed_style_updates_for_node(node_id: typing.Optional[dom.
    NodeId]=None) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Starts tracking the given node for the computed style updates
and whenever the computed style is updated for node, it queues
a ``computedStyleUpdated`` event with throttling.
There can only be 1 node tracked for computed style updates
so passing a new node id removes tracking from the previous node.
Pass ``undefined`` to disable tracking.

**EXPERIMENTAL**

:param ...:

:param node_id: *(Optional)*"""
    params_dict: T_JSON_DICT = dict()
    if node_id is not None:
        params_dict['nodeId'] = node_id.to_json()
    cmd_dict = {'method': 'CSS.trackComputedStyleUpdatesForNode', 'params':
        params_dict}
    json_result = yield cmd_dict
    return None


@event_class('CSS.computedStyleUpdated')
@dataclass
class ComputedStyleUpdated:
    """**EXPERIMENTAL**"""
    node_id: dom.NodeId

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->ComputedStyleUpdated:
        return cls(node_id=dom.NodeId.from_json(json_obj['nodeId']))


@event_class('CSS.fontsUpdated')
@dataclass
class FontsUpdated:
    """Fires whenever a web font is updated.  A non-empty font parameter indicates a successfully loaded
web font."""
    font: typing.Optional[FontFace] = None

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->FontsUpdated:
        return cls(font=FontFace.from_json(json_obj['font']) if json_obj.
            get('font') is not None else None)


@event_class('CSS.mediaQueryResultChanged')
@dataclass
class MediaQueryResultChanged:
    """Fires whenever a MediaQuery result changes (for example, after a browser window has been
resized.) The current implementation considers only viewport-dependent media features."""
    pass

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->MediaQueryResultChanged:
        return cls()


@event_class('CSS.styleSheetAdded')
@dataclass
class StyleSheetAdded:
    """Fired whenever an active document stylesheet is added."""
    header: CSSStyleSheetHeader

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->StyleSheetAdded:
        return cls(header=CSSStyleSheetHeader.from_json(json_obj['header']))


@event_class('CSS.styleSheetChanged')
@dataclass
class StyleSheetChanged:
    """Fired whenever a stylesheet is changed as a result of the client operation."""
    style_sheet_id: StyleSheetId

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->StyleSheetChanged:
        return cls(style_sheet_id=StyleSheetId.from_json(json_obj[
            'styleSheetId']))


@event_class('CSS.styleSheetRemoved')
@dataclass
class StyleSheetRemoved:
    """Fired whenever an active document stylesheet is removed."""
    style_sheet_id: StyleSheetId

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->StyleSheetRemoved:
        return cls(style_sheet_id=StyleSheetId.from_json(json_obj[
            'styleSheetId']))
