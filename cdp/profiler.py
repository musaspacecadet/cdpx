# # DO NOT EDIT THIS FILE!
# #
# # This file is generated from the CDP specification using AST. If you need to make
# # changes, edit the generator and regenerate all of the modules.

from __future__ import annotations
"""CDP domain: Profiler"""
import typing
import enum
from dataclasses import dataclass
from .util import T_JSON_DICT, event_class
from . import debugger
from . import runtime
None


@dataclass
class CoverageRange:
    """Coverage data for a source range."""
    start_offset: int
    end_offset: int
    count: int

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['startOffset'] = self.start_offset
        json_data['endOffset'] = self.end_offset
        json_data['count'] = self.count
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->CoverageRange:
        return cls(start_offset=json_obj['startOffset'], end_offset=
            json_obj['endOffset'], count=json_obj['count'])


@dataclass
class FunctionCoverage:
    """Coverage data for a JavaScript function."""
    function_name: str
    ranges: typing.List[CoverageRange]
    is_block_coverage: bool

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['functionName'] = self.function_name
        json_data['ranges'] = [i.to_json() for i in self.ranges]
        json_data['isBlockCoverage'] = self.is_block_coverage
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->FunctionCoverage:
        return cls(function_name=json_obj['functionName'], ranges=[
            CoverageRange.from_json(i) for i in json_obj['ranges']],
            is_block_coverage=json_obj['isBlockCoverage'])


@dataclass
class PositionTickInfo:
    """Specifies a number of samples attributed to a certain source position."""
    line: int
    ticks: int

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['line'] = self.line
        json_data['ticks'] = self.ticks
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->PositionTickInfo:
        return cls(line=json_obj['line'], ticks=json_obj['ticks'])


@dataclass
class Profile:
    """Profile."""
    nodes: typing.List[ProfileNode]
    start_time: float
    end_time: float
    samples: typing.Optional[typing.List[int]] = None
    time_deltas: typing.Optional[typing.List[int]] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['nodes'] = [i.to_json() for i in self.nodes]
        json_data['startTime'] = self.start_time
        json_data['endTime'] = self.end_time
        if self.samples is not None:
            json_data['samples'] = [i for i in self.samples]
        if self.time_deltas is not None:
            json_data['timeDeltas'] = [i for i in self.time_deltas]
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->Profile:
        return cls(nodes=[ProfileNode.from_json(i) for i in json_obj[
            'nodes']], start_time=json_obj['startTime'], end_time=json_obj[
            'endTime'], samples=[i for i in json_obj['samples']] if 
            json_obj.get('samples') is not None else None, time_deltas=[i for
            i in json_obj['timeDeltas']] if json_obj.get('timeDeltas') is not
            None else None)


@dataclass
class ProfileNode:
    """Profile node. Holds callsite information, execution statistics and child nodes."""
    id_: int
    call_frame: runtime.CallFrame
    hit_count: typing.Optional[int] = None
    children: typing.Optional[typing.List[int]] = None
    deopt_reason: typing.Optional[str] = None
    position_ticks: typing.Optional[typing.List[PositionTickInfo]] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['id'] = self.id_
        json_data['callFrame'] = self.call_frame.to_json()
        if self.hit_count is not None:
            json_data['hitCount'] = self.hit_count
        if self.children is not None:
            json_data['children'] = [i for i in self.children]
        if self.deopt_reason is not None:
            json_data['deoptReason'] = self.deopt_reason
        if self.position_ticks is not None:
            json_data['positionTicks'] = [i.to_json() for i in self.
                position_ticks]
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->ProfileNode:
        return cls(id_=json_obj['id'], call_frame=runtime.CallFrame.
            from_json(json_obj['callFrame']), hit_count=json_obj['hitCount'
            ] if json_obj.get('hitCount') is not None else None, children=[
            i for i in json_obj['children']] if json_obj.get('children') is not
            None else None, deopt_reason=json_obj['deoptReason'] if 
            json_obj.get('deoptReason') is not None else None,
            position_ticks=[PositionTickInfo.from_json(i) for i in json_obj
            ['positionTicks']] if json_obj.get('positionTicks') is not None
             else None)


@dataclass
class ScriptCoverage:
    """Coverage data for a JavaScript script."""
    script_id: runtime.ScriptId
    url: str
    functions: typing.List[FunctionCoverage]

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['scriptId'] = self.script_id.to_json()
        json_data['url'] = self.url
        json_data['functions'] = [i.to_json() for i in self.functions]
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->ScriptCoverage:
        return cls(script_id=runtime.ScriptId.from_json(json_obj['scriptId'
            ]), url=json_obj['url'], functions=[FunctionCoverage.from_json(
            i) for i in json_obj['functions']])


def disable() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    cmd_dict = {'method': 'Profiler.disable'}
    json_result = yield cmd_dict
    return None


def enable() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    cmd_dict = {'method': 'Profiler.enable'}
    json_result = yield cmd_dict
    return None


def get_best_effort_coverage() ->typing.Generator[T_JSON_DICT, T_JSON_DICT,
    typing.List[ScriptCoverage]]:
    """Collect coverage data for the current isolate. The coverage data may be incomplete due to
garbage collection.


:returns: Coverage data for the current isolate."""
    cmd_dict = {'method': 'Profiler.getBestEffortCoverage'}
    json_result = yield cmd_dict
    return [ScriptCoverage.from_json(i) for i in json_result['result']]


def set_sampling_interval(interval: int) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, None]:
    """Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.

:param ...:

:param interval: New sampling interval in microseconds."""
    params_dict: T_JSON_DICT = dict()
    params_dict['interval'] = interval
    cmd_dict = {'method': 'Profiler.setSamplingInterval', 'params': params_dict
        }
    json_result = yield cmd_dict
    return None


def start() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    cmd_dict = {'method': 'Profiler.start'}
    json_result = yield cmd_dict
    return None


def start_precise_coverage(call_count: typing.Optional[bool]=None, detailed:
    typing.Optional[bool]=None, allow_triggered_updates: typing.Optional[
    bool]=None) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, float]:
    """Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code
coverage may be incomplete. Enabling prevents running optimized code and resets execution
counters.

:param ...:

:param call_count: *(Optional)* Collect accurate call counts beyond simple 'covered' or 'not covered'.

:param detailed: *(Optional)* Collect block-based coverage.

:param allow_triggered_updates: *(Optional)* Allow the backend to send updates on its own initiative


:returns: Monotonically increasing time (in seconds) when the coverage update was taken in the backend."""
    params_dict: T_JSON_DICT = dict()
    if call_count is not None:
        params_dict['callCount'] = call_count
    if detailed is not None:
        params_dict['detailed'] = detailed
    if allow_triggered_updates is not None:
        params_dict['allowTriggeredUpdates'] = allow_triggered_updates
    cmd_dict = {'method': 'Profiler.startPreciseCoverage', 'params':
        params_dict}
    json_result = yield cmd_dict
    return json_result['timestamp']


def stop() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, Profile]:
    """:returns: Recorded profile."""
    cmd_dict = {'method': 'Profiler.stop'}
    json_result = yield cmd_dict
    return Profile.from_json(json_result['profile'])


def stop_precise_coverage() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Disable precise code coverage. Disabling releases unnecessary execution count records and allows
executing optimized code."""
    cmd_dict = {'method': 'Profiler.stopPreciseCoverage'}
    json_result = yield cmd_dict
    return None


def take_precise_coverage() ->typing.Generator[T_JSON_DICT, T_JSON_DICT,
    typing.Tuple[typing.List[ScriptCoverage], float]]:
    """Collect coverage data for the current isolate, and resets execution counters. Precise code
coverage needs to have started.


:returns: A tuple with the following items:

    1. **result** - Coverage data for the current isolate.
    2. **timestamp** - Monotonically increasing time (in seconds) when the coverage update was taken in the backend."""
    cmd_dict = {'method': 'Profiler.takePreciseCoverage'}
    json_result = yield cmd_dict
    return [ScriptCoverage.from_json(i) for i in json_result['result']
        ], json_result['timestamp']


@event_class('Profiler.consoleProfileFinished')
@dataclass
class ConsoleProfileFinished:
    id_: str
    location: debugger.Location
    profile: Profile
    title: typing.Optional[str] = None

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->ConsoleProfileFinished:
        return cls(id_=json_obj['id'], location=debugger.Location.from_json
            (json_obj['location']), profile=Profile.from_json(json_obj[
            'profile']), title=json_obj['title'] if json_obj.get('title')
             is not None else None)


@event_class('Profiler.consoleProfileStarted')
@dataclass
class ConsoleProfileStarted:
    """Sent when new profile recording is started using console.profile() call."""
    id_: str
    location: debugger.Location
    title: typing.Optional[str] = None

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->ConsoleProfileStarted:
        return cls(id_=json_obj['id'], location=debugger.Location.from_json
            (json_obj['location']), title=json_obj['title'] if json_obj.get
            ('title') is not None else None)


@event_class('Profiler.preciseCoverageDeltaUpdate')
@dataclass
class PreciseCoverageDeltaUpdate:
    """**EXPERIMENTAL**

Reports coverage delta since the last poll (either from an event like this, or from
``takePreciseCoverage`` for the current isolate. May only be sent if precise code
coverage has been started. This event can be trigged by the embedder to, for example,
trigger collection of coverage data immediately at a certain point in time."""
    timestamp: float
    occasion: str
    result: typing.List[ScriptCoverage]

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->PreciseCoverageDeltaUpdate:
        return cls(timestamp=json_obj['timestamp'], occasion=json_obj[
            'occasion'], result=[ScriptCoverage.from_json(i) for i in
            json_obj['result']])
