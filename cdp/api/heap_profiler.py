# # DO NOT EDIT THIS FILE!
# #
# # This file is generated from the CDP specification using AST. If you need to make
# # changes, edit the generator and regenerate all of the modules.

from __future__ import annotations
"""API wrapper for the HeapProfiler domain."""
import typing
from ..util import CDPClient
from .. import heap_profiler as _heap_profiler_module
from .. import runtime
None


class HeapProfilerAPI:
    """Provides an API wrapper for the 'HeapProfiler' domain commands.

**EXPERIMENTAL**"""

    def __init__(self, client: CDPClient) ->None:
        self.client: CDPClient = client

    def add_inspected_heap_object(self, heap_object_id:
        _heap_profiler_module.HeapSnapshotObjectId, _response_timeout:
        typing.Optional[float]=None) ->None:
        """Enables console to refer to the node with given id via $x (see Command Line API for more details
$x functions).

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param heap_object_id: Heap snapshot object id to be accessible by means of $x command line API.

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _heap_profiler_module.add_inspected_heap_object(heap_object_id
            =heap_object_id)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def collect_garbage(self, _response_timeout: typing.Optional[float]=None
        ) ->None:
        """NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _heap_profiler_module.collect_garbage()
        return self.client.send(gen, _response_timeout=_response_timeout)

    def disable(self, _response_timeout: typing.Optional[float]=None) ->None:
        """NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _heap_profiler_module.disable()
        return self.client.send(gen, _response_timeout=_response_timeout)

    def enable(self, _response_timeout: typing.Optional[float]=None) ->None:
        """NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _heap_profiler_module.enable()
        return self.client.send(gen, _response_timeout=_response_timeout)

    def get_heap_object_id(self, object_id: runtime.RemoteObjectId,
        _response_timeout: typing.Optional[float]=None
        ) ->_heap_profiler_module.HeapSnapshotObjectId:
        """NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param object_id: Identifier of the object to get heap object id for.

:param _response_timeout: Optional timeout in seconds for the command.


:returns: Id of the heap snapshot object corresponding to the passed remote object id."""
        gen = _heap_profiler_module.get_heap_object_id(object_id=object_id)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def get_object_by_heap_object_id(self, object_id: _heap_profiler_module
        .HeapSnapshotObjectId, object_group: typing.Optional[str]=None,
        _response_timeout: typing.Optional[float]=None) ->runtime.RemoteObject:
        """NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param object_id:

:param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.

:param _response_timeout: Optional timeout in seconds for the command.


:returns: Evaluation result."""
        gen = _heap_profiler_module.get_object_by_heap_object_id(object_id=
            object_id, object_group=object_group)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def get_sampling_profile(self, _response_timeout: typing.Optional[float
        ]=None) ->_heap_profiler_module.SamplingHeapProfile:
        """NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param _response_timeout: Optional timeout in seconds for the command.


:returns: Return the sampling profile being collected."""
        gen = _heap_profiler_module.get_sampling_profile()
        return self.client.send(gen, _response_timeout=_response_timeout)

    def start_sampling(self, sampling_interval: typing.Optional[float]=None,
        include_objects_collected_by_major_gc: typing.Optional[bool]=None,
        include_objects_collected_by_minor_gc: typing.Optional[bool]=None,
        _response_timeout: typing.Optional[float]=None) ->None:
        """NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param sampling_interval: *(Optional)* Average sample interval in bytes. Poisson distribution is used for the intervals. The default value is 32768 bytes.

:param include_objects_collected_by_major_gc: *(Optional)* By default, the sampling heap profiler reports only objects which are still alive when the profile is returned via getSamplingProfile or stopSampling, which is useful for determining what functions contribute the most to steady-state memory usage. This flag instructs the sampling heap profiler to also include information about objects discarded by major GC, which will show which functions cause large temporary memory usage or long GC pauses.

:param include_objects_collected_by_minor_gc: *(Optional)* By default, the sampling heap profiler reports only objects which are still alive when the profile is returned via getSamplingProfile or stopSampling, which is useful for determining what functions contribute the most to steady-state memory usage. This flag instructs the sampling heap profiler to also include information about objects discarded by minor GC, which is useful when tuning a latency-sensitive application for minimal GC activity.

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _heap_profiler_module.start_sampling(sampling_interval=
            sampling_interval, include_objects_collected_by_major_gc=
            include_objects_collected_by_major_gc,
            include_objects_collected_by_minor_gc=
            include_objects_collected_by_minor_gc)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def start_tracking_heap_objects(self, track_allocations: typing.
        Optional[bool]=None, _response_timeout: typing.Optional[float]=None
        ) ->None:
        """NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param track_allocations: *(Optional)*

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _heap_profiler_module.start_tracking_heap_objects(
            track_allocations=track_allocations)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def stop_sampling(self, _response_timeout: typing.Optional[float]=None
        ) ->_heap_profiler_module.SamplingHeapProfile:
        """NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param _response_timeout: Optional timeout in seconds for the command.


:returns: Recorded sampling heap profile."""
        gen = _heap_profiler_module.stop_sampling()
        return self.client.send(gen, _response_timeout=_response_timeout)

    def stop_tracking_heap_objects(self, report_progress: typing.Optional[
        bool]=None, treat_global_objects_as_roots: typing.Optional[bool]=
        None, capture_numeric_value: typing.Optional[bool]=None,
        expose_internals: typing.Optional[bool]=None, _response_timeout:
        typing.Optional[float]=None) ->None:
        """NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param report_progress: *(Optional)* If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken when the tracking is stopped.

:param treat_global_objects_as_roots: **(DEPRECATED)** *(Optional)* Deprecated in favor of ``exposeInternals``.

:param capture_numeric_value: *(Optional)* If true, numerical values are included in the snapshot

:param expose_internals: **(EXPERIMENTAL)** *(Optional)* If true, exposes internals of the snapshot.

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _heap_profiler_module.stop_tracking_heap_objects(report_progress
            =report_progress, treat_global_objects_as_roots=
            treat_global_objects_as_roots, capture_numeric_value=
            capture_numeric_value, expose_internals=expose_internals)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def take_heap_snapshot(self, report_progress: typing.Optional[bool]=
        None, treat_global_objects_as_roots: typing.Optional[bool]=None,
        capture_numeric_value: typing.Optional[bool]=None, expose_internals:
        typing.Optional[bool]=None, _response_timeout: typing.Optional[
        float]=None) ->None:
        """NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param report_progress: *(Optional)* If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken.

:param treat_global_objects_as_roots: **(DEPRECATED)** *(Optional)* If true, a raw snapshot without artificial roots will be generated. Deprecated in favor of ``exposeInternals``.

:param capture_numeric_value: *(Optional)* If true, numerical values are included in the snapshot

:param expose_internals: **(EXPERIMENTAL)** *(Optional)* If true, exposes internals of the snapshot.

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _heap_profiler_module.take_heap_snapshot(report_progress=
            report_progress, treat_global_objects_as_roots=
            treat_global_objects_as_roots, capture_numeric_value=
            capture_numeric_value, expose_internals=expose_internals)
        return self.client.send(gen, _response_timeout=_response_timeout)
