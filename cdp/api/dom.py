# # DO NOT EDIT THIS FILE!
# #
# # This file is generated from the CDP specification using AST. If you need to make
# # changes, edit the generator and regenerate all of the modules.

from __future__ import annotations
"""API wrapper for the DOM domain."""
import typing
from ..util import CDPClient
from .. import dom as _dom_module
from .. import page
from .. import runtime
from deprecated.sphinx import deprecated
None


class DomAPI:
    """Provides an API wrapper for the 'DOM' domain commands.

Domain Description:
This domain exposes DOM read/write operations. Each DOM Node is represented with its mirror object
that has an ``id``. This ``id`` can be used to get additional information on the Node, resolve it into
the JavaScript object wrapper, etc. It is important that client receives DOM events only for the
nodes that are known to the client. Backend keeps track of the nodes that were sent to the client
and never sends the same node twice. It is client's responsibility to collect information about
the nodes that were sent to the client. Note that ``iframe`` owner elements will return
corresponding document elements as their child nodes."""

    def __init__(self, client: CDPClient) ->None:
        self.client: CDPClient = client

    def collect_class_names_from_subtree(self, node_id: _dom_module.NodeId,
        _response_timeout: typing.Optional[float]=None) ->typing.List[str]:
        """Collects class names for the node with given id and all of it's child nodes.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param node_id: Id of the node to collect class names.

:param _response_timeout: Optional timeout in seconds for the command.


:returns: Class name list."""
        gen = _dom_module.collect_class_names_from_subtree(node_id=node_id)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def copy_to(self, node_id: _dom_module.NodeId, target_node_id:
        _dom_module.NodeId, insert_before_node_id: typing.Optional[
        _dom_module.NodeId]=None, _response_timeout: typing.Optional[float]
        =None) ->_dom_module.NodeId:
        """Creates a deep copy of the specified node and places it into the target container before the
given anchor.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param node_id: Id of the node to copy.

:param target_node_id: Id of the element to drop the copy into.

:param insert_before_node_id: *(Optional)* Drop the copy before this node (if absent, the copy becomes the last child of ``targetNodeId``).

:param _response_timeout: Optional timeout in seconds for the command.


:returns: Id of the node clone."""
        gen = _dom_module.copy_to(node_id=node_id, target_node_id=
            target_node_id, insert_before_node_id=insert_before_node_id)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def describe_node(self, node_id: typing.Optional[_dom_module.NodeId]=
        None, backend_node_id: typing.Optional[_dom_module.BackendNodeId]=
        None, object_id: typing.Optional[runtime.RemoteObjectId]=None,
        depth: typing.Optional[int]=None, pierce: typing.Optional[bool]=
        None, _response_timeout: typing.Optional[float]=None
        ) ->_dom_module.Node:
        """Describes node given its id, does not require domain to be enabled. Does not start tracking any
objects, can be used for automation.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param node_id: *(Optional)* Identifier of the node.

:param backend_node_id: *(Optional)* Identifier of the backend node.

:param object_id: *(Optional)* JavaScript object id of the node wrapper.

:param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.

:param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).

:param _response_timeout: Optional timeout in seconds for the command.


:returns: Node description."""
        gen = _dom_module.describe_node(node_id=node_id, backend_node_id=
            backend_node_id, object_id=object_id, depth=depth, pierce=pierce)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def disable(self, _response_timeout: typing.Optional[float]=None) ->None:
        """Disables DOM agent for the given page.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _dom_module.disable()
        return self.client.send(gen, _response_timeout=_response_timeout)

    def discard_search_results(self, search_id: str, _response_timeout:
        typing.Optional[float]=None) ->None:
        """Discards search results from the session with the given id. ``getSearchResults`` should no longer
be called for that search.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param search_id: Unique search session identifier.

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _dom_module.discard_search_results(search_id=search_id)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def enable(self, include_whitespace: typing.Optional[str]=None,
        _response_timeout: typing.Optional[float]=None) ->None:
        """Enables DOM agent for the given page.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param include_whitespace: **(EXPERIMENTAL)** *(Optional)* Whether to include whitespaces in the children array of returned Nodes.

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _dom_module.enable(include_whitespace=include_whitespace)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def focus(self, node_id: typing.Optional[_dom_module.NodeId]=None,
        backend_node_id: typing.Optional[_dom_module.BackendNodeId]=None,
        object_id: typing.Optional[runtime.RemoteObjectId]=None,
        _response_timeout: typing.Optional[float]=None) ->None:
        """Focuses the given element.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param node_id: *(Optional)* Identifier of the node.

:param backend_node_id: *(Optional)* Identifier of the backend node.

:param object_id: *(Optional)* JavaScript object id of the node wrapper.

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _dom_module.focus(node_id=node_id, backend_node_id=
            backend_node_id, object_id=object_id)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def get_anchor_element(self, node_id: _dom_module.NodeId,
        anchor_specifier: typing.Optional[str]=None, _response_timeout:
        typing.Optional[float]=None) ->_dom_module.NodeId:
        """Returns the target anchor element of the given anchor query according to
https://www.w3.org/TR/css-anchor-position-1/#target.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param node_id: Id of the positioned element from which to find the anchor.

:param anchor_specifier: *(Optional)* An optional anchor specifier, as defined in https://www.w3.org/TR/css-anchor-position-1/#anchor-specifier. If not provided, it will return the implicit anchor element for the given positioned element.

:param _response_timeout: Optional timeout in seconds for the command.


:returns: The anchor element of the given anchor query."""
        gen = _dom_module.get_anchor_element(node_id=node_id,
            anchor_specifier=anchor_specifier)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def get_attributes(self, node_id: _dom_module.NodeId, _response_timeout:
        typing.Optional[float]=None) ->typing.List[str]:
        """Returns attributes for the specified node.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param node_id: Id of the node to retrieve attributes for.

:param _response_timeout: Optional timeout in seconds for the command.


:returns: An interleaved array of node attribute names and values."""
        gen = _dom_module.get_attributes(node_id=node_id)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def get_box_model(self, node_id: typing.Optional[_dom_module.NodeId]=
        None, backend_node_id: typing.Optional[_dom_module.BackendNodeId]=
        None, object_id: typing.Optional[runtime.RemoteObjectId]=None,
        _response_timeout: typing.Optional[float]=None) ->_dom_module.BoxModel:
        """Returns boxes for the given node.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param node_id: *(Optional)* Identifier of the node.

:param backend_node_id: *(Optional)* Identifier of the backend node.

:param object_id: *(Optional)* JavaScript object id of the node wrapper.

:param _response_timeout: Optional timeout in seconds for the command.


:returns: Box model for the node."""
        gen = _dom_module.get_box_model(node_id=node_id, backend_node_id=
            backend_node_id, object_id=object_id)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def get_container_for_node(self, node_id: _dom_module.NodeId,
        container_name: typing.Optional[str]=None, physical_axes: typing.
        Optional[_dom_module.PhysicalAxes]=None, logical_axes: typing.
        Optional[_dom_module.LogicalAxes]=None, queries_scroll_state:
        typing.Optional[bool]=None, _response_timeout: typing.Optional[
        float]=None) ->typing.Optional[_dom_module.NodeId]:
        """Returns the query container of the given node based on container query
conditions: containerName, physical and logical axes, and whether it queries
scroll-state. If no axes are provided and queriesScrollState is false, the
style container is returned, which is the direct parent or the closest
element with a matching container-name.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param node_id:

:param container_name: *(Optional)*

:param physical_axes: *(Optional)*

:param logical_axes: *(Optional)*

:param queries_scroll_state: *(Optional)*

:param _response_timeout: Optional timeout in seconds for the command.


:returns: *(Optional)* The container node for the given node, or null if not found."""
        gen = _dom_module.get_container_for_node(node_id=node_id,
            container_name=container_name, physical_axes=physical_axes,
            logical_axes=logical_axes, queries_scroll_state=
            queries_scroll_state)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def get_content_quads(self, node_id: typing.Optional[_dom_module.NodeId
        ]=None, backend_node_id: typing.Optional[_dom_module.BackendNodeId]
        =None, object_id: typing.Optional[runtime.RemoteObjectId]=None,
        _response_timeout: typing.Optional[float]=None) ->typing.List[
        _dom_module.Quad]:
        """Returns quads that describe node position on the page. This method
might return multiple quads for inline nodes.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param node_id: *(Optional)* Identifier of the node.

:param backend_node_id: *(Optional)* Identifier of the backend node.

:param object_id: *(Optional)* JavaScript object id of the node wrapper.

:param _response_timeout: Optional timeout in seconds for the command.


:returns: Quads that describe node layout relative to viewport."""
        gen = _dom_module.get_content_quads(node_id=node_id,
            backend_node_id=backend_node_id, object_id=object_id)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def get_detached_dom_nodes(self, _response_timeout: typing.Optional[
        float]=None) ->typing.List[_dom_module.DetachedElementInfo]:
        """Returns list of detached nodes

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param _response_timeout: Optional timeout in seconds for the command.


:returns: The list of detached nodes"""
        gen = _dom_module.get_detached_dom_nodes()
        return self.client.send(gen, _response_timeout=_response_timeout)

    def get_document(self, depth: typing.Optional[int]=None, pierce: typing
        .Optional[bool]=None, _response_timeout: typing.Optional[float]=None
        ) ->_dom_module.Node:
        """Returns the root DOM node (and optionally the subtree) to the caller.
Implicitly enables the DOM domain events for the current target.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.

:param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).

:param _response_timeout: Optional timeout in seconds for the command.


:returns: Resulting node."""
        gen = _dom_module.get_document(depth=depth, pierce=pierce)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def get_element_by_relation(self, node_id: _dom_module.NodeId, relation:
        str, _response_timeout: typing.Optional[float]=None
        ) ->_dom_module.NodeId:
        """Returns the NodeId of the matched element according to certain relations.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param node_id: Id of the node from which to query the relation.

:param relation: Type of relation to get.

:param _response_timeout: Optional timeout in seconds for the command.


:returns: NodeId of the element matching the queried relation."""
        gen = _dom_module.get_element_by_relation(node_id=node_id, relation
            =relation)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def get_file_info(self, object_id: runtime.RemoteObjectId,
        _response_timeout: typing.Optional[float]=None) ->str:
        """Returns file information for the given
File wrapper.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param object_id: JavaScript object id of the node wrapper.

:param _response_timeout: Optional timeout in seconds for the command.


:returns:"""
        gen = _dom_module.get_file_info(object_id=object_id)
        return self.client.send(gen, _response_timeout=_response_timeout)

    @deprecated(version='1.3')
    def get_flattened_document(self, depth: typing.Optional[int]=None,
        pierce: typing.Optional[bool]=None, _response_timeout: typing.
        Optional[float]=None) ->typing.List[_dom_module.Node]:
        """Returns the root DOM node (and optionally the subtree) to the caller.
Deprecated, as it is not designed to work well with the rest of the DOM agent.
Use DOMSnapshot.captureSnapshot instead.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

.. deprecated:: 1.3


:param ...:

:param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.

:param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).

:param _response_timeout: Optional timeout in seconds for the command.


:returns: Resulting node."""
        gen = _dom_module.get_flattened_document(depth=depth, pierce=pierce)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def get_frame_owner(self, frame_id: page.FrameId, _response_timeout:
        typing.Optional[float]=None) ->typing.Tuple[_dom_module.
        BackendNodeId, typing.Optional[_dom_module.NodeId]]:
        """Returns iframe node that owns iframe with the given domain.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param frame_id:

:param _response_timeout: Optional timeout in seconds for the command.


:returns: A tuple with the following items:

    1. **backendNodeId** - Resulting node.
    2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document."""
        gen = _dom_module.get_frame_owner(frame_id=frame_id)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def get_node_for_location(self, x: int, y: int,
        include_user_agent_shadow_dom: typing.Optional[bool]=None,
        ignore_pointer_events_none: typing.Optional[bool]=None,
        _response_timeout: typing.Optional[float]=None) ->typing.Tuple[
        _dom_module.BackendNodeId, page.FrameId, typing.Optional[
        _dom_module.NodeId]]:
        """Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
either returned or not.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param x: X coordinate.

:param y: Y coordinate.

:param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false).

:param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them.

:param _response_timeout: Optional timeout in seconds for the command.


:returns: A tuple with the following items:

    1. **backendNodeId** - Resulting node.
    2. **frameId** - Frame this node belongs to.
    3. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document."""
        gen = _dom_module.get_node_for_location(x=x, y=y,
            include_user_agent_shadow_dom=include_user_agent_shadow_dom,
            ignore_pointer_events_none=ignore_pointer_events_none)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def get_node_stack_traces(self, node_id: _dom_module.NodeId,
        _response_timeout: typing.Optional[float]=None) ->typing.Optional[
        runtime.StackTrace]:
        """Gets stack traces associated with a Node. As of now, only provides stack trace for Node creation.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param node_id: Id of the node to get stack traces for.

:param _response_timeout: Optional timeout in seconds for the command.


:returns: *(Optional)* Creation stack trace, if available."""
        gen = _dom_module.get_node_stack_traces(node_id=node_id)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def get_nodes_for_subtree_by_style(self, node_id: _dom_module.NodeId,
        computed_styles: typing.List[_dom_module.CSSComputedStyleProperty],
        pierce: typing.Optional[bool]=None, _response_timeout: typing.
        Optional[float]=None) ->typing.List[_dom_module.NodeId]:
        """Finds nodes with a given computed style in a subtree.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param node_id: Node ID pointing to the root of a subtree.

:param computed_styles: The style to filter nodes by (includes nodes if any of properties matches).

:param pierce: *(Optional)* Whether or not iframes and shadow roots in the same target should be traversed when returning the results (default is false).

:param _response_timeout: Optional timeout in seconds for the command.


:returns: Resulting nodes."""
        gen = _dom_module.get_nodes_for_subtree_by_style(node_id=node_id,
            computed_styles=computed_styles, pierce=pierce)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def get_outer_html(self, node_id: typing.Optional[_dom_module.NodeId]=
        None, backend_node_id: typing.Optional[_dom_module.BackendNodeId]=
        None, object_id: typing.Optional[runtime.RemoteObjectId]=None,
        _response_timeout: typing.Optional[float]=None) ->str:
        """Returns node's HTML markup.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param node_id: *(Optional)* Identifier of the node.

:param backend_node_id: *(Optional)* Identifier of the backend node.

:param object_id: *(Optional)* JavaScript object id of the node wrapper.

:param _response_timeout: Optional timeout in seconds for the command.


:returns: Outer HTML markup."""
        gen = _dom_module.get_outer_html(node_id=node_id, backend_node_id=
            backend_node_id, object_id=object_id)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def get_querying_descendants_for_container(self, node_id: _dom_module.
        NodeId, _response_timeout: typing.Optional[float]=None) ->typing.List[
        _dom_module.NodeId]:
        """Returns the descendants of a container query container that have
container queries against this container.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param node_id: Id of the container node to find querying descendants from.

:param _response_timeout: Optional timeout in seconds for the command.


:returns: Descendant nodes with container queries against the given container."""
        gen = _dom_module.get_querying_descendants_for_container(node_id=
            node_id)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def get_relayout_boundary(self, node_id: _dom_module.NodeId,
        _response_timeout: typing.Optional[float]=None) ->_dom_module.NodeId:
        """Returns the id of the nearest ancestor that is a relayout boundary.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param node_id: Id of the node.

:param _response_timeout: Optional timeout in seconds for the command.


:returns: Relayout boundary node id for the given node."""
        gen = _dom_module.get_relayout_boundary(node_id=node_id)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def get_search_results(self, search_id: str, from_index: int, to_index:
        int, _response_timeout: typing.Optional[float]=None) ->typing.List[
        _dom_module.NodeId]:
        """Returns search results from given ``fromIndex`` to given ``toIndex`` from the search with the given
identifier.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param search_id: Unique search session identifier.

:param from_index: Start index of the search result to be returned.

:param to_index: End index of the search result to be returned.

:param _response_timeout: Optional timeout in seconds for the command.


:returns: Ids of the search result nodes."""
        gen = _dom_module.get_search_results(search_id=search_id,
            from_index=from_index, to_index=to_index)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def get_top_layer_elements(self, _response_timeout: typing.Optional[
        float]=None) ->typing.List[_dom_module.NodeId]:
        """Returns NodeIds of current top layer elements.
Top layer is rendered closest to the user within a viewport, therefore its elements always
appear on top of all other content.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param _response_timeout: Optional timeout in seconds for the command.


:returns: NodeIds of top layer elements"""
        gen = _dom_module.get_top_layer_elements()
        return self.client.send(gen, _response_timeout=_response_timeout)

    def hide_highlight(self, _response_timeout: typing.Optional[float]=None
        ) ->None:
        """Hides any highlight.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

Redirects to command 'Overlay'.


:param ...:

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _dom_module.hide_highlight()
        return self.client.send(gen, _response_timeout=_response_timeout)

    def highlight_node(self, _response_timeout: typing.Optional[float]=None
        ) ->None:
        """Highlights DOM node.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

Redirects to command 'Overlay'.


:param ...:

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _dom_module.highlight_node()
        return self.client.send(gen, _response_timeout=_response_timeout)

    def highlight_rect(self, _response_timeout: typing.Optional[float]=None
        ) ->None:
        """Highlights given rectangle.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

Redirects to command 'Overlay'.


:param ...:

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _dom_module.highlight_rect()
        return self.client.send(gen, _response_timeout=_response_timeout)

    def mark_undoable_state(self, _response_timeout: typing.Optional[float]
        =None) ->None:
        """Marks last undoable state.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _dom_module.mark_undoable_state()
        return self.client.send(gen, _response_timeout=_response_timeout)

    def move_to(self, node_id: _dom_module.NodeId, target_node_id:
        _dom_module.NodeId, insert_before_node_id: typing.Optional[
        _dom_module.NodeId]=None, _response_timeout: typing.Optional[float]
        =None) ->_dom_module.NodeId:
        """Moves node into the new container, places it before the given anchor.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param node_id: Id of the node to move.

:param target_node_id: Id of the element to drop the moved node into.

:param insert_before_node_id: *(Optional)* Drop node before this one (if absent, the moved node becomes the last child of ``targetNodeId``).

:param _response_timeout: Optional timeout in seconds for the command.


:returns: New id of the moved node."""
        gen = _dom_module.move_to(node_id=node_id, target_node_id=
            target_node_id, insert_before_node_id=insert_before_node_id)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def perform_search(self, query: str, include_user_agent_shadow_dom:
        typing.Optional[bool]=None, _response_timeout: typing.Optional[
        float]=None) ->typing.Tuple[str, int]:
        """Searches for a given string in the DOM tree. Use ``getSearchResults`` to access search results or
``cancelSearch`` to end this search session.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param query: Plain text or query selector or XPath search query.

:param include_user_agent_shadow_dom: *(Optional)* True to search in user agent shadow DOM.

:param _response_timeout: Optional timeout in seconds for the command.


:returns: A tuple with the following items:

    1. **searchId** - Unique search session identifier.
    2. **resultCount** - Number of search results."""
        gen = _dom_module.perform_search(query=query,
            include_user_agent_shadow_dom=include_user_agent_shadow_dom)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def push_node_by_path_to_frontend(self, path: str, _response_timeout:
        typing.Optional[float]=None) ->_dom_module.NodeId:
        """Requests that the node is sent to the caller given its path. // FIXME, use XPath

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param path: Path to node in the proprietary format.

:param _response_timeout: Optional timeout in seconds for the command.


:returns: Id of the node for given path."""
        gen = _dom_module.push_node_by_path_to_frontend(path=path)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def push_nodes_by_backend_ids_to_frontend(self, backend_node_ids:
        typing.List[_dom_module.BackendNodeId], _response_timeout: typing.
        Optional[float]=None) ->typing.List[_dom_module.NodeId]:
        """Requests that a batch of nodes is sent to the caller given their backend node ids.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param backend_node_ids: The array of backend node ids.

:param _response_timeout: Optional timeout in seconds for the command.


:returns: The array of ids of pushed nodes that correspond to the backend ids specified in backendNodeIds."""
        gen = _dom_module.push_nodes_by_backend_ids_to_frontend(
            backend_node_ids=backend_node_ids)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def query_selector(self, node_id: _dom_module.NodeId, selector: str,
        _response_timeout: typing.Optional[float]=None) ->_dom_module.NodeId:
        """Executes ``querySelector`` on a given node.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param node_id: Id of the node to query upon.

:param selector: Selector string.

:param _response_timeout: Optional timeout in seconds for the command.


:returns: Query selector result."""
        gen = _dom_module.query_selector(node_id=node_id, selector=selector)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def query_selector_all(self, node_id: _dom_module.NodeId, selector: str,
        _response_timeout: typing.Optional[float]=None) ->typing.List[
        _dom_module.NodeId]:
        """Executes ``querySelectorAll`` on a given node.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param node_id: Id of the node to query upon.

:param selector: Selector string.

:param _response_timeout: Optional timeout in seconds for the command.


:returns: Query selector result."""
        gen = _dom_module.query_selector_all(node_id=node_id, selector=selector
            )
        return self.client.send(gen, _response_timeout=_response_timeout)

    def redo(self, _response_timeout: typing.Optional[float]=None) ->None:
        """Re-does the last undone action.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _dom_module.redo()
        return self.client.send(gen, _response_timeout=_response_timeout)

    def remove_attribute(self, node_id: _dom_module.NodeId, name: str,
        _response_timeout: typing.Optional[float]=None) ->None:
        """Removes attribute with given name from an element with given id.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param node_id: Id of the element to remove attribute from.

:param name: Name of the attribute to remove.

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _dom_module.remove_attribute(node_id=node_id, name=name)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def remove_node(self, node_id: _dom_module.NodeId, _response_timeout:
        typing.Optional[float]=None) ->None:
        """Removes node with given id.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param node_id: Id of the node to remove.

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _dom_module.remove_node(node_id=node_id)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def request_child_nodes(self, node_id: _dom_module.NodeId, depth:
        typing.Optional[int]=None, pierce: typing.Optional[bool]=None,
        _response_timeout: typing.Optional[float]=None) ->None:
        """Requests that children of the node with given id are returned to the caller in form of
``setChildNodes`` events where not only immediate children are retrieved, but all children down to
the specified depth.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param node_id: Id of the node to get children for.

:param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.

:param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the sub-tree (default is false).

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _dom_module.request_child_nodes(node_id=node_id, depth=depth,
            pierce=pierce)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def request_node(self, object_id: runtime.RemoteObjectId,
        _response_timeout: typing.Optional[float]=None) ->_dom_module.NodeId:
        """Requests that the node is sent to the caller given the JavaScript node object reference. All
nodes that form the path from the node to the root are also sent to the client as a series of
``setChildNodes`` notifications.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param object_id: JavaScript object id to convert into node.

:param _response_timeout: Optional timeout in seconds for the command.


:returns: Node id for given object."""
        gen = _dom_module.request_node(object_id=object_id)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def resolve_node(self, node_id: typing.Optional[_dom_module.NodeId]=
        None, backend_node_id: typing.Optional[_dom_module.BackendNodeId]=
        None, object_group: typing.Optional[str]=None, execution_context_id:
        typing.Optional[runtime.ExecutionContextId]=None, _response_timeout:
        typing.Optional[float]=None) ->runtime.RemoteObject:
        """Resolves the JavaScript node object for a given NodeId or BackendNodeId.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param node_id: *(Optional)* Id of the node to resolve.

:param backend_node_id: *(Optional)* Backend identifier of the node to resolve.

:param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.

:param execution_context_id: *(Optional)* Execution context in which to resolve the node.

:param _response_timeout: Optional timeout in seconds for the command.


:returns: JavaScript object wrapper for given node."""
        gen = _dom_module.resolve_node(node_id=node_id, backend_node_id=
            backend_node_id, object_group=object_group,
            execution_context_id=execution_context_id)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def scroll_into_view_if_needed(self, node_id: typing.Optional[
        _dom_module.NodeId]=None, backend_node_id: typing.Optional[
        _dom_module.BackendNodeId]=None, object_id: typing.Optional[runtime
        .RemoteObjectId]=None, rect: typing.Optional[_dom_module.Rect]=None,
        _response_timeout: typing.Optional[float]=None) ->None:
        """Scrolls the specified rect of the given node into view if not already visible.
Note: exactly one between nodeId, backendNodeId and objectId should be passed
to identify the node.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param node_id: *(Optional)* Identifier of the node.

:param backend_node_id: *(Optional)* Identifier of the backend node.

:param object_id: *(Optional)* JavaScript object id of the node wrapper.

:param rect: *(Optional)* The rect to be scrolled into view, relative to the node's border box, in CSS pixels. When omitted, center of the node will be used, similar to Element.scrollIntoView.

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _dom_module.scroll_into_view_if_needed(node_id=node_id,
            backend_node_id=backend_node_id, object_id=object_id, rect=rect)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def set_attribute_value(self, node_id: _dom_module.NodeId, name: str,
        value: str, _response_timeout: typing.Optional[float]=None) ->None:
        """Sets attribute for an element with given id.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param node_id: Id of the element to set attribute for.

:param name: Attribute name.

:param value: Attribute value.

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _dom_module.set_attribute_value(node_id=node_id, name=name,
            value=value)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def set_attributes_as_text(self, node_id: _dom_module.NodeId, text: str,
        name: typing.Optional[str]=None, _response_timeout: typing.Optional
        [float]=None) ->None:
        """Sets attributes on element with given id. This method is useful when user edits some existing
attribute value and types in several attribute name/value pairs.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param node_id: Id of the element to set attributes for.

:param text: Text with a number of attributes. Will parse this text using HTML parser.

:param name: *(Optional)* Attribute name to replace with new attributes derived from text in case text parsed successfully.

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _dom_module.set_attributes_as_text(node_id=node_id, text=text,
            name=name)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def set_file_input_files(self, files: typing.List[str], node_id: typing
        .Optional[_dom_module.NodeId]=None, backend_node_id: typing.
        Optional[_dom_module.BackendNodeId]=None, object_id: typing.
        Optional[runtime.RemoteObjectId]=None, _response_timeout: typing.
        Optional[float]=None) ->None:
        """Sets files for the given file input element.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param files: Array of file paths to set.

:param node_id: *(Optional)* Identifier of the node.

:param backend_node_id: *(Optional)* Identifier of the backend node.

:param object_id: *(Optional)* JavaScript object id of the node wrapper.

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _dom_module.set_file_input_files(files=files, node_id=node_id,
            backend_node_id=backend_node_id, object_id=object_id)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def set_inspected_node(self, node_id: _dom_module.NodeId,
        _response_timeout: typing.Optional[float]=None) ->None:
        """Enables console to refer to the node with given id via $x (see Command Line API for more details
$x functions).

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param node_id: DOM node id to be accessible by means of $x command line API.

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _dom_module.set_inspected_node(node_id=node_id)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def set_node_name(self, node_id: _dom_module.NodeId, name: str,
        _response_timeout: typing.Optional[float]=None) ->_dom_module.NodeId:
        """Sets node name for a node with given id.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param node_id: Id of the node to set name for.

:param name: New node's name.

:param _response_timeout: Optional timeout in seconds for the command.


:returns: New node's id."""
        gen = _dom_module.set_node_name(node_id=node_id, name=name)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def set_node_stack_traces_enabled(self, enable: bool, _response_timeout:
        typing.Optional[float]=None) ->None:
        """Sets if stack traces should be captured for Nodes. See ``Node.getNodeStackTraces``. Default is disabled.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param enable: Enable or disable.

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _dom_module.set_node_stack_traces_enabled(enable=enable)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def set_node_value(self, node_id: _dom_module.NodeId, value: str,
        _response_timeout: typing.Optional[float]=None) ->None:
        """Sets node value for a node with given id.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param node_id: Id of the node to set value for.

:param value: New node's value.

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _dom_module.set_node_value(node_id=node_id, value=value)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def set_outer_html(self, node_id: _dom_module.NodeId, outer_html: str,
        _response_timeout: typing.Optional[float]=None) ->None:
        """Sets node HTML markup, returns new node id.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param node_id: Id of the node to set markup for.

:param outer_html: Outer HTML markup to set.

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _dom_module.set_outer_html(node_id=node_id, outer_html=outer_html
            )
        return self.client.send(gen, _response_timeout=_response_timeout)

    def undo(self, _response_timeout: typing.Optional[float]=None) ->None:
        """Undoes the last performed action.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _dom_module.undo()
        return self.client.send(gen, _response_timeout=_response_timeout)
