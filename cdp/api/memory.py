# # DO NOT EDIT THIS FILE!
# #
# # This file is generated from the CDP specification using AST. If you need to make
# # changes, edit the generator and regenerate all of the modules.

from __future__ import annotations
"""API wrapper for the Memory domain."""
import typing
from ..util import CDPClient
from .. import memory as _memory_module
None


class MemoryAPI:
    """Provides an API wrapper for the 'Memory' domain commands.

**EXPERIMENTAL**"""

    def __init__(self, client: CDPClient) ->None:
        self.client: CDPClient = client

    def forcibly_purge_java_script_memory(self, _response_timeout: typing.
        Optional[float]=None) ->None:
        """Simulate OomIntervention by purging V8 memory.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _memory_module.forcibly_purge_java_script_memory()
        return self.client.send(gen, _response_timeout=_response_timeout)

    def get_all_time_sampling_profile(self, _response_timeout: typing.
        Optional[float]=None) ->_memory_module.SamplingProfile:
        """Retrieve native memory allocations profile
collected since renderer process startup.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param _response_timeout: Optional timeout in seconds for the command.


:returns:"""
        gen = _memory_module.get_all_time_sampling_profile()
        return self.client.send(gen, _response_timeout=_response_timeout)

    def get_browser_sampling_profile(self, _response_timeout: typing.
        Optional[float]=None) ->_memory_module.SamplingProfile:
        """Retrieve native memory allocations profile
collected since browser process startup.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param _response_timeout: Optional timeout in seconds for the command.


:returns:"""
        gen = _memory_module.get_browser_sampling_profile()
        return self.client.send(gen, _response_timeout=_response_timeout)

    def get_dom_counters(self, _response_timeout: typing.Optional[float]=None
        ) ->typing.Tuple[int, int, int]:
        """Retruns current DOM object counters.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param _response_timeout: Optional timeout in seconds for the command.


:returns: A tuple with the following items:

    1. **documents** - 
    2. **nodes** - 
    3. **jsEventListeners** -"""
        gen = _memory_module.get_dom_counters()
        return self.client.send(gen, _response_timeout=_response_timeout)

    def get_dom_counters_for_leak_detection(self, _response_timeout: typing
        .Optional[float]=None) ->typing.List[_memory_module.DOMCounter]:
        """Retruns DOM object counters after preparing renderer for leak detection.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param _response_timeout: Optional timeout in seconds for the command.


:returns: DOM object counters."""
        gen = _memory_module.get_dom_counters_for_leak_detection()
        return self.client.send(gen, _response_timeout=_response_timeout)

    def get_sampling_profile(self, _response_timeout: typing.Optional[float
        ]=None) ->_memory_module.SamplingProfile:
        """Retrieve native memory allocations profile collected since last
``startSampling`` call.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param _response_timeout: Optional timeout in seconds for the command.


:returns:"""
        gen = _memory_module.get_sampling_profile()
        return self.client.send(gen, _response_timeout=_response_timeout)

    def prepare_for_leak_detection(self, _response_timeout: typing.Optional
        [float]=None) ->None:
        """Prepares for leak detection by terminating workers, stopping spellcheckers,
dropping non-essential internal caches, running garbage collections, etc.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _memory_module.prepare_for_leak_detection()
        return self.client.send(gen, _response_timeout=_response_timeout)

    def set_pressure_notifications_suppressed(self, suppressed: bool,
        _response_timeout: typing.Optional[float]=None) ->None:
        """Enable/disable suppressing memory pressure notifications in all processes.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param suppressed: If true, memory pressure notifications will be suppressed.

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _memory_module.set_pressure_notifications_suppressed(suppressed
            =suppressed)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def simulate_pressure_notification(self, level: _memory_module.
        PressureLevel, _response_timeout: typing.Optional[float]=None) ->None:
        """Simulate a memory pressure notification in all processes.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param level: Memory pressure level of the notification.

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _memory_module.simulate_pressure_notification(level=level)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def start_sampling(self, sampling_interval: typing.Optional[int]=None,
        suppress_randomness: typing.Optional[bool]=None, _response_timeout:
        typing.Optional[float]=None) ->None:
        """Start collecting native memory profile.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param sampling_interval: *(Optional)* Average number of bytes between samples.

:param suppress_randomness: *(Optional)* Do not randomize intervals between samples.

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _memory_module.start_sampling(sampling_interval=
            sampling_interval, suppress_randomness=suppress_randomness)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def stop_sampling(self, _response_timeout: typing.Optional[float]=None
        ) ->None:
        """Stop collecting native memory profile.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _memory_module.stop_sampling()
        return self.client.send(gen, _response_timeout=_response_timeout)
