# # DO NOT EDIT THIS FILE!
# #
# # This file is generated from the CDP specification using AST. If you need to make
# # changes, edit the generator and regenerate all of the modules.

from __future__ import annotations
"""API wrapper for the Tracing domain."""
import typing
from ..util import CDPClient
from .. import tracing as _tracing_module
None


class TracingAPI:
    """Provides an API wrapper for the 'Tracing' domain commands."""

    def __init__(self, client: CDPClient) ->None:
        self.client: CDPClient = client

    def end(self, _response_timeout: typing.Optional[float]=None) ->None:
        """Stop trace events collection.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _tracing_module.end()
        return self.client.send(gen, _response_timeout=_response_timeout)

    def get_categories(self, _response_timeout: typing.Optional[float]=None
        ) ->typing.List[str]:
        """Gets supported tracing categories.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param _response_timeout: Optional timeout in seconds for the command.


:returns: A list of supported tracing categories."""
        gen = _tracing_module.get_categories()
        return self.client.send(gen, _response_timeout=_response_timeout)

    def record_clock_sync_marker(self, sync_id: str, _response_timeout:
        typing.Optional[float]=None) ->None:
        """Record a clock sync marker in the trace.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param sync_id: The ID of this clock sync marker

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _tracing_module.record_clock_sync_marker(sync_id=sync_id)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def request_memory_dump(self, deterministic: typing.Optional[bool]=None,
        level_of_detail: typing.Optional[_tracing_module.
        MemoryDumpLevelOfDetail]=None, _response_timeout: typing.Optional[
        float]=None) ->typing.Tuple[str, bool]:
        """Request a global memory dump.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param deterministic: *(Optional)* Enables more deterministic results by forcing garbage collection

:param level_of_detail: *(Optional)* Specifies level of details in memory dump. Defaults to "detailed".

:param _response_timeout: Optional timeout in seconds for the command.


:returns: A tuple with the following items:

    1. **dumpGuid** - GUID of the resulting global memory dump.
    2. **success** - True iff the global memory dump succeeded."""
        gen = _tracing_module.request_memory_dump(deterministic=
            deterministic, level_of_detail=level_of_detail)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def start(self, categories: typing.Optional[str]=None, options: typing.
        Optional[str]=None, buffer_usage_reporting_interval: typing.
        Optional[float]=None, transfer_mode: typing.Optional[str]=None,
        stream_format: typing.Optional[_tracing_module.StreamFormat]=None,
        stream_compression: typing.Optional[_tracing_module.
        StreamCompression]=None, trace_config: typing.Optional[
        _tracing_module.TraceConfig]=None, perfetto_config: typing.Optional
        [str]=None, tracing_backend: typing.Optional[_tracing_module.
        TracingBackend]=None, _response_timeout: typing.Optional[float]=None
        ) ->None:
        """Start trace events collection.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param categories: **(DEPRECATED)** **(EXPERIMENTAL)** *(Optional)* Category/tag filter

:param options: **(DEPRECATED)** **(EXPERIMENTAL)** *(Optional)* Tracing options

:param buffer_usage_reporting_interval: **(EXPERIMENTAL)** *(Optional)* If set, the agent will issue bufferUsage events at this interval, specified in milliseconds

:param transfer_mode: *(Optional)* Whether to report trace events as series of dataCollected events or to save trace to a stream (defaults to ``ReportEvents``).

:param stream_format: *(Optional)* Trace data format to use. This only applies when using ``ReturnAsStream`` transfer mode (defaults to ``json``).

:param stream_compression: **(EXPERIMENTAL)** *(Optional)* Compression format to use. This only applies when using ``ReturnAsStream`` transfer mode (defaults to ``none``)

:param trace_config: *(Optional)*

:param perfetto_config: **(EXPERIMENTAL)** *(Optional)* Base64-encoded serialized perfetto.protos.TraceConfig protobuf message When specified, the parameters ``categories``, ``options``, ``traceConfig`` are ignored. (Encoded as a base64 string when passed over JSON)

:param tracing_backend: **(EXPERIMENTAL)** *(Optional)* Backend type (defaults to ``auto``)

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _tracing_module.start(categories=categories, options=options,
            buffer_usage_reporting_interval=buffer_usage_reporting_interval,
            transfer_mode=transfer_mode, stream_format=stream_format,
            stream_compression=stream_compression, trace_config=
            trace_config, perfetto_config=perfetto_config, tracing_backend=
            tracing_backend)
        return self.client.send(gen, _response_timeout=_response_timeout)
