# # DO NOT EDIT THIS FILE!
# #
# # This file is generated from the CDP specification using AST. If you need to make
# # changes, edit the generator and regenerate all of the modules.

from __future__ import annotations
"""API wrapper for the CSS domain."""
import typing
from ..util import CDPClient
from .. import css as _css_module
from .. import dom
from .. import page
None


class CssAPI:
    """Provides an API wrapper for the 'CSS' domain commands.

**EXPERIMENTAL**

Domain Description:
This domain exposes CSS read/write operations. All CSS objects (stylesheets, rules, and styles)
have an associated ``id`` used in subsequent operations on the related object. Each object type has
a specific ``id`` structure, and those are not interchangeable between objects of different types.
CSS objects can be loaded using the ``get*ForNode()`` calls (which accept a DOM node id). A client
can also keep track of stylesheets via the ``styleSheetAdded``/``styleSheetRemoved`` events and
subsequently load the required stylesheet contents using the ``getStyleSheet[Text]()`` methods."""

    def __init__(self, client: CDPClient) ->None:
        self.client: CDPClient = client

    def add_rule(self, style_sheet_id: _css_module.StyleSheetId, rule_text:
        str, location: _css_module.SourceRange,
        node_for_property_syntax_validation: typing.Optional[dom.NodeId]=
        None, _response_timeout: typing.Optional[float]=None
        ) ->_css_module.CSSRule:
        """Inserts a new rule with the given ``ruleText`` in a stylesheet with given ``styleSheetId``, at the
position specified by ``location``.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param style_sheet_id: The css style sheet identifier where a new rule should be inserted.

:param rule_text: The text of a new rule.

:param location: Text position of a new rule in the target style sheet.

:param node_for_property_syntax_validation: **(EXPERIMENTAL)** *(Optional)* NodeId for the DOM node in whose context custom property declarations for registered properties should be validated. If omitted, declarations in the new rule text can only be validated statically, which may produce incorrect results if the declaration contains a var() for example.

:param _response_timeout: Optional timeout in seconds for the command.


:returns: The newly created rule."""
        gen = _css_module.add_rule(style_sheet_id=style_sheet_id, rule_text
            =rule_text, location=location,
            node_for_property_syntax_validation=
            node_for_property_syntax_validation)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def collect_class_names(self, style_sheet_id: _css_module.StyleSheetId,
        _response_timeout: typing.Optional[float]=None) ->typing.List[str]:
        """Returns all class names from specified stylesheet.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param style_sheet_id:

:param _response_timeout: Optional timeout in seconds for the command.


:returns: Class name list."""
        gen = _css_module.collect_class_names(style_sheet_id=style_sheet_id)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def create_style_sheet(self, frame_id: page.FrameId, force: typing.
        Optional[bool]=None, _response_timeout: typing.Optional[float]=None
        ) ->_css_module.StyleSheetId:
        """Creates a new special "via-inspector" stylesheet in the frame with given ``frameId``.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param frame_id: Identifier of the frame where "via-inspector" stylesheet should be created.

:param force: *(Optional)* If true, creates a new stylesheet for every call. If false, returns a stylesheet previously created by a call with force=false for the frame's document if it exists or creates a new stylesheet (default: false).

:param _response_timeout: Optional timeout in seconds for the command.


:returns: Identifier of the created "via-inspector" stylesheet."""
        gen = _css_module.create_style_sheet(frame_id=frame_id, force=force)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def disable(self, _response_timeout: typing.Optional[float]=None) ->None:
        """Disables the CSS agent for the given page.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _css_module.disable()
        return self.client.send(gen, _response_timeout=_response_timeout)

    def enable(self, _response_timeout: typing.Optional[float]=None) ->None:
        """Enables the CSS agent for the given page. Clients should not assume that the CSS agent has been
enabled until the result of this command is received.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _css_module.enable()
        return self.client.send(gen, _response_timeout=_response_timeout)

    def force_pseudo_state(self, node_id: dom.NodeId, forced_pseudo_classes:
        typing.List[str], _response_timeout: typing.Optional[float]=None
        ) ->None:
        """Ensures that the given node will have specified pseudo-classes whenever its style is computed by
the browser.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param node_id: The element id for which to force the pseudo state.

:param forced_pseudo_classes: Element pseudo classes to force when computing the element's style.

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _css_module.force_pseudo_state(node_id=node_id,
            forced_pseudo_classes=forced_pseudo_classes)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def force_starting_style(self, node_id: dom.NodeId, forced: bool,
        _response_timeout: typing.Optional[float]=None) ->None:
        """Ensures that the given node is in its starting-style state.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param node_id: The element id for which to force the starting-style state.

:param forced: Boolean indicating if this is on or off.

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _css_module.force_starting_style(node_id=node_id, forced=forced)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def get_animated_styles_for_node(self, node_id: dom.NodeId,
        _response_timeout: typing.Optional[float]=None) ->typing.Tuple[
        typing.Optional[typing.List[_css_module.CSSAnimationStyle]], typing
        .Optional[_css_module.CSSStyle], typing.Optional[typing.List[
        _css_module.InheritedAnimatedStyleEntry]]]:
        """Returns the styles coming from animations & transitions
including the animation & transition styles coming from inheritance chain.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param node_id:

:param _response_timeout: Optional timeout in seconds for the command.


:returns: A tuple with the following items:

    1. **animationStyles** - *(Optional)* Styles coming from animations.
    2. **transitionsStyle** - *(Optional)* Style coming from transitions.
    3. **inherited** - *(Optional)* Inherited style entries for animationsStyle and transitionsStyle from the inheritance chain of the element."""
        gen = _css_module.get_animated_styles_for_node(node_id=node_id)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def get_background_colors(self, node_id: dom.NodeId, _response_timeout:
        typing.Optional[float]=None) ->typing.Tuple[typing.Optional[typing.
        List[str]], typing.Optional[str], typing.Optional[str]]:
        """NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param node_id: Id of the node to get background colors for.

:param _response_timeout: Optional timeout in seconds for the command.


:returns: A tuple with the following items:

    1. **backgroundColors** - *(Optional)* The range of background colors behind this element, if it contains any visible text. If no visible text is present, this will be undefined. In the case of a flat background color, this will consist of simply that color. In the case of a gradient, this will consist of each of the color stops. For anything more complicated, this will be an empty array. Images will be ignored (as if the image had failed to load).
    2. **computedFontSize** - *(Optional)* The computed font size for this node, as a CSS computed value string (e.g. '12px').
    3. **computedFontWeight** - *(Optional)* The computed font weight for this node, as a CSS computed value string (e.g. 'normal' or '100')."""
        gen = _css_module.get_background_colors(node_id=node_id)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def get_computed_style_for_node(self, node_id: dom.NodeId,
        _response_timeout: typing.Optional[float]=None) ->typing.List[
        _css_module.CSSComputedStyleProperty]:
        """Returns the computed style for a DOM node identified by ``nodeId``.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param node_id:

:param _response_timeout: Optional timeout in seconds for the command.


:returns: Computed style for the specified DOM node."""
        gen = _css_module.get_computed_style_for_node(node_id=node_id)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def get_inline_styles_for_node(self, node_id: dom.NodeId,
        _response_timeout: typing.Optional[float]=None) ->typing.Tuple[
        typing.Optional[_css_module.CSSStyle], typing.Optional[_css_module.
        CSSStyle]]:
        """Returns the styles defined inline (explicitly in the "style" attribute and implicitly, using DOM
attributes) for a DOM node identified by ``nodeId``.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param node_id:

:param _response_timeout: Optional timeout in seconds for the command.


:returns: A tuple with the following items:

    1. **inlineStyle** - *(Optional)* Inline style for the specified DOM node.
    2. **attributesStyle** - *(Optional)* Attribute-defined element style (e.g. resulting from "width=20 height=100%")."""
        gen = _css_module.get_inline_styles_for_node(node_id=node_id)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def get_layers_for_node(self, node_id: dom.NodeId, _response_timeout:
        typing.Optional[float]=None) ->_css_module.CSSLayerData:
        """Returns all layers parsed by the rendering engine for the tree scope of a node.
Given a DOM element identified by nodeId, getLayersForNode returns the root
layer for the nearest ancestor document or shadow root. The layer root contains
the full layer tree for the tree scope and their ordering.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param node_id:

:param _response_timeout: Optional timeout in seconds for the command.


:returns:"""
        gen = _css_module.get_layers_for_node(node_id=node_id)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def get_location_for_selector(self, style_sheet_id: _css_module.
        StyleSheetId, selector_text: str, _response_timeout: typing.
        Optional[float]=None) ->typing.List[_css_module.SourceRange]:
        """Given a CSS selector text and a style sheet ID, getLocationForSelector
returns an array of locations of the CSS selector in the style sheet.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param style_sheet_id:

:param selector_text:

:param _response_timeout: Optional timeout in seconds for the command.


:returns:"""
        gen = _css_module.get_location_for_selector(style_sheet_id=
            style_sheet_id, selector_text=selector_text)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def get_longhand_properties(self, shorthand_name: str, value: str,
        _response_timeout: typing.Optional[float]=None) ->typing.List[
        _css_module.CSSProperty]:
        """NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param shorthand_name:

:param value:

:param _response_timeout: Optional timeout in seconds for the command.


:returns:"""
        gen = _css_module.get_longhand_properties(shorthand_name=
            shorthand_name, value=value)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def get_matched_styles_for_node(self, node_id: dom.NodeId,
        _response_timeout: typing.Optional[float]=None) ->typing.Tuple[
        typing.Optional[_css_module.CSSStyle], typing.Optional[_css_module.
        CSSStyle], typing.Optional[typing.List[_css_module.RuleMatch]],
        typing.Optional[typing.List[_css_module.PseudoElementMatches]],
        typing.Optional[typing.List[_css_module.InheritedStyleEntry]],
        typing.Optional[typing.List[_css_module.
        InheritedPseudoElementMatches]], typing.Optional[typing.List[
        _css_module.CSSKeyframesRule]], typing.Optional[typing.List[
        _css_module.CSSPositionTryRule]], typing.Optional[int], typing.
        Optional[typing.List[_css_module.CSSPropertyRule]], typing.Optional
        [typing.List[_css_module.CSSPropertyRegistration]], typing.Optional
        [_css_module.CSSFontPaletteValuesRule], typing.Optional[dom.NodeId],
        typing.Optional[typing.List[_css_module.CSSFunctionRule]]]:
        """Returns requested styles for a DOM node identified by ``nodeId``.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param node_id:

:param _response_timeout: Optional timeout in seconds for the command.


:returns: A tuple with the following items:

    1. **inlineStyle** - *(Optional)* Inline style for the specified DOM node.
    2. **attributesStyle** - *(Optional)* Attribute-defined element style (e.g. resulting from "width=20 height=100%").
    3. **matchedCSSRules** - *(Optional)* CSS rules matching this node, from all applicable stylesheets.
    4. **pseudoElements** - *(Optional)* Pseudo style matches for this node.
    5. **inherited** - *(Optional)* A chain of inherited styles (from the immediate node parent up to the DOM tree root).
    6. **inheritedPseudoElements** - *(Optional)* A chain of inherited pseudo element styles (from the immediate node parent up to the DOM tree root).
    7. **cssKeyframesRules** - *(Optional)* A list of CSS keyframed animations matching this node.
    8. **cssPositionTryRules** - *(Optional)* A list of CSS @position-try rules matching this node, based on the position-try-fallbacks property.
    9. **activePositionFallbacTypeex** - *(Optional)* Index of the active fallback in the applied position-try-fallback property, will not be set if there is no active position-try fallback.
    10. **cssPropertyRules** - *(Optional)* A list of CSS at-property rules matching this node.
    11. **cssPropertyRegistrations** - *(Optional)* A list of CSS property registrations matching this node.
    12. **cssFontPaletteValuesRule** - *(Optional)* A font-palette-values rule matching this node.
    13. **parentLayoutNodeId** - *(Optional)* Id of the first parent element that does not have display: contents.
    14. **cssFunctionRules** - *(Optional)* A list of CSS at-function rules referenced by styles of this node."""
        gen = _css_module.get_matched_styles_for_node(node_id=node_id)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def get_media_queries(self, _response_timeout: typing.Optional[float]=None
        ) ->typing.List[_css_module.CSSMedia]:
        """Returns all media queries parsed by the rendering engine.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param _response_timeout: Optional timeout in seconds for the command.


:returns:"""
        gen = _css_module.get_media_queries()
        return self.client.send(gen, _response_timeout=_response_timeout)

    def get_platform_fonts_for_node(self, node_id: dom.NodeId,
        _response_timeout: typing.Optional[float]=None) ->typing.List[
        _css_module.PlatformFontUsage]:
        """Requests information about platform fonts which we used to render child TextNodes in the given
node.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param node_id:

:param _response_timeout: Optional timeout in seconds for the command.


:returns: Usage statistics for every employed platform font."""
        gen = _css_module.get_platform_fonts_for_node(node_id=node_id)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def get_style_sheet_text(self, style_sheet_id: _css_module.StyleSheetId,
        _response_timeout: typing.Optional[float]=None) ->str:
        """Returns the current textual content for a stylesheet.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param style_sheet_id:

:param _response_timeout: Optional timeout in seconds for the command.


:returns: The stylesheet text."""
        gen = _css_module.get_style_sheet_text(style_sheet_id=style_sheet_id)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def resolve_values(self, values: typing.List[str], node_id: dom.NodeId,
        property_name: typing.Optional[str]=None, pseudo_type: typing.
        Optional[dom.PseudoType]=None, pseudo_identifier: typing.Optional[
        str]=None, _response_timeout: typing.Optional[float]=None
        ) ->typing.List[str]:
        """Resolve the specified values in the context of the provided element.
For example, a value of '1em' is evaluated according to the computed
'font-size' of the element and a value 'calc(1px + 2px)' will be
resolved to '3px'.
If the ``propertyName`` was specified the ``values`` are resolved as if
they were property's declaration. If a value cannot be parsed according
to the provided property syntax, the value is parsed using combined
syntax as if null ``propertyName`` was provided. If the value cannot be
resolved even then, return the provided value without any changes.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param values: Substitution functions (var()/env()/attr()) and cascade-dependent keywords (revert/revert-layer) do not work.

:param node_id: Id of the node in whose context the expression is evaluated

:param property_name: *(Optional)* Only longhands and custom property names are accepted.

:param pseudo_type: *(Optional)* Pseudo element type, only works for pseudo elements that generate elements in the tree, such as ::before and ::after.

:param pseudo_identifier: *(Optional)* Pseudo element custom ident.

:param _response_timeout: Optional timeout in seconds for the command.


:returns:"""
        gen = _css_module.resolve_values(values=values, node_id=node_id,
            property_name=property_name, pseudo_type=pseudo_type,
            pseudo_identifier=pseudo_identifier)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def set_container_query_text(self, style_sheet_id: _css_module.
        StyleSheetId, range_: _css_module.SourceRange, text: str,
        _response_timeout: typing.Optional[float]=None
        ) ->_css_module.CSSContainerQuery:
        """Modifies the expression of a container query.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param style_sheet_id:

:param range_:

:param text:

:param _response_timeout: Optional timeout in seconds for the command.


:returns: The resulting CSS container query rule after modification."""
        gen = _css_module.set_container_query_text(style_sheet_id=
            style_sheet_id, range_=range_, text=text)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def set_effective_property_value_for_node(self, node_id: dom.NodeId,
        property_name: str, value: str, _response_timeout: typing.Optional[
        float]=None) ->None:
        """Find a rule with the given active property for the given node and set the new value for this
property

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param node_id: The element id for which to set property.

:param property_name:

:param value:

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _css_module.set_effective_property_value_for_node(node_id=
            node_id, property_name=property_name, value=value)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def set_keyframe_key(self, style_sheet_id: _css_module.StyleSheetId,
        range_: _css_module.SourceRange, key_text: str, _response_timeout:
        typing.Optional[float]=None) ->_css_module.Value:
        """Modifies the keyframe rule key text.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param style_sheet_id:

:param range_:

:param key_text:

:param _response_timeout: Optional timeout in seconds for the command.


:returns: The resulting key text after modification."""
        gen = _css_module.set_keyframe_key(style_sheet_id=style_sheet_id,
            range_=range_, key_text=key_text)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def set_local_fonts_enabled(self, enabled: bool, _response_timeout:
        typing.Optional[float]=None) ->None:
        """Enables/disables rendering of local CSS fonts (enabled by default).

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param enabled: Whether rendering of local fonts is enabled.

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _css_module.set_local_fonts_enabled(enabled=enabled)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def set_media_text(self, style_sheet_id: _css_module.StyleSheetId,
        range_: _css_module.SourceRange, text: str, _response_timeout:
        typing.Optional[float]=None) ->_css_module.CSSMedia:
        """Modifies the rule selector.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param style_sheet_id:

:param range_:

:param text:

:param _response_timeout: Optional timeout in seconds for the command.


:returns: The resulting CSS media rule after modification."""
        gen = _css_module.set_media_text(style_sheet_id=style_sheet_id,
            range_=range_, text=text)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def set_property_rule_property_name(self, style_sheet_id: _css_module.
        StyleSheetId, range_: _css_module.SourceRange, property_name: str,
        _response_timeout: typing.Optional[float]=None) ->_css_module.Value:
        """Modifies the property rule property name.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param style_sheet_id:

:param range_:

:param property_name:

:param _response_timeout: Optional timeout in seconds for the command.


:returns: The resulting key text after modification."""
        gen = _css_module.set_property_rule_property_name(style_sheet_id=
            style_sheet_id, range_=range_, property_name=property_name)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def set_rule_selector(self, style_sheet_id: _css_module.StyleSheetId,
        range_: _css_module.SourceRange, selector: str, _response_timeout:
        typing.Optional[float]=None) ->_css_module.SelectorList:
        """Modifies the rule selector.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param style_sheet_id:

:param range_:

:param selector:

:param _response_timeout: Optional timeout in seconds for the command.


:returns: The resulting selector list after modification."""
        gen = _css_module.set_rule_selector(style_sheet_id=style_sheet_id,
            range_=range_, selector=selector)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def set_scope_text(self, style_sheet_id: _css_module.StyleSheetId,
        range_: _css_module.SourceRange, text: str, _response_timeout:
        typing.Optional[float]=None) ->_css_module.CSSScope:
        """Modifies the expression of a scope at-rule.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param style_sheet_id:

:param range_:

:param text:

:param _response_timeout: Optional timeout in seconds for the command.


:returns: The resulting CSS Scope rule after modification."""
        gen = _css_module.set_scope_text(style_sheet_id=style_sheet_id,
            range_=range_, text=text)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def set_style_sheet_text(self, style_sheet_id: _css_module.StyleSheetId,
        text: str, _response_timeout: typing.Optional[float]=None
        ) ->typing.Optional[str]:
        """Sets the new stylesheet text.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param style_sheet_id:

:param text:

:param _response_timeout: Optional timeout in seconds for the command.


:returns: *(Optional)* URL of source map associated with script (if any)."""
        gen = _css_module.set_style_sheet_text(style_sheet_id=
            style_sheet_id, text=text)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def set_style_texts(self, edits: typing.List[_css_module.
        StyleDeclarationEdit], node_for_property_syntax_validation: typing.
        Optional[dom.NodeId]=None, _response_timeout: typing.Optional[float
        ]=None) ->typing.List[_css_module.CSSStyle]:
        """Applies specified style edits one after another in the given order.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param edits:

:param node_for_property_syntax_validation: **(EXPERIMENTAL)** *(Optional)* NodeId for the DOM node in whose context custom property declarations for registered properties should be validated. If omitted, declarations in the new rule text can only be validated statically, which may produce incorrect results if the declaration contains a var() for example.

:param _response_timeout: Optional timeout in seconds for the command.


:returns: The resulting styles after modification."""
        gen = _css_module.set_style_texts(edits=edits,
            node_for_property_syntax_validation=
            node_for_property_syntax_validation)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def set_supports_text(self, style_sheet_id: _css_module.StyleSheetId,
        range_: _css_module.SourceRange, text: str, _response_timeout:
        typing.Optional[float]=None) ->_css_module.CSSSupports:
        """Modifies the expression of a supports at-rule.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param style_sheet_id:

:param range_:

:param text:

:param _response_timeout: Optional timeout in seconds for the command.


:returns: The resulting CSS Supports rule after modification."""
        gen = _css_module.set_supports_text(style_sheet_id=style_sheet_id,
            range_=range_, text=text)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def start_rule_usage_tracking(self, _response_timeout: typing.Optional[
        float]=None) ->None:
        """Enables the selector recording.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _css_module.start_rule_usage_tracking()
        return self.client.send(gen, _response_timeout=_response_timeout)

    def stop_rule_usage_tracking(self, _response_timeout: typing.Optional[
        float]=None) ->typing.List[_css_module.RuleUsage]:
        """Stop tracking rule usage and return the list of rules that were used since last call to
``takeCoverageDelta`` (or since start of coverage instrumentation).

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param _response_timeout: Optional timeout in seconds for the command.


:returns:"""
        gen = _css_module.stop_rule_usage_tracking()
        return self.client.send(gen, _response_timeout=_response_timeout)

    def take_computed_style_updates(self, _response_timeout: typing.
        Optional[float]=None) ->typing.List[dom.NodeId]:
        """Polls the next batch of computed style updates.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param _response_timeout: Optional timeout in seconds for the command.


:returns: The list of node Ids that have their tracked computed styles updated."""
        gen = _css_module.take_computed_style_updates()
        return self.client.send(gen, _response_timeout=_response_timeout)

    def take_coverage_delta(self, _response_timeout: typing.Optional[float]
        =None) ->typing.Tuple[typing.List[_css_module.RuleUsage], float]:
        """Obtain list of rules that became used since last call to this method (or since start of coverage
instrumentation).

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param _response_timeout: Optional timeout in seconds for the command.


:returns: A tuple with the following items:

    1. **coverage** - 
    2. **timestamp** - Monotonically increasing time, in seconds."""
        gen = _css_module.take_coverage_delta()
        return self.client.send(gen, _response_timeout=_response_timeout)

    def track_computed_style_updates(self, properties_to_track: typing.List
        [_css_module.CSSComputedStyleProperty], _response_timeout: typing.
        Optional[float]=None) ->None:
        """Starts tracking the given computed styles for updates. The specified array of properties
replaces the one previously specified. Pass empty array to disable tracking.
Use takeComputedStyleUpdates to retrieve the list of nodes that had properties modified.
The changes to computed style properties are only tracked for nodes pushed to the front-end
by the DOM agent. If no changes to the tracked properties occur after the node has been pushed
to the front-end, no updates will be issued for the node.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param properties_to_track:

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _css_module.track_computed_style_updates(properties_to_track=
            properties_to_track)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def track_computed_style_updates_for_node(self, node_id: typing.
        Optional[dom.NodeId]=None, _response_timeout: typing.Optional[float
        ]=None) ->None:
        """Starts tracking the given node for the computed style updates
and whenever the computed style is updated for node, it queues
a ``computedStyleUpdated`` event with throttling.
There can only be 1 node tracked for computed style updates
so passing a new node id removes tracking from the previous node.
Pass ``undefined`` to disable tracking.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param node_id: *(Optional)*

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _css_module.track_computed_style_updates_for_node(node_id=node_id
            )
        return self.client.send(gen, _response_timeout=_response_timeout)
