# # DO NOT EDIT THIS FILE!
# #
# # This file is generated from the CDP specification using AST. If you need to make
# # changes, edit the generator and regenerate all of the modules.

from __future__ import annotations
"""API wrapper for the Network domain."""
import typing
from ..util import CDPClient
from .. import network as _network_module
from .. import debugger
from .. import emulation
from .. import io
from .. import page
from deprecated.sphinx import deprecated
None


class NetworkAPI:
    """Provides an API wrapper for the 'Network' domain commands.

Domain Description:
Network domain allows tracking network activities of the page. It exposes information about http,
file, data and other requests and responses, their headers, bodies, timing, etc."""

    def __init__(self, client: CDPClient) ->None:
        self.client: CDPClient = client

    @deprecated(version='1.3')
    def can_clear_browser_cache(self, _response_timeout: typing.Optional[
        float]=None) ->bool:
        """Tells whether clearing browser cache is supported.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

.. deprecated:: 1.3


:param ...:

:param _response_timeout: Optional timeout in seconds for the command.


:returns: True if browser cache can be cleared."""
        gen = _network_module.can_clear_browser_cache()
        return self.client.send(gen, _response_timeout=_response_timeout)

    @deprecated(version='1.3')
    def can_clear_browser_cookies(self, _response_timeout: typing.Optional[
        float]=None) ->bool:
        """Tells whether clearing browser cookies is supported.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

.. deprecated:: 1.3


:param ...:

:param _response_timeout: Optional timeout in seconds for the command.


:returns: True if browser cookies can be cleared."""
        gen = _network_module.can_clear_browser_cookies()
        return self.client.send(gen, _response_timeout=_response_timeout)

    @deprecated(version='1.3')
    def can_emulate_network_conditions(self, _response_timeout: typing.
        Optional[float]=None) ->bool:
        """Tells whether emulation of network conditions is supported.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

.. deprecated:: 1.3


:param ...:

:param _response_timeout: Optional timeout in seconds for the command.


:returns: True if emulation of network conditions is supported."""
        gen = _network_module.can_emulate_network_conditions()
        return self.client.send(gen, _response_timeout=_response_timeout)

    def clear_accepted_encodings_override(self, _response_timeout: typing.
        Optional[float]=None) ->None:
        """Clears accepted encodings set by setAcceptedEncodings

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _network_module.clear_accepted_encodings_override()
        return self.client.send(gen, _response_timeout=_response_timeout)

    def clear_browser_cache(self, _response_timeout: typing.Optional[float]
        =None) ->None:
        """Clears browser cache.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _network_module.clear_browser_cache()
        return self.client.send(gen, _response_timeout=_response_timeout)

    def clear_browser_cookies(self, _response_timeout: typing.Optional[
        float]=None) ->None:
        """Clears browser cookies.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _network_module.clear_browser_cookies()
        return self.client.send(gen, _response_timeout=_response_timeout)

    @deprecated(version='1.3')
    def continue_intercepted_request(self, interception_id: _network_module
        .InterceptionId, error_reason: typing.Optional[_network_module.
        ErrorReason]=None, raw_response: typing.Optional[str]=None, url:
        typing.Optional[str]=None, method: typing.Optional[str]=None,
        post_data: typing.Optional[str]=None, headers: typing.Optional[
        _network_module.Headers]=None, auth_challenge_response: typing.
        Optional[_network_module.AuthChallengeResponse]=None,
        _response_timeout: typing.Optional[float]=None) ->None:
        """Response to Network.requestIntercepted which either modifies the request to continue with any
modifications, or blocks it, or completes it with the provided response bytes. If a network
fetch occurs as a result which encounters a redirect an additional Network.requestIntercepted
event will be sent with the same InterceptionId.
Deprecated, use Fetch.continueRequest, Fetch.fulfillRequest and Fetch.failRequest instead.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

.. deprecated:: 1.3

**EXPERIMENTAL**


:param ...:

:param interception_id:

:param error_reason: *(Optional)* If set this causes the request to fail with the given reason. Passing ``Aborted`` for requests marked with ``isNavigationRequest`` also cancels the navigation. Must not be set in response to an authChallenge.

:param raw_response: *(Optional)* If set the requests completes using with the provided base64 encoded raw response, including HTTP status line and headers etc... Must not be set in response to an authChallenge. (Encoded as a base64 string when passed over JSON)

:param url: *(Optional)* If set the request url will be modified in a way that's not observable by page. Must not be set in response to an authChallenge.

:param method: *(Optional)* If set this allows the request method to be overridden. Must not be set in response to an authChallenge.

:param post_data: *(Optional)* If set this allows postData to be set. Must not be set in response to an authChallenge.

:param headers: *(Optional)* If set this allows the request headers to be changed. Must not be set in response to an authChallenge.

:param auth_challenge_response: *(Optional)* Response to a requestIntercepted with an authChallenge. Must not be set otherwise.

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _network_module.continue_intercepted_request(interception_id=
            interception_id, error_reason=error_reason, raw_response=
            raw_response, url=url, method=method, post_data=post_data,
            headers=headers, auth_challenge_response=auth_challenge_response)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def delete_cookies(self, name: str, url: typing.Optional[str]=None,
        domain: typing.Optional[str]=None, path: typing.Optional[str]=None,
        partition_key: typing.Optional[_network_module.CookiePartitionKey]=
        None, _response_timeout: typing.Optional[float]=None) ->None:
        """Deletes browser cookies with matching name and url or domain/path/partitionKey pair.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param name: Name of the cookies to remove.

:param url: *(Optional)* If specified, deletes all the cookies with the given name where domain and path match provided URL.

:param domain: *(Optional)* If specified, deletes only cookies with the exact domain.

:param path: *(Optional)* If specified, deletes only cookies with the exact path.

:param partition_key: **(EXPERIMENTAL)** *(Optional)* If specified, deletes only cookies with the the given name and partitionKey where all partition key attributes match the cookie partition key attribute.

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _network_module.delete_cookies(name=name, url=url, domain=
            domain, path=path, partition_key=partition_key)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def disable(self, _response_timeout: typing.Optional[float]=None) ->None:
        """Disables network tracking, prevents network events from being sent to the client.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _network_module.disable()
        return self.client.send(gen, _response_timeout=_response_timeout)

    def emulate_network_conditions(self, offline: bool, latency: float,
        download_throughput: float, upload_throughput: float,
        connection_type: typing.Optional[_network_module.ConnectionType]=
        None, packet_loss: typing.Optional[float]=None, packet_queue_length:
        typing.Optional[int]=None, packet_reordering: typing.Optional[bool]
        =None, _response_timeout: typing.Optional[float]=None) ->None:
        """Activates emulation of network conditions.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param offline: True to emulate internet disconnection.

:param latency: Minimum latency from request sent to response headers received (ms).

:param download_throughput: Maximal aggregated download throughput (bytes/sec). -1 disables download throttling.

:param upload_throughput: Maximal aggregated upload throughput (bytes/sec).  -1 disables upload throttling.

:param connection_type: *(Optional)* Connection type if known.

:param packet_loss: **(EXPERIMENTAL)** *(Optional)* WebRTC packet loss (percent, 0-100). 0 disables packet loss emulation, 100 drops all the packets.

:param packet_queue_length: **(EXPERIMENTAL)** *(Optional)* WebRTC packet queue length (packet). 0 removes any queue length limitations.

:param packet_reordering: **(EXPERIMENTAL)** *(Optional)* WebRTC packetReordering feature.

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _network_module.emulate_network_conditions(offline=offline,
            latency=latency, download_throughput=download_throughput,
            upload_throughput=upload_throughput, connection_type=
            connection_type, packet_loss=packet_loss, packet_queue_length=
            packet_queue_length, packet_reordering=packet_reordering)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def enable(self, max_total_buffer_size: typing.Optional[int]=None,
        max_resource_buffer_size: typing.Optional[int]=None,
        max_post_data_size: typing.Optional[int]=None, _response_timeout:
        typing.Optional[float]=None) ->None:
        """Enables network tracking, network events will now be delivered to the client.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param max_total_buffer_size: **(EXPERIMENTAL)** *(Optional)* Buffer size in bytes to use when preserving network payloads (XHRs, etc).

:param max_resource_buffer_size: **(EXPERIMENTAL)** *(Optional)* Per-resource buffer size in bytes to use when preserving network payloads (XHRs, etc).

:param max_post_data_size: *(Optional)* Longest post body size (in bytes) that would be included in requestWillBeSent notification

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _network_module.enable(max_total_buffer_size=
            max_total_buffer_size, max_resource_buffer_size=
            max_resource_buffer_size, max_post_data_size=max_post_data_size)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def enable_reporting_api(self, enable: bool, _response_timeout: typing.
        Optional[float]=None) ->None:
        """Enables tracking for the Reporting API, events generated by the Reporting API will now be delivered to the client.
Enabling triggers 'reportingApiReportAdded' for all existing reports.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param enable: Whether to enable or disable events for the Reporting API

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _network_module.enable_reporting_api(enable=enable)
        return self.client.send(gen, _response_timeout=_response_timeout)

    @deprecated(version='1.3')
    def get_all_cookies(self, _response_timeout: typing.Optional[float]=None
        ) ->typing.List[_network_module.Cookie]:
        """Returns all browser cookies. Depending on the backend support, will return detailed cookie
information in the ``cookies`` field.
Deprecated. Use Storage.getCookies instead.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

.. deprecated:: 1.3


:param ...:

:param _response_timeout: Optional timeout in seconds for the command.


:returns: Array of cookie objects."""
        gen = _network_module.get_all_cookies()
        return self.client.send(gen, _response_timeout=_response_timeout)

    def get_certificate(self, origin: str, _response_timeout: typing.
        Optional[float]=None) ->typing.List[str]:
        """Returns the DER-encoded certificate.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param origin: Origin to get certificate for.

:param _response_timeout: Optional timeout in seconds for the command.


:returns:"""
        gen = _network_module.get_certificate(origin=origin)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def get_cookies(self, urls: typing.Optional[typing.List[str]]=None,
        _response_timeout: typing.Optional[float]=None) ->typing.List[
        _network_module.Cookie]:
        """Returns all browser cookies for the current URL. Depending on the backend support, will return
detailed cookie information in the ``cookies`` field.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param urls: *(Optional)* The list of URLs for which applicable cookies will be fetched. If not specified, it's assumed to be set to the list containing the URLs of the page and all of its subframes.

:param _response_timeout: Optional timeout in seconds for the command.


:returns: Array of cookie objects."""
        gen = _network_module.get_cookies(urls=urls)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def get_request_post_data(self, request_id: _network_module.RequestId,
        _response_timeout: typing.Optional[float]=None) ->str:
        """Returns post data sent with the request. Returns an error when no data was sent with the request.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param request_id: Identifier of the network request to get content for.

:param _response_timeout: Optional timeout in seconds for the command.


:returns: Request body string, omitting files from multipart requests"""
        gen = _network_module.get_request_post_data(request_id=request_id)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def get_response_body(self, request_id: _network_module.RequestId,
        _response_timeout: typing.Optional[float]=None) ->typing.Tuple[str,
        bool]:
        """Returns content served for the given request.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param request_id: Identifier of the network request to get content for.

:param _response_timeout: Optional timeout in seconds for the command.


:returns: A tuple with the following items:

    1. **body** - Response body.
    2. **base64Encoded** - True, if content was sent as base64."""
        gen = _network_module.get_response_body(request_id=request_id)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def get_response_body_for_interception(self, interception_id:
        _network_module.InterceptionId, _response_timeout: typing.Optional[
        float]=None) ->typing.Tuple[str, bool]:
        """Returns content served for the given currently intercepted request.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param interception_id: Identifier for the intercepted request to get body for.

:param _response_timeout: Optional timeout in seconds for the command.


:returns: A tuple with the following items:

    1. **body** - Response body.
    2. **base64Encoded** - True, if content was sent as base64."""
        gen = _network_module.get_response_body_for_interception(
            interception_id=interception_id)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def get_security_isolation_status(self, frame_id: typing.Optional[page.
        FrameId]=None, _response_timeout: typing.Optional[float]=None
        ) ->_network_module.SecurityIsolationStatus:
        """Returns information about the COEP/COOP isolation status.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param frame_id: *(Optional)* If no frameId is provided, the status of the target is provided.

:param _response_timeout: Optional timeout in seconds for the command.


:returns:"""
        gen = _network_module.get_security_isolation_status(frame_id=frame_id)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def load_network_resource(self, url: str, options: _network_module.
        LoadNetworkResourceOptions, frame_id: typing.Optional[page.FrameId]
        =None, _response_timeout: typing.Optional[float]=None
        ) ->_network_module.LoadNetworkResourcePageResult:
        """Fetches the resource and returns the content.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param url: URL of the resource to get content for.

:param options: Options for the request.

:param frame_id: *(Optional)* Frame id to get the resource for. Mandatory for frame targets, and should be omitted for worker targets.

:param _response_timeout: Optional timeout in seconds for the command.


:returns:"""
        gen = _network_module.load_network_resource(url=url, options=
            options, frame_id=frame_id)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def replay_xhr(self, request_id: _network_module.RequestId,
        _response_timeout: typing.Optional[float]=None) ->None:
        """This method sends a new XMLHttpRequest which is identical to the original one. The following
parameters should be identical: method, url, async, request body, extra headers, withCredentials
attribute, user, password.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param request_id: Identifier of XHR to replay.

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _network_module.replay_xhr(request_id=request_id)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def search_in_response_body(self, request_id: _network_module.RequestId,
        query: str, case_sensitive: typing.Optional[bool]=None, is_regex:
        typing.Optional[bool]=None, _response_timeout: typing.Optional[
        float]=None) ->typing.List[debugger.SearchMatch]:
        """Searches for given string in response content.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param request_id: Identifier of the network response to search.

:param query: String to search for.

:param case_sensitive: *(Optional)* If true, search is case sensitive.

:param is_regex: *(Optional)* If true, treats string parameter as regex.

:param _response_timeout: Optional timeout in seconds for the command.


:returns: List of search matches."""
        gen = _network_module.search_in_response_body(request_id=request_id,
            query=query, case_sensitive=case_sensitive, is_regex=is_regex)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def set_accepted_encodings(self, encodings: typing.List[_network_module
        .ContentEncoding], _response_timeout: typing.Optional[float]=None
        ) ->None:
        """Sets a list of content encodings that will be accepted. Empty list means no encoding is accepted.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param encodings: List of accepted content encodings.

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _network_module.set_accepted_encodings(encodings=encodings)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def set_attach_debug_stack(self, enabled: bool, _response_timeout:
        typing.Optional[float]=None) ->None:
        """Specifies whether to attach a page script stack id in requests

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param enabled: Whether to attach a page script stack for debugging purpose.

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _network_module.set_attach_debug_stack(enabled=enabled)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def set_blocked_ur_ls(self, urls: typing.List[str], _response_timeout:
        typing.Optional[float]=None) ->None:
        """Blocks URLs from loading.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param urls: URL patterns to block. Wildcards ('*') are allowed.

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _network_module.set_blocked_ur_ls(urls=urls)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def set_bypass_service_worker(self, bypass: bool, _response_timeout:
        typing.Optional[float]=None) ->None:
        """Toggles ignoring of service worker for each request.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param bypass: Bypass service worker and load from network.

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _network_module.set_bypass_service_worker(bypass=bypass)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def set_cache_disabled(self, cache_disabled: bool, _response_timeout:
        typing.Optional[float]=None) ->None:
        """Toggles ignoring cache for each request. If ``true``, cache will not be used.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param cache_disabled: Cache disabled state.

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _network_module.set_cache_disabled(cache_disabled=cache_disabled)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def set_cookie(self, name: str, value: str, url: typing.Optional[str]=
        None, domain: typing.Optional[str]=None, path: typing.Optional[str]
        =None, secure: typing.Optional[bool]=None, http_only: typing.
        Optional[bool]=None, same_site: typing.Optional[_network_module.
        CookieSameSite]=None, expires: typing.Optional[_network_module.
        TimeSinceEpoch]=None, priority: typing.Optional[_network_module.
        CookiePriority]=None, same_party: typing.Optional[bool]=None,
        source_scheme: typing.Optional[_network_module.CookieSourceScheme]=
        None, source_port: typing.Optional[int]=None, partition_key: typing
        .Optional[_network_module.CookiePartitionKey]=None,
        _response_timeout: typing.Optional[float]=None) ->bool:
        """Sets a cookie with the given cookie data; may overwrite equivalent cookies if they exist.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param name: Cookie name.

:param value: Cookie value.

:param url: *(Optional)* The request-URI to associate with the setting of the cookie. This value can affect the default domain, path, source port, and source scheme values of the created cookie.

:param domain: *(Optional)* Cookie domain.

:param path: *(Optional)* Cookie path.

:param secure: *(Optional)* True if cookie is secure.

:param http_only: *(Optional)* True if cookie is http-only.

:param same_site: *(Optional)* Cookie SameSite type.

:param expires: *(Optional)* Cookie expiration date, session cookie if not set

:param priority: **(EXPERIMENTAL)** *(Optional)* Cookie Priority type.

:param same_party: **(EXPERIMENTAL)** *(Optional)* True if cookie is SameParty.

:param source_scheme: **(EXPERIMENTAL)** *(Optional)* Cookie source scheme type.

:param source_port: **(EXPERIMENTAL)** *(Optional)* Cookie source port. Valid values are {-1, [1, 65535]}, -1 indicates an unspecified port. An unspecified port value allows protocol clients to emulate legacy cookie scope for the port. This is a temporary ability and it will be removed in the future.

:param partition_key: **(EXPERIMENTAL)** *(Optional)* Cookie partition key. If not set, the cookie will be set as not partitioned.

:param _response_timeout: Optional timeout in seconds for the command.


:returns: Always set to true. If an error occurs, the response indicates protocol error."""
        gen = _network_module.set_cookie(name=name, value=value, url=url,
            domain=domain, path=path, secure=secure, http_only=http_only,
            same_site=same_site, expires=expires, priority=priority,
            same_party=same_party, source_scheme=source_scheme, source_port
            =source_port, partition_key=partition_key)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def set_cookie_controls(self, enable_third_party_cookie_restriction:
        bool, disable_third_party_cookie_metadata: bool,
        disable_third_party_cookie_heuristics: bool, _response_timeout:
        typing.Optional[float]=None) ->None:
        """Sets Controls for third-party cookie access
Page reload is required before the new cookie bahavior will be observed

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param enable_third_party_cookie_restriction: Whether 3pc restriction is enabled.

:param disable_third_party_cookie_metadata: Whether 3pc grace period exception should be enabled; false by default.

:param disable_third_party_cookie_heuristics: Whether 3pc heuristics exceptions should be enabled; false by default.

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _network_module.set_cookie_controls(
            enable_third_party_cookie_restriction=
            enable_third_party_cookie_restriction,
            disable_third_party_cookie_metadata=
            disable_third_party_cookie_metadata,
            disable_third_party_cookie_heuristics=
            disable_third_party_cookie_heuristics)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def set_cookies(self, cookies: typing.List[_network_module.CookieParam],
        _response_timeout: typing.Optional[float]=None) ->None:
        """Sets given cookies.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param cookies: Cookies to be set.

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _network_module.set_cookies(cookies=cookies)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def set_extra_http_headers(self, headers: _network_module.Headers,
        _response_timeout: typing.Optional[float]=None) ->None:
        """Specifies whether to always send extra HTTP headers with the requests from this page.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param headers: Map with extra HTTP headers.

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _network_module.set_extra_http_headers(headers=headers)
        return self.client.send(gen, _response_timeout=_response_timeout)

    @deprecated(version='1.3')
    def set_request_interception(self, patterns: typing.List[
        _network_module.RequestPattern], _response_timeout: typing.Optional
        [float]=None) ->None:
        """Sets the requests to intercept that match the provided patterns and optionally resource types.
Deprecated, please use Fetch.enable instead.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

.. deprecated:: 1.3

**EXPERIMENTAL**


:param ...:

:param patterns: Requests matching any of these patterns will be forwarded and wait for the corresponding continueInterceptedRequest call.

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _network_module.set_request_interception(patterns=patterns)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def set_user_agent_override(self, user_agent: str, accept_language:
        typing.Optional[str]=None, platform: typing.Optional[str]=None,
        user_agent_metadata: typing.Optional[emulation.UserAgentMetadata]=
        None, _response_timeout: typing.Optional[float]=None) ->None:
        """Allows overriding user agent with the given string.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

Redirects to command 'Emulation'.


:param ...:

:param user_agent: User agent to use.

:param accept_language: *(Optional)* Browser language to emulate.

:param platform: *(Optional)* The platform navigator.platform should return.

:param user_agent_metadata: **(EXPERIMENTAL)** *(Optional)* To be sent in Sec-CH-UA-* headers and returned in navigator.userAgentData

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _network_module.set_user_agent_override(user_agent=user_agent,
            accept_language=accept_language, platform=platform,
            user_agent_metadata=user_agent_metadata)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def stream_resource_content(self, request_id: _network_module.RequestId,
        _response_timeout: typing.Optional[float]=None) ->str:
        """Enables streaming of the response for the given requestId.
If enabled, the dataReceived event contains the data that was received during streaming.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param request_id: Identifier of the request to stream.

:param _response_timeout: Optional timeout in seconds for the command.


:returns: Data that has been buffered until streaming is enabled. (Encoded as a base64 string when passed over JSON)"""
        gen = _network_module.stream_resource_content(request_id=request_id)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def take_response_body_for_interception_as_stream(self, interception_id:
        _network_module.InterceptionId, _response_timeout: typing.Optional[
        float]=None) ->io.StreamHandle:
        """Returns a handle to the stream representing the response body. Note that after this command,
the intercepted request can't be continued as is -- you either need to cancel it or to provide
the response body. The stream only supports sequential read, IO.read will fail if the position
is specified.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param interception_id:

:param _response_timeout: Optional timeout in seconds for the command.


:returns:"""
        gen = _network_module.take_response_body_for_interception_as_stream(
            interception_id=interception_id)
        return self.client.send(gen, _response_timeout=_response_timeout)
