# # DO NOT EDIT THIS FILE!
# #
# # This file is generated from the CDP specification using AST. If you need to make
# # changes, edit the generator and regenerate all of the modules.

from __future__ import annotations
"""API wrapper for the Target domain."""
import typing
from ..util import CDPClient
from .. import target as _target_module
from .. import browser
from deprecated.sphinx import deprecated
None


class TargetAPI:
    """Provides an API wrapper for the 'Target' domain commands.

Domain Description:
Supports additional targets discovery and allows to attach to them."""

    def __init__(self, client: CDPClient) ->None:
        self.client: CDPClient = client

    def activate_target(self, target_id: _target_module.TargetID,
        _response_timeout: typing.Optional[float]=None) ->None:
        """Activates (focuses) the target.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param target_id:

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _target_module.activate_target(target_id=target_id)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def attach_to_browser_target(self, _response_timeout: typing.Optional[
        float]=None) ->_target_module.SessionID:
        """Attaches to the browser target, only uses flat sessionId mode.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param _response_timeout: Optional timeout in seconds for the command.


:returns: Id assigned to the session."""
        gen = _target_module.attach_to_browser_target()
        return self.client.send(gen, _response_timeout=_response_timeout)

    def attach_to_target(self, target_id: _target_module.TargetID, flatten:
        typing.Optional[bool]=None, _response_timeout: typing.Optional[
        float]=None) ->_target_module.SessionID:
        """Attaches to the target with given id.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param target_id:

:param flatten: *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.

:param _response_timeout: Optional timeout in seconds for the command.


:returns: Id assigned to the session."""
        gen = _target_module.attach_to_target(target_id=target_id, flatten=
            flatten)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def auto_attach_related(self, target_id: _target_module.TargetID,
        wait_for_debugger_on_start: bool, filter_: typing.Optional[
        _target_module.TargetFilter]=None, _response_timeout: typing.
        Optional[float]=None) ->None:
        """Adds the specified target to the list of targets that will be monitored for any related target
creation (such as child frames, child workers and new versions of service worker) and reported
through ``attachedToTarget``. The specified target is also auto-attached.
This cancels the effect of any previous ``setAutoAttach`` and is also cancelled by subsequent
``setAutoAttach``. Only available at the Browser target.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param target_id:

:param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ``Runtime.runIfWaitingForDebugger`` to run paused targets.

:param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _target_module.auto_attach_related(target_id=target_id,
            wait_for_debugger_on_start=wait_for_debugger_on_start, filter_=
            filter_)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def close_target(self, target_id: _target_module.TargetID,
        _response_timeout: typing.Optional[float]=None) ->bool:
        """Closes the target. If the target is a page that gets closed too.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param target_id:

:param _response_timeout: Optional timeout in seconds for the command.


:returns: Always set to true. If an error occurs, the response indicates protocol error."""
        gen = _target_module.close_target(target_id=target_id)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def create_browser_context(self, dispose_on_detach: typing.Optional[
        bool]=None, proxy_server: typing.Optional[str]=None,
        proxy_bypass_list: typing.Optional[str]=None,
        origins_with_universal_network_access: typing.Optional[typing.List[
        str]]=None, _response_timeout: typing.Optional[float]=None
        ) ->browser.BrowserContextID:
        """Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
one.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param dispose_on_detach: **(EXPERIMENTAL)** *(Optional)* If specified, disposes this context when debugging session disconnects.

:param proxy_server: **(EXPERIMENTAL)** *(Optional)* Proxy server, similar to the one passed to --proxy-server

:param proxy_bypass_list: **(EXPERIMENTAL)** *(Optional)* Proxy bypass list, similar to the one passed to --proxy-bypass-list

:param origins_with_universal_network_access: **(EXPERIMENTAL)** *(Optional)* An optional list of origins to grant unlimited cross-origin access to. Parts of the URL other than those constituting origin are ignored.

:param _response_timeout: Optional timeout in seconds for the command.


:returns: The id of the context created."""
        gen = _target_module.create_browser_context(dispose_on_detach=
            dispose_on_detach, proxy_server=proxy_server, proxy_bypass_list
            =proxy_bypass_list, origins_with_universal_network_access=
            origins_with_universal_network_access)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def create_target(self, url: str, left: typing.Optional[int]=None, top:
        typing.Optional[int]=None, width: typing.Optional[int]=None, height:
        typing.Optional[int]=None, window_state: typing.Optional[
        _target_module.WindowState]=None, browser_context_id: typing.
        Optional[browser.BrowserContextID]=None, enable_begin_frame_control:
        typing.Optional[bool]=None, new_window: typing.Optional[bool]=None,
        background: typing.Optional[bool]=None, for_tab: typing.Optional[
        bool]=None, hidden: typing.Optional[bool]=None, _response_timeout:
        typing.Optional[float]=None) ->_target_module.TargetID:
        """Creates a new page.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param url: The initial URL the page will be navigated to. An empty string indicates about:blank.

:param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).

:param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).

:param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).

:param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).

:param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.

:param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.

:param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).

:param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).

:param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).

:param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".

:param hidden: **(EXPERIMENTAL)** *(Optional)* Whether to create a hidden target. The hidden target is observable via protocol, but not present in the tab UI strip. Cannot be created with ``forTab: true``, ``newWindow: true`` or ``background: false``. The life-time of the tab is limited to the life-time of the session.

:param _response_timeout: Optional timeout in seconds for the command.


:returns: The id of the page opened."""
        gen = _target_module.create_target(url=url, left=left, top=top,
            width=width, height=height, window_state=window_state,
            browser_context_id=browser_context_id,
            enable_begin_frame_control=enable_begin_frame_control,
            new_window=new_window, background=background, for_tab=for_tab,
            hidden=hidden)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def detach_from_target(self, session_id: typing.Optional[_target_module
        .SessionID]=None, target_id: typing.Optional[_target_module.
        TargetID]=None, _response_timeout: typing.Optional[float]=None) ->None:
        """Detaches session with given id.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param session_id: *(Optional)* Session to detach.

:param target_id: **(DEPRECATED)** *(Optional)* Deprecated.

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _target_module.detach_from_target(session_id=session_id,
            target_id=target_id)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def dispose_browser_context(self, browser_context_id: browser.
        BrowserContextID, _response_timeout: typing.Optional[float]=None
        ) ->None:
        """Deletes a BrowserContext. All the belonging pages will be closed without calling their
beforeunload hooks.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param browser_context_id:

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _target_module.dispose_browser_context(browser_context_id=
            browser_context_id)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def expose_dev_tools_protocol(self, target_id: _target_module.TargetID,
        binding_name: typing.Optional[str]=None, inherit_permissions:
        typing.Optional[bool]=None, _response_timeout: typing.Optional[
        float]=None) ->None:
        """Inject object to the target's main frame that provides a communication
channel with browser target.

Injected object will be available as ``window[bindingName]``.

The object has the following API:
- ``binding.send(json)`` - a method to send messages over the remote debugging protocol
- ``binding.onmessage = json => handleMessage(json)`` - a callback that will be called for the protocol notifications and command responses.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param target_id:

:param binding_name: *(Optional)* Binding name, 'cdp' if not specified.

:param inherit_permissions: *(Optional)* If true, inherits the current root session's permissions (default: false).

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _target_module.expose_dev_tools_protocol(target_id=target_id,
            binding_name=binding_name, inherit_permissions=inherit_permissions)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def get_browser_contexts(self, _response_timeout: typing.Optional[float
        ]=None) ->typing.List[browser.BrowserContextID]:
        """Returns all browser contexts created with ``Target.createBrowserContext`` method.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param _response_timeout: Optional timeout in seconds for the command.


:returns: An array of browser context ids."""
        gen = _target_module.get_browser_contexts()
        return self.client.send(gen, _response_timeout=_response_timeout)

    def get_target_info(self, target_id: typing.Optional[_target_module.
        TargetID]=None, _response_timeout: typing.Optional[float]=None
        ) ->_target_module.TargetInfo:
        """Returns information about a target.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param target_id: *(Optional)*

:param _response_timeout: Optional timeout in seconds for the command.


:returns:"""
        gen = _target_module.get_target_info(target_id=target_id)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def get_targets(self, filter_: typing.Optional[_target_module.
        TargetFilter]=None, _response_timeout: typing.Optional[float]=None
        ) ->typing.List[_target_module.TargetInfo]:
        """Retrieves a list of available targets.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be reported. If filter is not specified and target discovery is currently enabled, a filter used for target discovery is used for consistency.

:param _response_timeout: Optional timeout in seconds for the command.


:returns: The list of targets."""
        gen = _target_module.get_targets(filter_=filter_)
        return self.client.send(gen, _response_timeout=_response_timeout)

    @deprecated(version='1.3')
    def send_message_to_target(self, message: str, session_id: typing.
        Optional[_target_module.SessionID]=None, target_id: typing.Optional
        [_target_module.TargetID]=None, _response_timeout: typing.Optional[
        float]=None) ->None:
        """Sends protocol message over session with given id.
Consider using flat mode instead; see commands attachToTarget, setAutoAttach,
and crbug.com/991325.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

.. deprecated:: 1.3


:param ...:

:param message:

:param session_id: *(Optional)* Identifier of the session.

:param target_id: **(DEPRECATED)** *(Optional)* Deprecated.

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _target_module.send_message_to_target(message=message,
            session_id=session_id, target_id=target_id)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def set_auto_attach(self, auto_attach: bool, wait_for_debugger_on_start:
        bool, flatten: typing.Optional[bool]=None, filter_: typing.Optional
        [_target_module.TargetFilter]=None, _response_timeout: typing.
        Optional[float]=None) ->None:
        """Controls whether to automatically attach to new targets which are considered
to be directly related to this one (for example, iframes or workers).
When turned on, attaches to all existing related targets as well. When turned off,
automatically detaches from all currently attached targets.
This also clears all targets added by ``autoAttachRelated`` from the list of targets to watch
for creation of related targets.
You might want to call this recursively for auto-attached targets to attach
to all available targets.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param auto_attach: Whether to auto-attach to related targets.

:param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ``Runtime.runIfWaitingForDebugger`` to run paused targets.

:param flatten: **(EXPERIMENTAL)** *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.

:param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _target_module.set_auto_attach(auto_attach=auto_attach,
            wait_for_debugger_on_start=wait_for_debugger_on_start, flatten=
            flatten, filter_=filter_)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def set_discover_targets(self, discover: bool, filter_: typing.Optional
        [_target_module.TargetFilter]=None, _response_timeout: typing.
        Optional[float]=None) ->None:
        """Controls whether to discover available targets and notify via
``targetCreated/targetInfoChanged/targetDestroyed`` events.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param discover: Whether to discover available targets.

:param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached. If ``discover`` is false, ``filter`` must be omitted or empty.

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _target_module.set_discover_targets(discover=discover,
            filter_=filter_)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def set_remote_locations(self, locations: typing.List[_target_module.
        RemoteLocation], _response_timeout: typing.Optional[float]=None
        ) ->None:
        """Enables target discovery for the specified locations, when ``setDiscoverTargets`` was set to
``true``.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param locations: List of remote locations.

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _target_module.set_remote_locations(locations=locations)
        return self.client.send(gen, _response_timeout=_response_timeout)
