# # DO NOT EDIT THIS FILE!
# #
# # This file is generated from the CDP specification using AST. If you need to make
# # changes, edit the generator and regenerate all of the modules.

from __future__ import annotations
"""API wrapper for the Fetch domain."""
import typing
from ..util import CDPClient
from .. import fetch as _fetch_module
from .. import io
from .. import network
None


class FetchAPI:
    """Provides an API wrapper for the 'Fetch' domain commands.

Domain Description:
A domain for letting clients substitute browser's network layer with client code."""

    def __init__(self, client: CDPClient) ->None:
        self.client: CDPClient = client

    def continue_request(self, request_id: _fetch_module.RequestId, url:
        typing.Optional[str]=None, method: typing.Optional[str]=None,
        post_data: typing.Optional[str]=None, headers: typing.Optional[
        typing.List[_fetch_module.HeaderEntry]]=None, intercept_response:
        typing.Optional[bool]=None, _response_timeout: typing.Optional[
        float]=None) ->None:
        """Continues the request, optionally modifying some of its parameters.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param request_id: An id the client received in requestPaused event.

:param url: *(Optional)* If set, the request url will be modified in a way that's not observable by page.

:param method: *(Optional)* If set, the request method is overridden.

:param post_data: *(Optional)* If set, overrides the post data in the request. (Encoded as a base64 string when passed over JSON)

:param headers: *(Optional)* If set, overrides the request headers. Note that the overrides do not extend to subsequent redirect hops, if a redirect happens. Another override may be applied to a different request produced by a redirect.

:param intercept_response: **(EXPERIMENTAL)** *(Optional)* If set, overrides response interception behavior for this request.

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _fetch_module.continue_request(request_id=request_id, url=url,
            method=method, post_data=post_data, headers=headers,
            intercept_response=intercept_response)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def continue_response(self, request_id: _fetch_module.RequestId,
        response_code: typing.Optional[int]=None, response_phrase: typing.
        Optional[str]=None, response_headers: typing.Optional[typing.List[
        _fetch_module.HeaderEntry]]=None, binary_response_headers: typing.
        Optional[str]=None, _response_timeout: typing.Optional[float]=None
        ) ->None:
        """Continues loading of the paused response, optionally modifying the
response headers. If either responseCode or headers are modified, all of them
must be present.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.

**EXPERIMENTAL**


:param ...:

:param request_id: An id the client received in requestPaused event.

:param response_code: *(Optional)* An HTTP response code. If absent, original response code will be used.

:param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.

:param response_headers: *(Optional)* Response headers. If absent, original response headers will be used.

:param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \\0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _fetch_module.continue_response(request_id=request_id,
            response_code=response_code, response_phrase=response_phrase,
            response_headers=response_headers, binary_response_headers=
            binary_response_headers)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def continue_with_auth(self, request_id: _fetch_module.RequestId,
        auth_challenge_response: _fetch_module.AuthChallengeResponse,
        _response_timeout: typing.Optional[float]=None) ->None:
        """Continues a request supplying authChallengeResponse following authRequired event.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param request_id: An id the client received in authRequired event.

:param auth_challenge_response: Response to  with an authChallenge.

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _fetch_module.continue_with_auth(request_id=request_id,
            auth_challenge_response=auth_challenge_response)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def disable(self, _response_timeout: typing.Optional[float]=None) ->None:
        """Disables the fetch domain.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _fetch_module.disable()
        return self.client.send(gen, _response_timeout=_response_timeout)

    def enable(self, patterns: typing.Optional[typing.List[_fetch_module.
        RequestPattern]]=None, handle_auth_requests: typing.Optional[bool]=
        None, _response_timeout: typing.Optional[float]=None) ->None:
        """Enables issuing of requestPaused events. A request will be paused until client
calls one of failRequest, fulfillRequest or continueRequest/continueWithAuth.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param patterns: *(Optional)* If specified, only requests matching any of these patterns will produce fetchRequested event and will be paused until clients response. If not set, all requests will be affected.

:param handle_auth_requests: *(Optional)* If true, authRequired events will be issued and requests will be paused expecting a call to continueWithAuth.

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _fetch_module.enable(patterns=patterns, handle_auth_requests=
            handle_auth_requests)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def fail_request(self, request_id: _fetch_module.RequestId,
        error_reason: network.ErrorReason, _response_timeout: typing.
        Optional[float]=None) ->None:
        """Causes the request to fail with specified reason.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param request_id: An id the client received in requestPaused event.

:param error_reason: Causes the request to fail with the given reason.

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _fetch_module.fail_request(request_id=request_id,
            error_reason=error_reason)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def fulfill_request(self, request_id: _fetch_module.RequestId,
        response_code: int, response_headers: typing.Optional[typing.List[
        _fetch_module.HeaderEntry]]=None, binary_response_headers: typing.
        Optional[str]=None, body: typing.Optional[str]=None,
        response_phrase: typing.Optional[str]=None, _response_timeout:
        typing.Optional[float]=None) ->None:
        """Provides response to the request.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param request_id: An id the client received in requestPaused event.

:param response_code: An HTTP response code.

:param response_headers: *(Optional)* Response headers.

:param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \\0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)

:param body: *(Optional)* A response body. If absent, original response body will be used if the request is intercepted at the response stage and empty body will be used if the request is intercepted at the request stage. (Encoded as a base64 string when passed over JSON)

:param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.

:param _response_timeout: Optional timeout in seconds for the command."""
        gen = _fetch_module.fulfill_request(request_id=request_id,
            response_code=response_code, response_headers=response_headers,
            binary_response_headers=binary_response_headers, body=body,
            response_phrase=response_phrase)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def get_response_body(self, request_id: _fetch_module.RequestId,
        _response_timeout: typing.Optional[float]=None) ->typing.Tuple[str,
        bool]:
        """Causes the body of the response to be received from the server and
returned as a single string. May only be issued for a request that
is paused in the Response stage and is mutually exclusive with
takeResponseBodyForInterceptionAsStream. Calling other methods that
affect the request or disabling fetch domain before body is received
results in an undefined behavior.
Note that the response body is not available for redirects. Requests
paused in the _redirect received_ state may be differentiated by
``responseCode`` and presence of ``location`` response header, see
comments to ``requestPaused`` for details.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param request_id: Identifier for the intercepted request to get body for.

:param _response_timeout: Optional timeout in seconds for the command.


:returns: A tuple with the following items:

    1. **body** - Response body.
    2. **base64Encoded** - True, if content was sent as base64."""
        gen = _fetch_module.get_response_body(request_id=request_id)
        return self.client.send(gen, _response_timeout=_response_timeout)

    def take_response_body_as_stream(self, request_id: _fetch_module.
        RequestId, _response_timeout: typing.Optional[float]=None
        ) ->io.StreamHandle:
        """Returns a handle to the stream representing the response body.
The request must be paused in the HeadersReceived stage.
Note that after this command the request can't be continued
as is -- client either needs to cancel it or to provide the
response body.
The stream only supports sequential read, IO.read will fail if the position
is specified.
This method is mutually exclusive with getResponseBody.
Calling other methods that affect the request or disabling fetch
domain before body is received results in an undefined behavior.

NOTE: This is a blocking wrapper method that executes the underlying generator command using the client.


:param ...:

:param request_id:

:param _response_timeout: Optional timeout in seconds for the command.


:returns:"""
        gen = _fetch_module.take_response_body_as_stream(request_id=request_id)
        return self.client.send(gen, _response_timeout=_response_timeout)
