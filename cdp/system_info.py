# # DO NOT EDIT THIS FILE!
# #
# # This file is generated from the CDP specification using AST. If you need to make
# # changes, edit the generator and regenerate all of the modules.

from __future__ import annotations
"""CDP domain: SystemInfo (experimental)

The SystemInfo domain defines methods and events for querying low-level system information."""
import typing
import enum
from dataclasses import dataclass
from .util import T_JSON_DICT
None


@dataclass
class GPUDevice:
    """Describes a single graphics processor (GPU)."""
    vendor_id: float
    device_id: float
    vendor_string: str
    device_string: str
    driver_vendor: str
    driver_version: str
    sub_sys_id: typing.Optional[float] = None
    revision: typing.Optional[float] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['vendorId'] = self.vendor_id
        json_data['deviceId'] = self.device_id
        json_data['vendorString'] = self.vendor_string
        json_data['deviceString'] = self.device_string
        json_data['driverVendor'] = self.driver_vendor
        json_data['driverVersion'] = self.driver_version
        if self.sub_sys_id is not None:
            json_data['subSysId'] = self.sub_sys_id
        if self.revision is not None:
            json_data['revision'] = self.revision
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->GPUDevice:
        return cls(vendor_id=json_obj['vendorId'], device_id=json_obj[
            'deviceId'], vendor_string=json_obj['vendorString'],
            device_string=json_obj['deviceString'], driver_vendor=json_obj[
            'driverVendor'], driver_version=json_obj['driverVersion'],
            sub_sys_id=json_obj['subSysId'] if json_obj.get('subSysId') is not
            None else None, revision=json_obj['revision'] if json_obj.get(
            'revision') is not None else None)


@dataclass
class GPUInfo:
    """Provides information about the GPU(s) on the system."""
    devices: typing.List[GPUDevice]
    driver_bug_workarounds: typing.List[str]
    video_decoding: typing.List[VideoDecodeAcceleratorCapability]
    video_encoding: typing.List[VideoEncodeAcceleratorCapability]
    image_decoding: typing.List[ImageDecodeAcceleratorCapability]
    aux_attributes: typing.Optional[T_JSON_DICT] = None
    feature_status: typing.Optional[T_JSON_DICT] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['devices'] = [i.to_json() for i in self.devices]
        json_data['driverBugWorkarounds'] = [i for i in self.
            driver_bug_workarounds]
        json_data['videoDecoding'] = [i.to_json() for i in self.video_decoding]
        json_data['videoEncoding'] = [i.to_json() for i in self.video_encoding]
        json_data['imageDecoding'] = [i.to_json() for i in self.image_decoding]
        if self.aux_attributes is not None:
            json_data['auxAttributes'] = self.aux_attributes
        if self.feature_status is not None:
            json_data['featureStatus'] = self.feature_status
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->GPUInfo:
        return cls(devices=[GPUDevice.from_json(i) for i in json_obj[
            'devices']], driver_bug_workarounds=[i for i in json_obj[
            'driverBugWorkarounds']], video_decoding=[
            VideoDecodeAcceleratorCapability.from_json(i) for i in json_obj
            ['videoDecoding']], video_encoding=[
            VideoEncodeAcceleratorCapability.from_json(i) for i in json_obj
            ['videoEncoding']], image_decoding=[
            ImageDecodeAcceleratorCapability.from_json(i) for i in json_obj
            ['imageDecoding']], aux_attributes=json_obj['auxAttributes'] if
            json_obj.get('auxAttributes') is not None else None,
            feature_status=json_obj['featureStatus'] if json_obj.get(
            'featureStatus') is not None else None)


@dataclass
class ImageDecodeAcceleratorCapability:
    """Describes a supported image decoding profile with its associated minimum and
maximum resolutions and subsampling."""
    image_type: ImageType
    max_dimensions: Size
    min_dimensions: Size
    subsamplings: typing.List[SubsamplingFormat]

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['imageType'] = self.image_type.to_json()
        json_data['maxDimensions'] = self.max_dimensions.to_json()
        json_data['minDimensions'] = self.min_dimensions.to_json()
        json_data['subsamplings'] = [i.to_json() for i in self.subsamplings]
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT
        ) ->ImageDecodeAcceleratorCapability:
        return cls(image_type=ImageType.from_json(json_obj['imageType']),
            max_dimensions=Size.from_json(json_obj['maxDimensions']),
            min_dimensions=Size.from_json(json_obj['minDimensions']),
            subsamplings=[SubsamplingFormat.from_json(i) for i in json_obj[
            'subsamplings']])


@dataclass
class ProcessInfo:
    """Represents process info."""
    type_: str
    id_: int
    cpu_time: float

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['type'] = self.type_
        json_data['id'] = self.id_
        json_data['cpuTime'] = self.cpu_time
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->ProcessInfo:
        return cls(type_=json_obj['type'], id_=json_obj['id'], cpu_time=
            json_obj['cpuTime'])


@dataclass
class Size:
    """Describes the width and height dimensions of an entity."""
    width: int
    height: int

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['width'] = self.width
        json_data['height'] = self.height
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->Size:
        return cls(width=json_obj['width'], height=json_obj['height'])


@dataclass
class VideoDecodeAcceleratorCapability:
    """Describes a supported video decoding profile with its associated minimum and
maximum resolutions."""
    profile: str
    max_resolution: Size
    min_resolution: Size

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['profile'] = self.profile
        json_data['maxResolution'] = self.max_resolution.to_json()
        json_data['minResolution'] = self.min_resolution.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT
        ) ->VideoDecodeAcceleratorCapability:
        return cls(profile=json_obj['profile'], max_resolution=Size.
            from_json(json_obj['maxResolution']), min_resolution=Size.
            from_json(json_obj['minResolution']))


@dataclass
class VideoEncodeAcceleratorCapability:
    """Describes a supported video encoding profile with its associated maximum
resolution and maximum framerate."""
    profile: str
    max_resolution: Size
    max_framerate_numerator: int
    max_framerate_denominator: int

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['profile'] = self.profile
        json_data['maxResolution'] = self.max_resolution.to_json()
        json_data['maxFramerateNumerator'] = self.max_framerate_numerator
        json_data['maxFramerateDenominator'] = self.max_framerate_denominator
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT
        ) ->VideoEncodeAcceleratorCapability:
        return cls(profile=json_obj['profile'], max_resolution=Size.
            from_json(json_obj['maxResolution']), max_framerate_numerator=
            json_obj['maxFramerateNumerator'], max_framerate_denominator=
            json_obj['maxFramerateDenominator'])


class ImageType(enum.Enum):
    """Image format of a given image."""
    JPEG = 'jpeg'
    WEBP = 'webp'
    UNKNOWN = 'unknown'

    @classmethod
    def from_json(cls, json: str) ->ImageType:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<ImageType.{}>'.format(self.value)


class SubsamplingFormat(enum.Enum):
    """YUV subsampling type of the pixels of a given image."""
    YUV420 = 'yuv420'
    YUV422 = 'yuv422'
    YUV444 = 'yuv444'

    @classmethod
    def from_json(cls, json: str) ->SubsamplingFormat:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<SubsamplingFormat.{}>'.format(self.value)


def get_feature_state(feature_state: str) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, bool]:
    """Returns information about the feature state.

:param ...:

:param feature_state:


:returns:"""
    params_dict: T_JSON_DICT = dict()
    params_dict['featureState'] = feature_state
    cmd_dict = {'method': 'SystemInfo.getFeatureState', 'params': params_dict}
    json_result = yield cmd_dict
    return json_result['featureEnabled']


def get_info() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, typing.Tuple[
    GPUInfo, str, str, str]]:
    """Returns information about the system.


:returns: A tuple with the following items:

    1. **gpu** - Information about the GPUs on the system.
    2. **modelName** - A platform-dependent description of the model of the machine. On Mac OS, this is, for example, 'MacBookPro'. Will be the empty string if not supported.
    3. **modelVersion** - A platform-dependent description of the version of the machine. On Mac OS, this is, for example, '10.1'. Will be the empty string if not supported.
    4. **commandLine** - The command line string used to launch the browser. Will be the empty string if not supported."""
    cmd_dict = {'method': 'SystemInfo.getInfo'}
    json_result = yield cmd_dict
    return GPUInfo.from_json(json_result['gpu']), json_result['modelName'
        ], json_result['modelVersion'], json_result['commandLine']


def get_process_info() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, typing.
    List[ProcessInfo]]:
    """Returns information about all running processes.


:returns: An array of process info blocks."""
    cmd_dict = {'method': 'SystemInfo.getProcessInfo'}
    json_result = yield cmd_dict
    return [ProcessInfo.from_json(i) for i in json_result['processInfo']]
