# # DO NOT EDIT THIS FILE!
# #
# # This file is generated from the CDP specification using AST. If you need to make
# # changes, edit the generator and regenerate all of the modules.

from __future__ import annotations
"""CDP domain: IndexedDB (experimental)"""
import typing
import enum
from dataclasses import dataclass
from .util import T_JSON_DICT
from . import runtime
from . import storage
None


@dataclass
class DataEntry:
    """Data entry."""
    key: runtime.RemoteObject
    primary_key: runtime.RemoteObject
    value: runtime.RemoteObject

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['key'] = self.key.to_json()
        json_data['primaryKey'] = self.primary_key.to_json()
        json_data['value'] = self.value.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->DataEntry:
        return cls(key=runtime.RemoteObject.from_json(json_obj['key']),
            primary_key=runtime.RemoteObject.from_json(json_obj[
            'primaryKey']), value=runtime.RemoteObject.from_json(json_obj[
            'value']))


@dataclass
class DatabaseWithObjectStores:
    """Database with an array of object stores."""
    name: str
    version: float
    object_stores: typing.List[ObjectStore]

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['name'] = self.name
        json_data['version'] = self.version
        json_data['objectStores'] = [i.to_json() for i in self.object_stores]
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->DatabaseWithObjectStores:
        return cls(name=json_obj['name'], version=json_obj['version'],
            object_stores=[ObjectStore.from_json(i) for i in json_obj[
            'objectStores']])


@dataclass
class Key:
    """Key."""
    type_: str
    number: typing.Optional[float] = None
    string: typing.Optional[str] = None
    date: typing.Optional[float] = None
    array: typing.Optional[typing.List[Key]] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['type'] = self.type_
        if self.number is not None:
            json_data['number'] = self.number
        if self.string is not None:
            json_data['string'] = self.string
        if self.date is not None:
            json_data['date'] = self.date
        if self.array is not None:
            json_data['array'] = [i.to_json() for i in self.array]
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->Key:
        return cls(type_=json_obj['type'], number=json_obj['number'] if 
            json_obj.get('number') is not None else None, string=json_obj[
            'string'] if json_obj.get('string') is not None else None, date
            =json_obj['date'] if json_obj.get('date') is not None else None,
            array=[Key.from_json(i) for i in json_obj['array']] if json_obj
            .get('array') is not None else None)


@dataclass
class KeyPath:
    """Key path."""
    type_: str
    string: typing.Optional[str] = None
    array: typing.Optional[typing.List[str]] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['type'] = self.type_
        if self.string is not None:
            json_data['string'] = self.string
        if self.array is not None:
            json_data['array'] = [i for i in self.array]
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->KeyPath:
        return cls(type_=json_obj['type'], string=json_obj['string'] if 
            json_obj.get('string') is not None else None, array=[i for i in
            json_obj['array']] if json_obj.get('array') is not None else None)


@dataclass
class KeyRange:
    """Key range."""
    lower_open: bool
    upper_open: bool
    lower: typing.Optional[Key] = None
    upper: typing.Optional[Key] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['lowerOpen'] = self.lower_open
        json_data['upperOpen'] = self.upper_open
        if self.lower is not None:
            json_data['lower'] = self.lower.to_json()
        if self.upper is not None:
            json_data['upper'] = self.upper.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->KeyRange:
        return cls(lower_open=json_obj['lowerOpen'], upper_open=json_obj[
            'upperOpen'], lower=Key.from_json(json_obj['lower']) if 
            json_obj.get('lower') is not None else None, upper=Key.
            from_json(json_obj['upper']) if json_obj.get('upper') is not
            None else None)


@dataclass
class ObjectStore:
    """Object store."""
    name: str
    key_path: KeyPath
    auto_increment: bool
    indexes: typing.List[ObjectStoreIndex]

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['name'] = self.name
        json_data['keyPath'] = self.key_path.to_json()
        json_data['autoIncrement'] = self.auto_increment
        json_data['indexes'] = [i.to_json() for i in self.indexes]
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->ObjectStore:
        return cls(name=json_obj['name'], key_path=KeyPath.from_json(
            json_obj['keyPath']), auto_increment=json_obj['autoIncrement'],
            indexes=[ObjectStoreIndex.from_json(i) for i in json_obj[
            'indexes']])


@dataclass
class ObjectStoreIndex:
    """Object store index."""
    name: str
    key_path: KeyPath
    unique: bool
    multi_entry: bool

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['name'] = self.name
        json_data['keyPath'] = self.key_path.to_json()
        json_data['unique'] = self.unique
        json_data['multiEntry'] = self.multi_entry
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->ObjectStoreIndex:
        return cls(name=json_obj['name'], key_path=KeyPath.from_json(
            json_obj['keyPath']), unique=json_obj['unique'], multi_entry=
            json_obj['multiEntry'])


def clear_object_store(database_name: str, object_store_name: str,
    security_origin: typing.Optional[str]=None, storage_key: typing.
    Optional[str]=None, storage_bucket: typing.Optional[storage.
    StorageBucket]=None) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Clears all entries from an object store.

:param ...:

:param database_name: Database name.

:param object_store_name: Object store name.

:param security_origin: *(Optional)* At least and at most one of securityOrigin, storageKey, or storageBucket must be specified. Security origin.

:param storage_key: *(Optional)* Storage key.

:param storage_bucket: *(Optional)* Storage bucket. If not specified, it uses the default bucket."""
    params_dict: T_JSON_DICT = dict()
    if security_origin is not None:
        params_dict['securityOrigin'] = security_origin
    if storage_key is not None:
        params_dict['storageKey'] = storage_key
    if storage_bucket is not None:
        params_dict['storageBucket'] = storage_bucket.to_json()
    params_dict['databaseName'] = database_name
    params_dict['objectStoreName'] = object_store_name
    cmd_dict = {'method': 'IndexedDB.clearObjectStore', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def delete_database(database_name: str, security_origin: typing.Optional[
    str]=None, storage_key: typing.Optional[str]=None, storage_bucket:
    typing.Optional[storage.StorageBucket]=None) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, None]:
    """Deletes a database.

:param ...:

:param database_name: Database name.

:param security_origin: *(Optional)* At least and at most one of securityOrigin, storageKey, or storageBucket must be specified. Security origin.

:param storage_key: *(Optional)* Storage key.

:param storage_bucket: *(Optional)* Storage bucket. If not specified, it uses the default bucket."""
    params_dict: T_JSON_DICT = dict()
    if security_origin is not None:
        params_dict['securityOrigin'] = security_origin
    if storage_key is not None:
        params_dict['storageKey'] = storage_key
    if storage_bucket is not None:
        params_dict['storageBucket'] = storage_bucket.to_json()
    params_dict['databaseName'] = database_name
    cmd_dict = {'method': 'IndexedDB.deleteDatabase', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def delete_object_store_entries(database_name: str, object_store_name: str,
    key_range: KeyRange, security_origin: typing.Optional[str]=None,
    storage_key: typing.Optional[str]=None, storage_bucket: typing.Optional
    [storage.StorageBucket]=None) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, None]:
    """Delete a range of entries from an object store

:param ...:

:param database_name:

:param object_store_name:

:param key_range: Range of entry keys to delete

:param security_origin: *(Optional)* At least and at most one of securityOrigin, storageKey, or storageBucket must be specified. Security origin.

:param storage_key: *(Optional)* Storage key.

:param storage_bucket: *(Optional)* Storage bucket. If not specified, it uses the default bucket."""
    params_dict: T_JSON_DICT = dict()
    if security_origin is not None:
        params_dict['securityOrigin'] = security_origin
    if storage_key is not None:
        params_dict['storageKey'] = storage_key
    if storage_bucket is not None:
        params_dict['storageBucket'] = storage_bucket.to_json()
    params_dict['databaseName'] = database_name
    params_dict['objectStoreName'] = object_store_name
    params_dict['keyRange'] = key_range.to_json()
    cmd_dict = {'method': 'IndexedDB.deleteObjectStoreEntries', 'params':
        params_dict}
    json_result = yield cmd_dict
    return None


def disable() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Disables events from backend."""
    cmd_dict = {'method': 'IndexedDB.disable'}
    json_result = yield cmd_dict
    return None


def enable() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Enables events from backend."""
    cmd_dict = {'method': 'IndexedDB.enable'}
    json_result = yield cmd_dict
    return None


def get_metadata(database_name: str, object_store_name: str,
    security_origin: typing.Optional[str]=None, storage_key: typing.
    Optional[str]=None, storage_bucket: typing.Optional[storage.
    StorageBucket]=None) ->typing.Generator[T_JSON_DICT, T_JSON_DICT,
    typing.Tuple[float, float]]:
    """Gets metadata of an object store.

:param ...:

:param database_name: Database name.

:param object_store_name: Object store name.

:param security_origin: *(Optional)* At least and at most one of securityOrigin, storageKey, or storageBucket must be specified. Security origin.

:param storage_key: *(Optional)* Storage key.

:param storage_bucket: *(Optional)* Storage bucket. If not specified, it uses the default bucket.


:returns: A tuple with the following items:

    1. **entriesCount** - the entries count
    2. **keyGeneratorValue** - the current value of key generator, to become the next inserted key into the object store. Valid if objectStore.autoIncrement is true."""
    params_dict: T_JSON_DICT = dict()
    if security_origin is not None:
        params_dict['securityOrigin'] = security_origin
    if storage_key is not None:
        params_dict['storageKey'] = storage_key
    if storage_bucket is not None:
        params_dict['storageBucket'] = storage_bucket.to_json()
    params_dict['databaseName'] = database_name
    params_dict['objectStoreName'] = object_store_name
    cmd_dict = {'method': 'IndexedDB.getMetadata', 'params': params_dict}
    json_result = yield cmd_dict
    return json_result['entriesCount'], json_result['keyGeneratorValue']


def request_data(database_name: str, object_store_name: str, index_name:
    str, skip_count: int, page_size: int, security_origin: typing.Optional[
    str]=None, storage_key: typing.Optional[str]=None, storage_bucket:
    typing.Optional[storage.StorageBucket]=None, key_range: typing.Optional
    [KeyRange]=None) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, typing.
    Tuple[typing.List[DataEntry], bool]]:
    """Requests data from object store or index.

:param ...:

:param database_name: Database name.

:param object_store_name: Object store name.

:param index_name: Index name, empty string for object store data requests.

:param skip_count: Number of records to skip.

:param page_size: Number of records to fetch.

:param security_origin: *(Optional)* At least and at most one of securityOrigin, storageKey, or storageBucket must be specified. Security origin.

:param storage_key: *(Optional)* Storage key.

:param storage_bucket: *(Optional)* Storage bucket. If not specified, it uses the default bucket.

:param key_range: *(Optional)* Key range.


:returns: A tuple with the following items:

    1. **objectStoreDataEntries** - Array of object store data entries.
    2. **hasMore** - If true, there are more entries to fetch in the given range."""
    params_dict: T_JSON_DICT = dict()
    if security_origin is not None:
        params_dict['securityOrigin'] = security_origin
    if storage_key is not None:
        params_dict['storageKey'] = storage_key
    if storage_bucket is not None:
        params_dict['storageBucket'] = storage_bucket.to_json()
    params_dict['databaseName'] = database_name
    params_dict['objectStoreName'] = object_store_name
    params_dict['indexName'] = index_name
    params_dict['skipCount'] = skip_count
    params_dict['pageSize'] = page_size
    if key_range is not None:
        params_dict['keyRange'] = key_range.to_json()
    cmd_dict = {'method': 'IndexedDB.requestData', 'params': params_dict}
    json_result = yield cmd_dict
    return [DataEntry.from_json(i) for i in json_result[
        'objectStoreDataEntries']], json_result['hasMore']


def request_database(database_name: str, security_origin: typing.Optional[
    str]=None, storage_key: typing.Optional[str]=None, storage_bucket:
    typing.Optional[storage.StorageBucket]=None) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, DatabaseWithObjectStores]:
    """Requests database with given name in given frame.

:param ...:

:param database_name: Database name.

:param security_origin: *(Optional)* At least and at most one of securityOrigin, storageKey, or storageBucket must be specified. Security origin.

:param storage_key: *(Optional)* Storage key.

:param storage_bucket: *(Optional)* Storage bucket. If not specified, it uses the default bucket.


:returns: Database with an array of object stores."""
    params_dict: T_JSON_DICT = dict()
    if security_origin is not None:
        params_dict['securityOrigin'] = security_origin
    if storage_key is not None:
        params_dict['storageKey'] = storage_key
    if storage_bucket is not None:
        params_dict['storageBucket'] = storage_bucket.to_json()
    params_dict['databaseName'] = database_name
    cmd_dict = {'method': 'IndexedDB.requestDatabase', 'params': params_dict}
    json_result = yield cmd_dict
    return DatabaseWithObjectStores.from_json(json_result[
        'databaseWithObjectStores'])


def request_database_names(security_origin: typing.Optional[str]=None,
    storage_key: typing.Optional[str]=None, storage_bucket: typing.Optional
    [storage.StorageBucket]=None) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, typing.List[str]]:
    """Requests database names for given security origin.

:param ...:

:param security_origin: *(Optional)* At least and at most one of securityOrigin, storageKey, or storageBucket must be specified. Security origin.

:param storage_key: *(Optional)* Storage key.

:param storage_bucket: *(Optional)* Storage bucket. If not specified, it uses the default bucket.


:returns: Database names for origin."""
    params_dict: T_JSON_DICT = dict()
    if security_origin is not None:
        params_dict['securityOrigin'] = security_origin
    if storage_key is not None:
        params_dict['storageKey'] = storage_key
    if storage_bucket is not None:
        params_dict['storageBucket'] = storage_bucket.to_json()
    cmd_dict = {'method': 'IndexedDB.requestDatabaseNames', 'params':
        params_dict}
    json_result = yield cmd_dict
    return [i for i in json_result['databaseNames']]
