# # DO NOT EDIT THIS FILE!
# #
# # This file is generated from the CDP specification using AST. If you need to make
# # changes, edit the generator and regenerate all of the modules.

from __future__ import annotations
"""CDP domain: DOMSnapshot (experimental)

This domain facilitates obtaining document snapshots with DOM, layout, and style information."""
import typing
import enum
from dataclasses import dataclass
from .util import T_JSON_DICT
from deprecated.sphinx import deprecated
from . import css
from . import dom
from . import dom_debugger
from . import page
None


@dataclass
class ComputedStyle:
    """A subset of the full ComputedStyle as defined by the request whitelist."""
    properties: typing.List[NameValue]

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['properties'] = [i.to_json() for i in self.properties]
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->ComputedStyle:
        return cls(properties=[NameValue.from_json(i) for i in json_obj[
            'properties']])


@dataclass
class DOMNode:
    """A Node in the DOM tree."""
    node_type: int
    node_name: str
    node_value: str
    backend_node_id: dom.BackendNodeId
    text_value: typing.Optional[str] = None
    input_value: typing.Optional[str] = None
    input_checked: typing.Optional[bool] = None
    option_selected: typing.Optional[bool] = None
    child_node_indexes: typing.Optional[typing.List[int]] = None
    attributes: typing.Optional[typing.List[NameValue]] = None
    pseudo_element_indexes: typing.Optional[typing.List[int]] = None
    layout_node_index: typing.Optional[int] = None
    document_url: typing.Optional[str] = None
    base_url: typing.Optional[str] = None
    content_language: typing.Optional[str] = None
    document_encoding: typing.Optional[str] = None
    public_id: typing.Optional[str] = None
    system_id: typing.Optional[str] = None
    frame_id: typing.Optional[page.FrameId] = None
    content_document_index: typing.Optional[int] = None
    pseudo_type: typing.Optional[dom.PseudoType] = None
    shadow_root_type: typing.Optional[dom.ShadowRootType] = None
    is_clickable: typing.Optional[bool] = None
    event_listeners: typing.Optional[typing.List[dom_debugger.EventListener]
        ] = None
    current_source_url: typing.Optional[str] = None
    origin_url: typing.Optional[str] = None
    scroll_offset_x: typing.Optional[float] = None
    scroll_offset_y: typing.Optional[float] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['nodeType'] = self.node_type
        json_data['nodeName'] = self.node_name
        json_data['nodeValue'] = self.node_value
        json_data['backendNodeId'] = self.backend_node_id.to_json()
        if self.text_value is not None:
            json_data['textValue'] = self.text_value
        if self.input_value is not None:
            json_data['inputValue'] = self.input_value
        if self.input_checked is not None:
            json_data['inputChecked'] = self.input_checked
        if self.option_selected is not None:
            json_data['optionSelected'] = self.option_selected
        if self.child_node_indexes is not None:
            json_data['childNodeIndexes'] = [i for i in self.child_node_indexes
                ]
        if self.attributes is not None:
            json_data['attributes'] = [i.to_json() for i in self.attributes]
        if self.pseudo_element_indexes is not None:
            json_data['pseudoElementIndexes'] = [i for i in self.
                pseudo_element_indexes]
        if self.layout_node_index is not None:
            json_data['layoutNodeIndex'] = self.layout_node_index
        if self.document_url is not None:
            json_data['documentURL'] = self.document_url
        if self.base_url is not None:
            json_data['baseURL'] = self.base_url
        if self.content_language is not None:
            json_data['contentLanguage'] = self.content_language
        if self.document_encoding is not None:
            json_data['documentEncoding'] = self.document_encoding
        if self.public_id is not None:
            json_data['publicId'] = self.public_id
        if self.system_id is not None:
            json_data['systemId'] = self.system_id
        if self.frame_id is not None:
            json_data['frameId'] = self.frame_id.to_json()
        if self.content_document_index is not None:
            json_data['contentDocumentIndex'] = self.content_document_index
        if self.pseudo_type is not None:
            json_data['pseudoType'] = self.pseudo_type.to_json()
        if self.shadow_root_type is not None:
            json_data['shadowRootType'] = self.shadow_root_type.to_json()
        if self.is_clickable is not None:
            json_data['isClickable'] = self.is_clickable
        if self.event_listeners is not None:
            json_data['eventListeners'] = [i.to_json() for i in self.
                event_listeners]
        if self.current_source_url is not None:
            json_data['currentSourceURL'] = self.current_source_url
        if self.origin_url is not None:
            json_data['originURL'] = self.origin_url
        if self.scroll_offset_x is not None:
            json_data['scrollOffsetX'] = self.scroll_offset_x
        if self.scroll_offset_y is not None:
            json_data['scrollOffsetY'] = self.scroll_offset_y
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->DOMNode:
        return cls(node_type=json_obj['nodeType'], node_name=json_obj[
            'nodeName'], node_value=json_obj['nodeValue'], backend_node_id=
            dom.BackendNodeId.from_json(json_obj['backendNodeId']),
            text_value=json_obj['textValue'] if json_obj.get('textValue')
             is not None else None, input_value=json_obj['inputValue'] if 
            json_obj.get('inputValue') is not None else None, input_checked
            =json_obj['inputChecked'] if json_obj.get('inputChecked') is not
            None else None, option_selected=json_obj['optionSelected'] if 
            json_obj.get('optionSelected') is not None else None,
            child_node_indexes=[i for i in json_obj['childNodeIndexes']] if
            json_obj.get('childNodeIndexes') is not None else None,
            attributes=[NameValue.from_json(i) for i in json_obj[
            'attributes']] if json_obj.get('attributes') is not None else
            None, pseudo_element_indexes=[i for i in json_obj[
            'pseudoElementIndexes']] if json_obj.get('pseudoElementIndexes'
            ) is not None else None, layout_node_index=json_obj[
            'layoutNodeIndex'] if json_obj.get('layoutNodeIndex') is not
            None else None, document_url=json_obj['documentURL'] if 
            json_obj.get('documentURL') is not None else None, base_url=
            json_obj['baseURL'] if json_obj.get('baseURL') is not None else
            None, content_language=json_obj['contentLanguage'] if json_obj.
            get('contentLanguage') is not None else None, document_encoding
            =json_obj['documentEncoding'] if json_obj.get(
            'documentEncoding') is not None else None, public_id=json_obj[
            'publicId'] if json_obj.get('publicId') is not None else None,
            system_id=json_obj['systemId'] if json_obj.get('systemId') is not
            None else None, frame_id=page.FrameId.from_json(json_obj[
            'frameId']) if json_obj.get('frameId') is not None else None,
            content_document_index=json_obj['contentDocumentIndex'] if 
            json_obj.get('contentDocumentIndex') is not None else None,
            pseudo_type=dom.PseudoType.from_json(json_obj['pseudoType']) if
            json_obj.get('pseudoType') is not None else None,
            shadow_root_type=dom.ShadowRootType.from_json(json_obj[
            'shadowRootType']) if json_obj.get('shadowRootType') is not
            None else None, is_clickable=json_obj['isClickable'] if 
            json_obj.get('isClickable') is not None else None,
            event_listeners=[dom_debugger.EventListener.from_json(i) for i in
            json_obj['eventListeners']] if json_obj.get('eventListeners')
             is not None else None, current_source_url=json_obj[
            'currentSourceURL'] if json_obj.get('currentSourceURL') is not
            None else None, origin_url=json_obj['originURL'] if json_obj.
            get('originURL') is not None else None, scroll_offset_x=
            json_obj['scrollOffsetX'] if json_obj.get('scrollOffsetX') is not
            None else None, scroll_offset_y=json_obj['scrollOffsetY'] if 
            json_obj.get('scrollOffsetY') is not None else None)


@dataclass
class DocumentSnapshot:
    """Document snapshot."""
    document_url: StringIndex
    title: StringIndex
    base_url: StringIndex
    content_language: StringIndex
    encoding_name: StringIndex
    public_id: StringIndex
    system_id: StringIndex
    frame_id: StringIndex
    nodes: NodeTreeSnapshot
    layout: LayoutTreeSnapshot
    text_boxes: TextBoxSnapshot
    scroll_offset_x: typing.Optional[float] = None
    scroll_offset_y: typing.Optional[float] = None
    content_width: typing.Optional[float] = None
    content_height: typing.Optional[float] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['documentURL'] = self.document_url.to_json()
        json_data['title'] = self.title.to_json()
        json_data['baseURL'] = self.base_url.to_json()
        json_data['contentLanguage'] = self.content_language.to_json()
        json_data['encodingName'] = self.encoding_name.to_json()
        json_data['publicId'] = self.public_id.to_json()
        json_data['systemId'] = self.system_id.to_json()
        json_data['frameId'] = self.frame_id.to_json()
        json_data['nodes'] = self.nodes.to_json()
        json_data['layout'] = self.layout.to_json()
        json_data['textBoxes'] = self.text_boxes.to_json()
        if self.scroll_offset_x is not None:
            json_data['scrollOffsetX'] = self.scroll_offset_x
        if self.scroll_offset_y is not None:
            json_data['scrollOffsetY'] = self.scroll_offset_y
        if self.content_width is not None:
            json_data['contentWidth'] = self.content_width
        if self.content_height is not None:
            json_data['contentHeight'] = self.content_height
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->DocumentSnapshot:
        return cls(document_url=StringIndex.from_json(json_obj[
            'documentURL']), title=StringIndex.from_json(json_obj['title']),
            base_url=StringIndex.from_json(json_obj['baseURL']),
            content_language=StringIndex.from_json(json_obj[
            'contentLanguage']), encoding_name=StringIndex.from_json(
            json_obj['encodingName']), public_id=StringIndex.from_json(
            json_obj['publicId']), system_id=StringIndex.from_json(json_obj
            ['systemId']), frame_id=StringIndex.from_json(json_obj[
            'frameId']), nodes=NodeTreeSnapshot.from_json(json_obj['nodes']
            ), layout=LayoutTreeSnapshot.from_json(json_obj['layout']),
            text_boxes=TextBoxSnapshot.from_json(json_obj['textBoxes']),
            scroll_offset_x=json_obj['scrollOffsetX'] if json_obj.get(
            'scrollOffsetX') is not None else None, scroll_offset_y=
            json_obj['scrollOffsetY'] if json_obj.get('scrollOffsetY') is not
            None else None, content_width=json_obj['contentWidth'] if 
            json_obj.get('contentWidth') is not None else None,
            content_height=json_obj['contentHeight'] if json_obj.get(
            'contentHeight') is not None else None)


@dataclass
class InlineTextBox:
    """Details of post layout rendered text positions. The exact layout should not be regarded as
stable and may change between versions."""
    bounding_box: dom.Rect
    start_character_index: int
    num_characters: int

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['boundingBox'] = self.bounding_box.to_json()
        json_data['startCharacterIndex'] = self.start_character_index
        json_data['numCharacters'] = self.num_characters
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->InlineTextBox:
        return cls(bounding_box=dom.Rect.from_json(json_obj['boundingBox']),
            start_character_index=json_obj['startCharacterIndex'],
            num_characters=json_obj['numCharacters'])


@dataclass
class LayoutTreeNode:
    """Details of an element in the DOM tree with a LayoutObject."""
    dom_node_index: int
    bounding_box: dom.Rect
    layout_text: typing.Optional[str] = None
    inline_text_nodes: typing.Optional[typing.List[InlineTextBox]] = None
    style_index: typing.Optional[int] = None
    paint_order: typing.Optional[int] = None
    is_stacking_context: typing.Optional[bool] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['domNodeIndex'] = self.dom_node_index
        json_data['boundingBox'] = self.bounding_box.to_json()
        if self.layout_text is not None:
            json_data['layoutText'] = self.layout_text
        if self.inline_text_nodes is not None:
            json_data['inlineTextNodes'] = [i.to_json() for i in self.
                inline_text_nodes]
        if self.style_index is not None:
            json_data['styleIndex'] = self.style_index
        if self.paint_order is not None:
            json_data['paintOrder'] = self.paint_order
        if self.is_stacking_context is not None:
            json_data['isStackingContext'] = self.is_stacking_context
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->LayoutTreeNode:
        return cls(dom_node_index=json_obj['domNodeIndex'], bounding_box=
            dom.Rect.from_json(json_obj['boundingBox']), layout_text=
            json_obj['layoutText'] if json_obj.get('layoutText') is not
            None else None, inline_text_nodes=[InlineTextBox.from_json(i) for
            i in json_obj['inlineTextNodes']] if json_obj.get(
            'inlineTextNodes') is not None else None, style_index=json_obj[
            'styleIndex'] if json_obj.get('styleIndex') is not None else
            None, paint_order=json_obj['paintOrder'] if json_obj.get(
            'paintOrder') is not None else None, is_stacking_context=
            json_obj['isStackingContext'] if json_obj.get(
            'isStackingContext') is not None else None)


@dataclass
class LayoutTreeSnapshot:
    """Table of details of an element in the DOM tree with a LayoutObject."""
    node_index: typing.List[int]
    styles: typing.List[ArrayOfStrings]
    bounds: typing.List[Rectangle]
    text: typing.List[StringIndex]
    stacking_contexts: RareBooleanData
    paint_orders: typing.Optional[typing.List[int]] = None
    offset_rects: typing.Optional[typing.List[Rectangle]] = None
    scroll_rects: typing.Optional[typing.List[Rectangle]] = None
    client_rects: typing.Optional[typing.List[Rectangle]] = None
    blended_background_colors: typing.Optional[typing.List[StringIndex]] = None
    text_color_opacities: typing.Optional[typing.List[float]] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['nodeIndex'] = [i for i in self.node_index]
        json_data['styles'] = [i.to_json() for i in self.styles]
        json_data['bounds'] = [i.to_json() for i in self.bounds]
        json_data['text'] = [i.to_json() for i in self.text]
        json_data['stackingContexts'] = self.stacking_contexts.to_json()
        if self.paint_orders is not None:
            json_data['paintOrders'] = [i for i in self.paint_orders]
        if self.offset_rects is not None:
            json_data['offsetRects'] = [i.to_json() for i in self.offset_rects]
        if self.scroll_rects is not None:
            json_data['scrollRects'] = [i.to_json() for i in self.scroll_rects]
        if self.client_rects is not None:
            json_data['clientRects'] = [i.to_json() for i in self.client_rects]
        if self.blended_background_colors is not None:
            json_data['blendedBackgroundColors'] = [i.to_json() for i in
                self.blended_background_colors]
        if self.text_color_opacities is not None:
            json_data['textColorOpacities'] = [i for i in self.
                text_color_opacities]
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->LayoutTreeSnapshot:
        return cls(node_index=[i for i in json_obj['nodeIndex']], styles=[
            ArrayOfStrings.from_json(i) for i in json_obj['styles']],
            bounds=[Rectangle.from_json(i) for i in json_obj['bounds']],
            text=[StringIndex.from_json(i) for i in json_obj['text']],
            stacking_contexts=RareBooleanData.from_json(json_obj[
            'stackingContexts']), paint_orders=[i for i in json_obj[
            'paintOrders']] if json_obj.get('paintOrders') is not None else
            None, offset_rects=[Rectangle.from_json(i) for i in json_obj[
            'offsetRects']] if json_obj.get('offsetRects') is not None else
            None, scroll_rects=[Rectangle.from_json(i) for i in json_obj[
            'scrollRects']] if json_obj.get('scrollRects') is not None else
            None, client_rects=[Rectangle.from_json(i) for i in json_obj[
            'clientRects']] if json_obj.get('clientRects') is not None else
            None, blended_background_colors=[StringIndex.from_json(i) for i in
            json_obj['blendedBackgroundColors']] if json_obj.get(
            'blendedBackgroundColors') is not None else None,
            text_color_opacities=[i for i in json_obj['textColorOpacities']
            ] if json_obj.get('textColorOpacities') is not None else None)


@dataclass
class NameValue:
    """A name/value pair."""
    name: str
    value: str

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['name'] = self.name
        json_data['value'] = self.value
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->NameValue:
        return cls(name=json_obj['name'], value=json_obj['value'])


@dataclass
class NodeTreeSnapshot:
    """Table containing nodes."""
    parent_index: typing.Optional[typing.List[int]] = None
    node_type: typing.Optional[typing.List[int]] = None
    shadow_root_type: typing.Optional[RareStringData] = None
    node_name: typing.Optional[typing.List[StringIndex]] = None
    node_value: typing.Optional[typing.List[StringIndex]] = None
    backend_node_id: typing.Optional[typing.List[dom.BackendNodeId]] = None
    attributes: typing.Optional[typing.List[ArrayOfStrings]] = None
    text_value: typing.Optional[RareStringData] = None
    input_value: typing.Optional[RareStringData] = None
    input_checked: typing.Optional[RareBooleanData] = None
    option_selected: typing.Optional[RareBooleanData] = None
    content_document_index: typing.Optional[RareIntegerData] = None
    pseudo_type: typing.Optional[RareStringData] = None
    pseudo_identifier: typing.Optional[RareStringData] = None
    is_clickable: typing.Optional[RareBooleanData] = None
    current_source_url: typing.Optional[RareStringData] = None
    origin_url: typing.Optional[RareStringData] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        if self.parent_index is not None:
            json_data['parentIndex'] = [i for i in self.parent_index]
        if self.node_type is not None:
            json_data['nodeType'] = [i for i in self.node_type]
        if self.shadow_root_type is not None:
            json_data['shadowRootType'] = self.shadow_root_type.to_json()
        if self.node_name is not None:
            json_data['nodeName'] = [i.to_json() for i in self.node_name]
        if self.node_value is not None:
            json_data['nodeValue'] = [i.to_json() for i in self.node_value]
        if self.backend_node_id is not None:
            json_data['backendNodeId'] = [i.to_json() for i in self.
                backend_node_id]
        if self.attributes is not None:
            json_data['attributes'] = [i.to_json() for i in self.attributes]
        if self.text_value is not None:
            json_data['textValue'] = self.text_value.to_json()
        if self.input_value is not None:
            json_data['inputValue'] = self.input_value.to_json()
        if self.input_checked is not None:
            json_data['inputChecked'] = self.input_checked.to_json()
        if self.option_selected is not None:
            json_data['optionSelected'] = self.option_selected.to_json()
        if self.content_document_index is not None:
            json_data['contentDocumentIndex'
                ] = self.content_document_index.to_json()
        if self.pseudo_type is not None:
            json_data['pseudoType'] = self.pseudo_type.to_json()
        if self.pseudo_identifier is not None:
            json_data['pseudoIdentifier'] = self.pseudo_identifier.to_json()
        if self.is_clickable is not None:
            json_data['isClickable'] = self.is_clickable.to_json()
        if self.current_source_url is not None:
            json_data['currentSourceURL'] = self.current_source_url.to_json()
        if self.origin_url is not None:
            json_data['originURL'] = self.origin_url.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->NodeTreeSnapshot:
        return cls(parent_index=[i for i in json_obj['parentIndex']] if 
            json_obj.get('parentIndex') is not None else None, node_type=[i for
            i in json_obj['nodeType']] if json_obj.get('nodeType') is not
            None else None, shadow_root_type=RareStringData.from_json(
            json_obj['shadowRootType']) if json_obj.get('shadowRootType')
             is not None else None, node_name=[StringIndex.from_json(i) for
            i in json_obj['nodeName']] if json_obj.get('nodeName') is not
            None else None, node_value=[StringIndex.from_json(i) for i in
            json_obj['nodeValue']] if json_obj.get('nodeValue') is not None
             else None, backend_node_id=[dom.BackendNodeId.from_json(i) for
            i in json_obj['backendNodeId']] if json_obj.get('backendNodeId'
            ) is not None else None, attributes=[ArrayOfStrings.from_json(i
            ) for i in json_obj['attributes']] if json_obj.get('attributes'
            ) is not None else None, text_value=RareStringData.from_json(
            json_obj['textValue']) if json_obj.get('textValue') is not None
             else None, input_value=RareStringData.from_json(json_obj[
            'inputValue']) if json_obj.get('inputValue') is not None else
            None, input_checked=RareBooleanData.from_json(json_obj[
            'inputChecked']) if json_obj.get('inputChecked') is not None else
            None, option_selected=RareBooleanData.from_json(json_obj[
            'optionSelected']) if json_obj.get('optionSelected') is not
            None else None, content_document_index=RareIntegerData.
            from_json(json_obj['contentDocumentIndex']) if json_obj.get(
            'contentDocumentIndex') is not None else None, pseudo_type=
            RareStringData.from_json(json_obj['pseudoType']) if json_obj.
            get('pseudoType') is not None else None, pseudo_identifier=
            RareStringData.from_json(json_obj['pseudoIdentifier']) if 
            json_obj.get('pseudoIdentifier') is not None else None,
            is_clickable=RareBooleanData.from_json(json_obj['isClickable']) if
            json_obj.get('isClickable') is not None else None,
            current_source_url=RareStringData.from_json(json_obj[
            'currentSourceURL']) if json_obj.get('currentSourceURL') is not
            None else None, origin_url=RareStringData.from_json(json_obj[
            'originURL']) if json_obj.get('originURL') is not None else None)


@dataclass
class RareBooleanData:
    index: typing.List[int]

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['index'] = [i for i in self.index]
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->RareBooleanData:
        return cls(index=[i for i in json_obj['index']])


@dataclass
class RareIntegerData:
    index: typing.List[int]
    value: typing.List[int]

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['index'] = [i for i in self.index]
        json_data['value'] = [i for i in self.value]
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->RareIntegerData:
        return cls(index=[i for i in json_obj['index']], value=[i for i in
            json_obj['value']])


@dataclass
class RareStringData:
    """Data that is only present on rare nodes."""
    index: typing.List[int]
    value: typing.List[StringIndex]

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['index'] = [i for i in self.index]
        json_data['value'] = [i.to_json() for i in self.value]
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->RareStringData:
        return cls(index=[i for i in json_obj['index']], value=[StringIndex
            .from_json(i) for i in json_obj['value']])


@dataclass
class TextBoxSnapshot:
    """Table of details of the post layout rendered text positions. The exact layout should not be regarded as
stable and may change between versions."""
    layout_index: typing.List[int]
    bounds: typing.List[Rectangle]
    start: typing.List[int]
    length: typing.List[int]

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['layoutIndex'] = [i for i in self.layout_index]
        json_data['bounds'] = [i.to_json() for i in self.bounds]
        json_data['start'] = [i for i in self.start]
        json_data['length'] = [i for i in self.length]
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->TextBoxSnapshot:
        return cls(layout_index=[i for i in json_obj['layoutIndex']],
            bounds=[Rectangle.from_json(i) for i in json_obj['bounds']],
            start=[i for i in json_obj['start']], length=[i for i in
            json_obj['length']])


class StringIndex(int):
    """Index of the string in the strings table.

Represents the CDP type 'DOMSnapshot.StringIndex'."""

    def to_json(self) ->int:
        return self

    @classmethod
    def from_json(cls, json: int) ->StringIndex:
        return cls(json)

    def __repr__(self) ->str:
        return 'StringIndex({})'.format(super().__repr__())


class ArrayOfStrings(list):
    """Index of the string in the strings table.

Represents the CDP array type 'DOMSnapshot.ArrayOfStrings'."""

    def to_json(self) ->typing.List[StringIndex]:
        return self

    @classmethod
    def from_json(cls, json: typing.List[StringIndex]) ->ArrayOfStrings:
        return cls(json)

    def __repr__(self) ->str:
        return 'ArrayOfStrings({})'.format(super().__repr__())


class Rectangle(list):
    """Represents the CDP array type 'DOMSnapshot.Rectangle'."""

    def to_json(self) ->typing.List[float]:
        return self

    @classmethod
    def from_json(cls, json: typing.List[float]) ->Rectangle:
        return cls(json)

    def __repr__(self) ->str:
        return 'Rectangle({})'.format(super().__repr__())


def capture_snapshot(computed_styles: typing.List[str], include_paint_order:
    typing.Optional[bool]=None, include_dom_rects: typing.Optional[bool]=
    None, include_blended_background_colors: typing.Optional[bool]=None,
    include_text_color_opacities: typing.Optional[bool]=None
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, typing.Tuple[typing.List
    [DocumentSnapshot], typing.List[str]]]:
    """Returns a document snapshot, including the full DOM tree of the root node (including iframes,
template contents, and imported documents) in a flattened array, as well as layout and
white-listed computed style information for the nodes. Shadow DOM in the returned DOM tree is
flattened.

:param ...:

:param computed_styles: Whitelist of computed styles to return.

:param include_paint_order: *(Optional)* Whether to include layout object paint orders into the snapshot.

:param include_dom_rects: *(Optional)* Whether to include DOM rectangles (offsetRects, clientRects, scrollRects) into the snapshot

:param include_blended_background_colors: **(EXPERIMENTAL)** *(Optional)* Whether to include blended background colors in the snapshot (default: false). Blended background color is achieved by blending background colors of all elements that overlap with the current element.

:param include_text_color_opacities: **(EXPERIMENTAL)** *(Optional)* Whether to include text color opacity in the snapshot (default: false). An element might have the opacity property set that affects the text color of the element. The final text color opacity is computed based on the opacity of all overlapping elements.


:returns: A tuple with the following items:

    1. **documents** - The nodes in the DOM tree. The DOMNode at index 0 corresponds to the root document.
    2. **strings** - Shared string table that all string properties refer to with indexes."""
    params_dict: T_JSON_DICT = dict()
    params_dict['computedStyles'] = [i for i in computed_styles]
    if include_paint_order is not None:
        params_dict['includePaintOrder'] = include_paint_order
    if include_dom_rects is not None:
        params_dict['includeDOMRects'] = include_dom_rects
    if include_blended_background_colors is not None:
        params_dict['includeBlendedBackgroundColors'
            ] = include_blended_background_colors
    if include_text_color_opacities is not None:
        params_dict['includeTextColorOpacities'] = include_text_color_opacities
    cmd_dict = {'method': 'DOMSnapshot.captureSnapshot', 'params': params_dict}
    json_result = yield cmd_dict
    return [DocumentSnapshot.from_json(i) for i in json_result['documents']], [
        i for i in json_result['strings']]


def disable() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Disables DOM snapshot agent for the given page."""
    cmd_dict = {'method': 'DOMSnapshot.disable'}
    json_result = yield cmd_dict
    return None


def enable() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Enables DOM snapshot agent for the given page."""
    cmd_dict = {'method': 'DOMSnapshot.enable'}
    json_result = yield cmd_dict
    return None


@deprecated(version='1.3')
def get_snapshot(computed_style_whitelist: typing.List[str],
    include_event_listeners: typing.Optional[bool]=None,
    include_paint_order: typing.Optional[bool]=None,
    include_user_agent_shadow_tree: typing.Optional[bool]=None
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, typing.Tuple[typing.List
    [DOMNode], typing.List[LayoutTreeNode], typing.List[ComputedStyle]]]:
    """Returns a document snapshot, including the full DOM tree of the root node (including iframes,
template contents, and imported documents) in a flattened array, as well as layout and
white-listed computed style information for the nodes. Shadow DOM in the returned DOM tree is
flattened.

.. deprecated:: 1.3

:param ...:

:param computed_style_whitelist: Whitelist of computed styles to return.

:param include_event_listeners: *(Optional)* Whether or not to retrieve details of DOM listeners (default false).

:param include_paint_order: *(Optional)* Whether to determine and include the paint order index of LayoutTreeNodes (default false).

:param include_user_agent_shadow_tree: *(Optional)* Whether to include UA shadow tree in the snapshot (default false).


:returns: A tuple with the following items:

    1. **domNodes** - The nodes in the DOM tree. The DOMNode at index 0 corresponds to the root document.
    2. **layoutTreeNodes** - The nodes in the layout tree.
    3. **computedStyles** - Whitelisted ComputedStyle properties for each node in the layout tree."""
    params_dict: T_JSON_DICT = dict()
    params_dict['computedStyleWhitelist'] = [i for i in
        computed_style_whitelist]
    if include_event_listeners is not None:
        params_dict['includeEventListeners'] = include_event_listeners
    if include_paint_order is not None:
        params_dict['includePaintOrder'] = include_paint_order
    if include_user_agent_shadow_tree is not None:
        params_dict['includeUserAgentShadowTree'
            ] = include_user_agent_shadow_tree
    cmd_dict = {'method': 'DOMSnapshot.getSnapshot', 'params': params_dict}
    json_result = yield cmd_dict
    return [DOMNode.from_json(i) for i in json_result['domNodes']], [
        LayoutTreeNode.from_json(i) for i in json_result['layoutTreeNodes']], [
        ComputedStyle.from_json(i) for i in json_result['computedStyles']]
