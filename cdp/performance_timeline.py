# # DO NOT EDIT THIS FILE!
# #
# # This file is generated from the CDP specification using AST. If you need to make
# # changes, edit the generator and regenerate all of the modules.

from __future__ import annotations
"""CDP domain: PerformanceTimeline (experimental)

Reporting of performance timeline events, as specified in
https://w3c.github.io/performance-timeline/#dom-performanceobserver."""
import typing
import enum
from dataclasses import dataclass
from .util import T_JSON_DICT, event_class
from . import dom
from . import network
from . import page
None


@dataclass
class LargestContentfulPaint:
    """See https://github.com/WICG/LargestContentfulPaint and largest_contentful_paint.idl"""
    render_time: network.TimeSinceEpoch
    load_time: network.TimeSinceEpoch
    size: float
    element_id: typing.Optional[str] = None
    url: typing.Optional[str] = None
    node_id: typing.Optional[dom.BackendNodeId] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['renderTime'] = self.render_time.to_json()
        json_data['loadTime'] = self.load_time.to_json()
        json_data['size'] = self.size
        if self.element_id is not None:
            json_data['elementId'] = self.element_id
        if self.url is not None:
            json_data['url'] = self.url
        if self.node_id is not None:
            json_data['nodeId'] = self.node_id.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->LargestContentfulPaint:
        return cls(render_time=network.TimeSinceEpoch.from_json(json_obj[
            'renderTime']), load_time=network.TimeSinceEpoch.from_json(
            json_obj['loadTime']), size=json_obj['size'], element_id=
            json_obj['elementId'] if json_obj.get('elementId') is not None else
            None, url=json_obj['url'] if json_obj.get('url') is not None else
            None, node_id=dom.BackendNodeId.from_json(json_obj['nodeId']) if
            json_obj.get('nodeId') is not None else None)


@dataclass
class LayoutShift:
    """See https://wicg.github.io/layout-instability/#sec-layout-shift and layout_shift.idl"""
    value: float
    had_recent_input: bool
    last_input_time: network.TimeSinceEpoch
    sources: typing.List[LayoutShiftAttribution]

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['value'] = self.value
        json_data['hadRecentInput'] = self.had_recent_input
        json_data['lastInputTime'] = self.last_input_time.to_json()
        json_data['sources'] = [i.to_json() for i in self.sources]
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->LayoutShift:
        return cls(value=json_obj['value'], had_recent_input=json_obj[
            'hadRecentInput'], last_input_time=network.TimeSinceEpoch.
            from_json(json_obj['lastInputTime']), sources=[
            LayoutShiftAttribution.from_json(i) for i in json_obj['sources']])


@dataclass
class LayoutShiftAttribution:
    previous_rect: dom.Rect
    current_rect: dom.Rect
    node_id: typing.Optional[dom.BackendNodeId] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['previousRect'] = self.previous_rect.to_json()
        json_data['currentRect'] = self.current_rect.to_json()
        if self.node_id is not None:
            json_data['nodeId'] = self.node_id.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->LayoutShiftAttribution:
        return cls(previous_rect=dom.Rect.from_json(json_obj['previousRect'
            ]), current_rect=dom.Rect.from_json(json_obj['currentRect']),
            node_id=dom.BackendNodeId.from_json(json_obj['nodeId']) if 
            json_obj.get('nodeId') is not None else None)


@dataclass
class TimelineEvent:
    frame_id: page.FrameId
    type_: str
    name: str
    time: network.TimeSinceEpoch
    duration: typing.Optional[float] = None
    lcp_details: typing.Optional[LargestContentfulPaint] = None
    layout_shift_details: typing.Optional[LayoutShift] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['frameId'] = self.frame_id.to_json()
        json_data['type'] = self.type_
        json_data['name'] = self.name
        json_data['time'] = self.time.to_json()
        if self.duration is not None:
            json_data['duration'] = self.duration
        if self.lcp_details is not None:
            json_data['lcpDetails'] = self.lcp_details.to_json()
        if self.layout_shift_details is not None:
            json_data['layoutShiftDetails'
                ] = self.layout_shift_details.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->TimelineEvent:
        return cls(frame_id=page.FrameId.from_json(json_obj['frameId']),
            type_=json_obj['type'], name=json_obj['name'], time=network.
            TimeSinceEpoch.from_json(json_obj['time']), duration=json_obj[
            'duration'] if json_obj.get('duration') is not None else None,
            lcp_details=LargestContentfulPaint.from_json(json_obj[
            'lcpDetails']) if json_obj.get('lcpDetails') is not None else
            None, layout_shift_details=LayoutShift.from_json(json_obj[
            'layoutShiftDetails']) if json_obj.get('layoutShiftDetails') is not
            None else None)


def enable(event_types: typing.List[str]) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, None]:
    """Previously buffered events would be reported before method returns.
See also: timelineEventAdded

:param ...:

:param event_types: The types of event to report, as specified in https://w3c.github.io/performance-timeline/#dom-performanceentry-entrytype The specified filter overrides any previous filters, passing empty filter disables recording. Note that not all types exposed to the web platform are currently supported."""
    params_dict: T_JSON_DICT = dict()
    params_dict['eventTypes'] = [i for i in event_types]
    cmd_dict = {'method': 'PerformanceTimeline.enable', 'params': params_dict}
    json_result = yield cmd_dict
    return None


@event_class('PerformanceTimeline.timelineEventAdded')
@dataclass
class TimelineEventAdded:
    """Sent when a performance timeline event is added. See reportPerformanceTimeline method."""
    event: TimelineEvent

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->TimelineEventAdded:
        return cls(event=TimelineEvent.from_json(json_obj['event']))
