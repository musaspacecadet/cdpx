# # DO NOT EDIT THIS FILE!
# #
# # This file is generated from the CDP specification using AST. If you need to make
# # changes, edit the generator and regenerate all of the modules.

from __future__ import annotations
"""CDP domain: Fetch

A domain for letting clients substitute browser's network layer with client code."""
import typing
import enum
from dataclasses import dataclass
from .util import T_JSON_DICT, event_class
from . import io
from . import network
from . import page
None


@dataclass
class AuthChallenge:
    """Authorization challenge for HTTP status code 401 or 407."""
    origin: str
    scheme: str
    realm: str
    source: typing.Optional[str] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['origin'] = self.origin
        json_data['scheme'] = self.scheme
        json_data['realm'] = self.realm
        if self.source is not None:
            json_data['source'] = self.source
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->AuthChallenge:
        return cls(origin=json_obj['origin'], scheme=json_obj['scheme'],
            realm=json_obj['realm'], source=json_obj['source'] if json_obj.
            get('source') is not None else None)


@dataclass
class AuthChallengeResponse:
    """Response to an AuthChallenge."""
    response: str
    username: typing.Optional[str] = None
    password: typing.Optional[str] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['response'] = self.response
        if self.username is not None:
            json_data['username'] = self.username
        if self.password is not None:
            json_data['password'] = self.password
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->AuthChallengeResponse:
        return cls(response=json_obj['response'], username=json_obj[
            'username'] if json_obj.get('username') is not None else None,
            password=json_obj['password'] if json_obj.get('password') is not
            None else None)


@dataclass
class HeaderEntry:
    """Response HTTP header entry"""
    name: str
    value: str

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['name'] = self.name
        json_data['value'] = self.value
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->HeaderEntry:
        return cls(name=json_obj['name'], value=json_obj['value'])


@dataclass
class RequestPattern:
    url_pattern: typing.Optional[str] = None
    resource_type: typing.Optional[network.ResourceType] = None
    request_stage: typing.Optional[RequestStage] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        if self.url_pattern is not None:
            json_data['urlPattern'] = self.url_pattern
        if self.resource_type is not None:
            json_data['resourceType'] = self.resource_type.to_json()
        if self.request_stage is not None:
            json_data['requestStage'] = self.request_stage.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->RequestPattern:
        return cls(url_pattern=json_obj['urlPattern'] if json_obj.get(
            'urlPattern') is not None else None, resource_type=network.
            ResourceType.from_json(json_obj['resourceType']) if json_obj.
            get('resourceType') is not None else None, request_stage=
            RequestStage.from_json(json_obj['requestStage']) if json_obj.
            get('requestStage') is not None else None)


class RequestStage(enum.Enum):
    """Stages of the request to handle. Request will intercept before the request is
sent. Response will intercept after the response is received (but before response
body is received)."""
    REQUEST = 'Request'
    RESPONSE = 'Response'

    @classmethod
    def from_json(cls, json: str) ->RequestStage:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<RequestStage.{}>'.format(self.value)


class RequestId(str):
    """Unique request identifier.
Note that this does not identify individual HTTP requests that are part of
a network request.

Represents the CDP type 'Fetch.RequestId'."""

    def to_json(self) ->str:
        return self

    @classmethod
    def from_json(cls, json: str) ->RequestId:
        return cls(json)

    def __repr__(self) ->str:
        return 'RequestId({})'.format(super().__repr__())


def continue_request(request_id: RequestId, url: typing.Optional[str]=None,
    method: typing.Optional[str]=None, post_data: typing.Optional[str]=None,
    headers: typing.Optional[typing.List[HeaderEntry]]=None,
    intercept_response: typing.Optional[bool]=None) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, None]:
    """Continues the request, optionally modifying some of its parameters.

:param ...:

:param request_id: An id the client received in requestPaused event.

:param url: *(Optional)* If set, the request url will be modified in a way that's not observable by page.

:param method: *(Optional)* If set, the request method is overridden.

:param post_data: *(Optional)* If set, overrides the post data in the request. (Encoded as a base64 string when passed over JSON)

:param headers: *(Optional)* If set, overrides the request headers. Note that the overrides do not extend to subsequent redirect hops, if a redirect happens. Another override may be applied to a different request produced by a redirect.

:param intercept_response: **(EXPERIMENTAL)** *(Optional)* If set, overrides response interception behavior for this request."""
    params_dict: T_JSON_DICT = dict()
    params_dict['requestId'] = request_id.to_json()
    if url is not None:
        params_dict['url'] = url
    if method is not None:
        params_dict['method'] = method
    if post_data is not None:
        params_dict['postData'] = post_data
    if headers is not None:
        params_dict['headers'] = [i.to_json() for i in headers]
    if intercept_response is not None:
        params_dict['interceptResponse'] = intercept_response
    cmd_dict = {'method': 'Fetch.continueRequest', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def continue_response(request_id: RequestId, response_code: typing.Optional
    [int]=None, response_phrase: typing.Optional[str]=None,
    response_headers: typing.Optional[typing.List[HeaderEntry]]=None,
    binary_response_headers: typing.Optional[str]=None) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, None]:
    """Continues loading of the paused response, optionally modifying the
response headers. If either responseCode or headers are modified, all of them
must be present.

**EXPERIMENTAL**

:param ...:

:param request_id: An id the client received in requestPaused event.

:param response_code: *(Optional)* An HTTP response code. If absent, original response code will be used.

:param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.

:param response_headers: *(Optional)* Response headers. If absent, original response headers will be used.

:param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \\0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)"""
    params_dict: T_JSON_DICT = dict()
    params_dict['requestId'] = request_id.to_json()
    if response_code is not None:
        params_dict['responseCode'] = response_code
    if response_phrase is not None:
        params_dict['responsePhrase'] = response_phrase
    if response_headers is not None:
        params_dict['responseHeaders'] = [i.to_json() for i in response_headers
            ]
    if binary_response_headers is not None:
        params_dict['binaryResponseHeaders'] = binary_response_headers
    cmd_dict = {'method': 'Fetch.continueResponse', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def continue_with_auth(request_id: RequestId, auth_challenge_response:
    AuthChallengeResponse) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Continues a request supplying authChallengeResponse following authRequired event.

:param ...:

:param request_id: An id the client received in authRequired event.

:param auth_challenge_response: Response to  with an authChallenge."""
    params_dict: T_JSON_DICT = dict()
    params_dict['requestId'] = request_id.to_json()
    params_dict['authChallengeResponse'] = auth_challenge_response.to_json()
    cmd_dict = {'method': 'Fetch.continueWithAuth', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def disable() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Disables the fetch domain."""
    cmd_dict = {'method': 'Fetch.disable'}
    json_result = yield cmd_dict
    return None


def enable(patterns: typing.Optional[typing.List[RequestPattern]]=None,
    handle_auth_requests: typing.Optional[bool]=None) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, None]:
    """Enables issuing of requestPaused events. A request will be paused until client
calls one of failRequest, fulfillRequest or continueRequest/continueWithAuth.

:param ...:

:param patterns: *(Optional)* If specified, only requests matching any of these patterns will produce fetchRequested event and will be paused until clients response. If not set, all requests will be affected.

:param handle_auth_requests: *(Optional)* If true, authRequired events will be issued and requests will be paused expecting a call to continueWithAuth."""
    params_dict: T_JSON_DICT = dict()
    if patterns is not None:
        params_dict['patterns'] = [i.to_json() for i in patterns]
    if handle_auth_requests is not None:
        params_dict['handleAuthRequests'] = handle_auth_requests
    cmd_dict = {'method': 'Fetch.enable', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def fail_request(request_id: RequestId, error_reason: network.ErrorReason
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Causes the request to fail with specified reason.

:param ...:

:param request_id: An id the client received in requestPaused event.

:param error_reason: Causes the request to fail with the given reason."""
    params_dict: T_JSON_DICT = dict()
    params_dict['requestId'] = request_id.to_json()
    params_dict['errorReason'] = error_reason.to_json()
    cmd_dict = {'method': 'Fetch.failRequest', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def fulfill_request(request_id: RequestId, response_code: int,
    response_headers: typing.Optional[typing.List[HeaderEntry]]=None,
    binary_response_headers: typing.Optional[str]=None, body: typing.
    Optional[str]=None, response_phrase: typing.Optional[str]=None
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Provides response to the request.

:param ...:

:param request_id: An id the client received in requestPaused event.

:param response_code: An HTTP response code.

:param response_headers: *(Optional)* Response headers.

:param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \\0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)

:param body: *(Optional)* A response body. If absent, original response body will be used if the request is intercepted at the response stage and empty body will be used if the request is intercepted at the request stage. (Encoded as a base64 string when passed over JSON)

:param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used."""
    params_dict: T_JSON_DICT = dict()
    params_dict['requestId'] = request_id.to_json()
    params_dict['responseCode'] = response_code
    if response_headers is not None:
        params_dict['responseHeaders'] = [i.to_json() for i in response_headers
            ]
    if binary_response_headers is not None:
        params_dict['binaryResponseHeaders'] = binary_response_headers
    if body is not None:
        params_dict['body'] = body
    if response_phrase is not None:
        params_dict['responsePhrase'] = response_phrase
    cmd_dict = {'method': 'Fetch.fulfillRequest', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def get_response_body(request_id: RequestId) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, typing.Tuple[str, bool]]:
    """Causes the body of the response to be received from the server and
returned as a single string. May only be issued for a request that
is paused in the Response stage and is mutually exclusive with
takeResponseBodyForInterceptionAsStream. Calling other methods that
affect the request or disabling fetch domain before body is received
results in an undefined behavior.
Note that the response body is not available for redirects. Requests
paused in the _redirect received_ state may be differentiated by
``responseCode`` and presence of ``location`` response header, see
comments to ``requestPaused`` for details.

:param ...:

:param request_id: Identifier for the intercepted request to get body for.


:returns: A tuple with the following items:

    1. **body** - Response body.
    2. **base64Encoded** - True, if content was sent as base64."""
    params_dict: T_JSON_DICT = dict()
    params_dict['requestId'] = request_id.to_json()
    cmd_dict = {'method': 'Fetch.getResponseBody', 'params': params_dict}
    json_result = yield cmd_dict
    return json_result['body'], json_result['base64Encoded']


def take_response_body_as_stream(request_id: RequestId) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, io.StreamHandle]:
    """Returns a handle to the stream representing the response body.
The request must be paused in the HeadersReceived stage.
Note that after this command the request can't be continued
as is -- client either needs to cancel it or to provide the
response body.
The stream only supports sequential read, IO.read will fail if the position
is specified.
This method is mutually exclusive with getResponseBody.
Calling other methods that affect the request or disabling fetch
domain before body is received results in an undefined behavior.

:param ...:

:param request_id:


:returns:"""
    params_dict: T_JSON_DICT = dict()
    params_dict['requestId'] = request_id.to_json()
    cmd_dict = {'method': 'Fetch.takeResponseBodyAsStream', 'params':
        params_dict}
    json_result = yield cmd_dict
    return io.StreamHandle.from_json(json_result['stream'])


@event_class('Fetch.authRequired')
@dataclass
class AuthRequired:
    """Issued when the domain is enabled with handleAuthRequests set to true.
The request is paused until client responds with continueWithAuth."""
    request_id: RequestId
    request: network.Request
    frame_id: page.FrameId
    resource_type: network.ResourceType
    auth_challenge: AuthChallenge

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->AuthRequired:
        return cls(request_id=RequestId.from_json(json_obj['requestId']),
            request=network.Request.from_json(json_obj['request']),
            frame_id=page.FrameId.from_json(json_obj['frameId']),
            resource_type=network.ResourceType.from_json(json_obj[
            'resourceType']), auth_challenge=AuthChallenge.from_json(
            json_obj['authChallenge']))


@event_class('Fetch.requestPaused')
@dataclass
class RequestPaused:
    """Issued when the domain is enabled and the request URL matches the
specified filter. The request is paused until the client responds
with one of continueRequest, failRequest or fulfillRequest.
The stage of the request can be determined by presence of responseErrorReason
and responseStatusCode -- the request is at the response stage if either
of these fields is present and in the request stage otherwise.
Redirect responses and subsequent requests are reported similarly to regular
responses and requests. Redirect responses may be distinguished by the value
of ``responseStatusCode`` (which is one of 301, 302, 303, 307, 308) along with
presence of the ``location`` header. Requests resulting from a redirect will
have ``redirectedRequestId`` field set."""
    request_id: RequestId
    request: network.Request
    frame_id: page.FrameId
    resource_type: network.ResourceType
    response_error_reason: typing.Optional[network.ErrorReason] = None
    response_status_code: typing.Optional[int] = None
    response_status_text: typing.Optional[str] = None
    response_headers: typing.Optional[typing.List[HeaderEntry]] = None
    network_id: typing.Optional[network.RequestId] = None
    redirected_request_id: typing.Optional[RequestId] = None

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->RequestPaused:
        return cls(request_id=RequestId.from_json(json_obj['requestId']),
            request=network.Request.from_json(json_obj['request']),
            frame_id=page.FrameId.from_json(json_obj['frameId']),
            resource_type=network.ResourceType.from_json(json_obj[
            'resourceType']), response_error_reason=network.ErrorReason.
            from_json(json_obj['responseErrorReason']) if json_obj.get(
            'responseErrorReason') is not None else None,
            response_status_code=json_obj['responseStatusCode'] if json_obj
            .get('responseStatusCode') is not None else None,
            response_status_text=json_obj['responseStatusText'] if json_obj
            .get('responseStatusText') is not None else None,
            response_headers=[HeaderEntry.from_json(i) for i in json_obj[
            'responseHeaders']] if json_obj.get('responseHeaders') is not
            None else None, network_id=network.RequestId.from_json(json_obj
            ['networkId']) if json_obj.get('networkId') is not None else
            None, redirected_request_id=RequestId.from_json(json_obj[
            'redirectedRequestId']) if json_obj.get('redirectedRequestId')
             is not None else None)
