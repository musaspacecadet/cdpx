# # DO NOT EDIT THIS FILE!
# #
# # This file is generated from the CDP specification using AST. If you need to make
# # changes, edit the generator and regenerate all of the modules.

from __future__ import annotations
"""CDP domain: DOMDebugger

DOM debugging allows setting breakpoints on particular DOM operations and events. JavaScript
execution will stop on these operations as if there was a regular breakpoint set."""
import typing
import enum
from dataclasses import dataclass
from .util import T_JSON_DICT
from deprecated.sphinx import deprecated
from . import dom
from . import runtime
None


@dataclass
class EventListener:
    """Object event listener."""
    type_: str
    use_capture: bool
    passive: bool
    once: bool
    script_id: runtime.ScriptId
    line_number: int
    column_number: int
    handler: typing.Optional[runtime.RemoteObject] = None
    original_handler: typing.Optional[runtime.RemoteObject] = None
    backend_node_id: typing.Optional[dom.BackendNodeId] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['type'] = self.type_
        json_data['useCapture'] = self.use_capture
        json_data['passive'] = self.passive
        json_data['once'] = self.once
        json_data['scriptId'] = self.script_id.to_json()
        json_data['lineNumber'] = self.line_number
        json_data['columnNumber'] = self.column_number
        if self.handler is not None:
            json_data['handler'] = self.handler.to_json()
        if self.original_handler is not None:
            json_data['originalHandler'] = self.original_handler.to_json()
        if self.backend_node_id is not None:
            json_data['backendNodeId'] = self.backend_node_id.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->EventListener:
        return cls(type_=json_obj['type'], use_capture=json_obj[
            'useCapture'], passive=json_obj['passive'], once=json_obj[
            'once'], script_id=runtime.ScriptId.from_json(json_obj[
            'scriptId']), line_number=json_obj['lineNumber'], column_number
            =json_obj['columnNumber'], handler=runtime.RemoteObject.
            from_json(json_obj['handler']) if json_obj.get('handler') is not
            None else None, original_handler=runtime.RemoteObject.from_json
            (json_obj['originalHandler']) if json_obj.get('originalHandler'
            ) is not None else None, backend_node_id=dom.BackendNodeId.
            from_json(json_obj['backendNodeId']) if json_obj.get(
            'backendNodeId') is not None else None)


class CSPViolationType(enum.Enum):
    """CSP Violation type."""
    TRUSTEDTYPE_SINK_VIOLATION = 'trustedtype-sink-violation'
    TRUSTEDTYPE_POLICY_VIOLATION = 'trustedtype-policy-violation'

    @classmethod
    def from_json(cls, json: str) ->CSPViolationType:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<CSPViolationType.{}>'.format(self.value)


class DOMBreakpointType(enum.Enum):
    """DOM breakpoint type."""
    SUBTREE_MODIFIED = 'subtree-modified'
    ATTRIBUTE_MODIFIED = 'attribute-modified'
    NODE_REMOVED = 'node-removed'

    @classmethod
    def from_json(cls, json: str) ->DOMBreakpointType:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<DOMBreakpointType.{}>'.format(self.value)


def get_event_listeners(object_id: runtime.RemoteObjectId, depth: typing.
    Optional[int]=None, pierce: typing.Optional[bool]=None) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, typing.List[EventListener]]:
    """Returns event listeners of the given object.

:param ...:

:param object_id: Identifier of the object to return listeners for.

:param depth: *(Optional)* The maximum depth at which Node children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.

:param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false). Reports listeners for all contexts if pierce is enabled.


:returns: Array of relevant listeners."""
    params_dict: T_JSON_DICT = dict()
    params_dict['objectId'] = object_id.to_json()
    if depth is not None:
        params_dict['depth'] = depth
    if pierce is not None:
        params_dict['pierce'] = pierce
    cmd_dict = {'method': 'DOMDebugger.getEventListeners', 'params':
        params_dict}
    json_result = yield cmd_dict
    return [EventListener.from_json(i) for i in json_result['listeners']]


def remove_dom_breakpoint(node_id: dom.NodeId, type_: DOMBreakpointType
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Removes DOM breakpoint that was set using ``setDOMBreakpoint``.

:param ...:

:param node_id: Identifier of the node to remove breakpoint from.

:param type_: Type of the breakpoint to remove."""
    params_dict: T_JSON_DICT = dict()
    params_dict['nodeId'] = node_id.to_json()
    params_dict['type'] = type_.to_json()
    cmd_dict = {'method': 'DOMDebugger.removeDOMBreakpoint', 'params':
        params_dict}
    json_result = yield cmd_dict
    return None


def remove_event_listener_breakpoint(event_name: str, target_name: typing.
    Optional[str]=None) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Removes breakpoint on particular DOM event.

:param ...:

:param event_name: Event name.

:param target_name: **(EXPERIMENTAL)** *(Optional)* EventTarget interface name."""
    params_dict: T_JSON_DICT = dict()
    params_dict['eventName'] = event_name
    if target_name is not None:
        params_dict['targetName'] = target_name
    cmd_dict = {'method': 'DOMDebugger.removeEventListenerBreakpoint',
        'params': params_dict}
    json_result = yield cmd_dict
    return None


@deprecated(version='1.3')
def remove_instrumentation_breakpoint(event_name: str) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, None]:
    """Removes breakpoint on particular native event.

Redirects to command 'EventBreakpoints'.

.. deprecated:: 1.3

**EXPERIMENTAL**

:param ...:

:param event_name: Instrumentation name to stop on."""
    params_dict: T_JSON_DICT = dict()
    params_dict['eventName'] = event_name
    cmd_dict = {'method': 'DOMDebugger.removeInstrumentationBreakpoint',
        'params': params_dict}
    json_result = yield cmd_dict
    return None


def remove_xhr_breakpoint(url: str) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, None]:
    """Removes breakpoint from XMLHttpRequest.

:param ...:

:param url: Resource URL substring."""
    params_dict: T_JSON_DICT = dict()
    params_dict['url'] = url
    cmd_dict = {'method': 'DOMDebugger.removeXHRBreakpoint', 'params':
        params_dict}
    json_result = yield cmd_dict
    return None


def set_break_on_csp_violation(violation_types: typing.List[CSPViolationType]
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Sets breakpoint on particular CSP violations.

**EXPERIMENTAL**

:param ...:

:param violation_types: CSP Violations to stop upon."""
    params_dict: T_JSON_DICT = dict()
    params_dict['violationTypes'] = [i.to_json() for i in violation_types]
    cmd_dict = {'method': 'DOMDebugger.setBreakOnCSPViolation', 'params':
        params_dict}
    json_result = yield cmd_dict
    return None


def set_dom_breakpoint(node_id: dom.NodeId, type_: DOMBreakpointType
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Sets breakpoint on particular operation with DOM.

:param ...:

:param node_id: Identifier of the node to set breakpoint on.

:param type_: Type of the operation to stop upon."""
    params_dict: T_JSON_DICT = dict()
    params_dict['nodeId'] = node_id.to_json()
    params_dict['type'] = type_.to_json()
    cmd_dict = {'method': 'DOMDebugger.setDOMBreakpoint', 'params': params_dict
        }
    json_result = yield cmd_dict
    return None


def set_event_listener_breakpoint(event_name: str, target_name: typing.
    Optional[str]=None) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Sets breakpoint on particular DOM event.

:param ...:

:param event_name: DOM Event name to stop on (any DOM event will do).

:param target_name: **(EXPERIMENTAL)** *(Optional)* EventTarget interface name to stop on. If equal to ``"*"`` or not provided, will stop on any EventTarget."""
    params_dict: T_JSON_DICT = dict()
    params_dict['eventName'] = event_name
    if target_name is not None:
        params_dict['targetName'] = target_name
    cmd_dict = {'method': 'DOMDebugger.setEventListenerBreakpoint',
        'params': params_dict}
    json_result = yield cmd_dict
    return None


@deprecated(version='1.3')
def set_instrumentation_breakpoint(event_name: str) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, None]:
    """Sets breakpoint on particular native event.

Redirects to command 'EventBreakpoints'.

.. deprecated:: 1.3

**EXPERIMENTAL**

:param ...:

:param event_name: Instrumentation name to stop on."""
    params_dict: T_JSON_DICT = dict()
    params_dict['eventName'] = event_name
    cmd_dict = {'method': 'DOMDebugger.setInstrumentationBreakpoint',
        'params': params_dict}
    json_result = yield cmd_dict
    return None


def set_xhr_breakpoint(url: str) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, None]:
    """Sets breakpoint on XMLHttpRequest.

:param ...:

:param url: Resource URL substring. All XHRs having this substring in the URL will get stopped upon."""
    params_dict: T_JSON_DICT = dict()
    params_dict['url'] = url
    cmd_dict = {'method': 'DOMDebugger.setXHRBreakpoint', 'params': params_dict
        }
    json_result = yield cmd_dict
    return None
