# # DO NOT EDIT THIS FILE!
# #
# # This file is generated from the CDP specification using AST. If you need to make
# # changes, edit the generator and regenerate all of the modules.

from __future__ import annotations
"""CDP domain: Browser

The Browser domain defines methods and events for browser managing."""
import typing
import enum
from dataclasses import dataclass
from .util import T_JSON_DICT, event_class
from . import page
from . import target
None


@dataclass
class Bounds:
    """Browser window bounds information"""
    left: typing.Optional[int] = None
    top: typing.Optional[int] = None
    width: typing.Optional[int] = None
    height: typing.Optional[int] = None
    window_state: typing.Optional[WindowState] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        if self.left is not None:
            json_data['left'] = self.left
        if self.top is not None:
            json_data['top'] = self.top
        if self.width is not None:
            json_data['width'] = self.width
        if self.height is not None:
            json_data['height'] = self.height
        if self.window_state is not None:
            json_data['windowState'] = self.window_state.to_json()
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->Bounds:
        return cls(left=json_obj['left'] if json_obj.get('left') is not
            None else None, top=json_obj['top'] if json_obj.get('top') is not
            None else None, width=json_obj['width'] if json_obj.get('width'
            ) is not None else None, height=json_obj['height'] if json_obj.
            get('height') is not None else None, window_state=WindowState.
            from_json(json_obj['windowState']) if json_obj.get(
            'windowState') is not None else None)


@dataclass
class Bucket:
    """Chrome histogram bucket."""
    low: int
    high: int
    count: int

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['low'] = self.low
        json_data['high'] = self.high
        json_data['count'] = self.count
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->Bucket:
        return cls(low=json_obj['low'], high=json_obj['high'], count=
            json_obj['count'])


@dataclass
class Histogram:
    """Chrome histogram."""
    name: str
    sum_: int
    count: int
    buckets: typing.List[Bucket]

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['name'] = self.name
        json_data['sum'] = self.sum_
        json_data['count'] = self.count
        json_data['buckets'] = [i.to_json() for i in self.buckets]
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->Histogram:
        return cls(name=json_obj['name'], sum_=json_obj['sum'], count=
            json_obj['count'], buckets=[Bucket.from_json(i) for i in
            json_obj['buckets']])


@dataclass
class PermissionDescriptor:
    """Definition of PermissionDescriptor defined in the Permissions API:
https://w3c.github.io/permissions/#dom-permissiondescriptor."""
    name: str
    sysex: typing.Optional[bool] = None
    user_visible_only: typing.Optional[bool] = None
    allow_without_sanitization: typing.Optional[bool] = None
    allow_without_gesture: typing.Optional[bool] = None
    pan_tilt_zoom: typing.Optional[bool] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['name'] = self.name
        if self.sysex is not None:
            json_data['sysex'] = self.sysex
        if self.user_visible_only is not None:
            json_data['userVisibleOnly'] = self.user_visible_only
        if self.allow_without_sanitization is not None:
            json_data['allowWithoutSanitization'
                ] = self.allow_without_sanitization
        if self.allow_without_gesture is not None:
            json_data['allowWithoutGesture'] = self.allow_without_gesture
        if self.pan_tilt_zoom is not None:
            json_data['panTiltZoom'] = self.pan_tilt_zoom
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->PermissionDescriptor:
        return cls(name=json_obj['name'], sysex=json_obj['sysex'] if 
            json_obj.get('sysex') is not None else None, user_visible_only=
            json_obj['userVisibleOnly'] if json_obj.get('userVisibleOnly')
             is not None else None, allow_without_sanitization=json_obj[
            'allowWithoutSanitization'] if json_obj.get(
            'allowWithoutSanitization') is not None else None,
            allow_without_gesture=json_obj['allowWithoutGesture'] if 
            json_obj.get('allowWithoutGesture') is not None else None,
            pan_tilt_zoom=json_obj['panTiltZoom'] if json_obj.get(
            'panTiltZoom') is not None else None)


class BrowserCommandId(enum.Enum):
    """Browser command ids used by executeBrowserCommand."""
    OPEN_TAB_SEARCH = 'openTabSearch'
    CLOSE_TAB_SEARCH = 'closeTabSearch'
    OPEN_GLIC = 'openGlic'

    @classmethod
    def from_json(cls, json: str) ->BrowserCommandId:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<BrowserCommandId.{}>'.format(self.value)


class PermissionSetting(enum.Enum):
    GRANTED = 'granted'
    DENIED = 'denied'
    PROMPT = 'prompt'

    @classmethod
    def from_json(cls, json: str) ->PermissionSetting:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<PermissionSetting.{}>'.format(self.value)


class PermissionType(enum.Enum):
    AR = 'ar'
    AUDIO_CAPTURE = 'audioCapture'
    AUTOMATIC_FULLSCREEN = 'automaticFullscreen'
    BACKGROUND_FETCH = 'backgroundFetch'
    BACKGROUND_SYNC = 'backgroundSync'
    CAMERA_PAN_TILT_ZOOM = 'cameraPanTiltZoom'
    CAPTURED_SURFACE_CONTROL = 'capturedSurfaceControl'
    CLIPBOARD_READ_WRITE = 'clipboardReadWrite'
    CLIPBOARD_SANITIZED_WRITE = 'clipboardSanitizedWrite'
    DISPLAY_CAPTURE = 'displayCapture'
    DURABLE_STORAGE = 'durableStorage'
    GEOLOCATION = 'geolocation'
    HAND_TRACKING = 'handTracking'
    IDLE_DETECTION = 'idleDetection'
    KEYBOARD_LOCK = 'keyboardLock'
    LOCAL_FONTS = 'localFonts'
    LOCAL_NETWORK_ACCESS = 'localNetworkAccess'
    MIDI = 'midi'
    MIDI_SYSEX = 'midiSysex'
    NFC = 'nfc'
    NOTIFICATIONS = 'notifications'
    PAYMENT_HANDLER = 'paymentHandler'
    PERIODIC_BACKGROUND_SYNC = 'periodicBackgroundSync'
    POINTER_LOCK = 'pointerLock'
    PROTECTED_MEDIA_IDENTIFIER = 'protectedMediaIdentifier'
    SENSORS = 'sensors'
    SMART_CARD = 'smartCard'
    SPEAKER_SELECTION = 'speakerSelection'
    STORAGE_ACCESS = 'storageAccess'
    TOP_LEVEL_STORAGE_ACCESS = 'topLevelStorageAccess'
    VIDEO_CAPTURE = 'videoCapture'
    VR = 'vr'
    WAKE_LOCK_SCREEN = 'wakeLockScreen'
    WAKE_LOCK_SYSTEM = 'wakeLockSystem'
    WEB_APP_INSTALLATION = 'webAppInstallation'
    WEB_PRINTING = 'webPrinting'
    WINDOW_MANAGEMENT = 'windowManagement'

    @classmethod
    def from_json(cls, json: str) ->PermissionType:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<PermissionType.{}>'.format(self.value)


class PrivacySandboxAPI(enum.Enum):
    BIDDING_AND_AUCTION_SERVICES = 'BiddingAndAuctionServices'
    TRUSTED_KEY_VALUE = 'TrustedKeyValue'

    @classmethod
    def from_json(cls, json: str) ->PrivacySandboxAPI:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<PrivacySandboxAPI.{}>'.format(self.value)


class WindowState(enum.Enum):
    """The state of the browser window."""
    NORMAL = 'normal'
    MINIMIZED = 'minimized'
    MAXIMIZED = 'maximized'
    FULLSCREEN = 'fullscreen'

    @classmethod
    def from_json(cls, json: str) ->WindowState:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<WindowState.{}>'.format(self.value)


class BrowserContextID(str):
    """Represents the CDP type 'Browser.BrowserContextID'.

**EXPERIMENTAL**"""

    def to_json(self) ->str:
        return self

    @classmethod
    def from_json(cls, json: str) ->BrowserContextID:
        return cls(json)

    def __repr__(self) ->str:
        return 'BrowserContextID({})'.format(super().__repr__())


class WindowID(int):
    """Represents the CDP type 'Browser.WindowID'.

**EXPERIMENTAL**"""

    def to_json(self) ->int:
        return self

    @classmethod
    def from_json(cls, json: int) ->WindowID:
        return cls(json)

    def __repr__(self) ->str:
        return 'WindowID({})'.format(super().__repr__())


def add_privacy_sandbox_coordinator_key_config(api: PrivacySandboxAPI,
    coordinator_origin: str, key_config: str, browser_context_id: typing.
    Optional[BrowserContextID]=None) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, None]:
    """Configures encryption keys used with a given privacy sandbox API to talk
to a trusted coordinator.  Since this is intended for test automation only,
coordinatorOrigin must be a .test domain. No existing coordinator
configuration for the origin may exist.

:param ...:

:param api:

:param coordinator_origin:

:param key_config:

:param browser_context_id: *(Optional)* BrowserContext to perform the action in. When omitted, default browser context is used."""
    params_dict: T_JSON_DICT = dict()
    params_dict['api'] = api.to_json()
    params_dict['coordinatorOrigin'] = coordinator_origin
    params_dict['keyConfig'] = key_config
    if browser_context_id is not None:
        params_dict['browserContextId'] = browser_context_id.to_json()
    cmd_dict = {'method': 'Browser.addPrivacySandboxCoordinatorKeyConfig',
        'params': params_dict}
    json_result = yield cmd_dict
    return None


def add_privacy_sandbox_enrollment_override(url: str) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, None]:
    """Allows a site to use privacy sandbox features that require enrollment
without the site actually being enrolled. Only supported on page targets.

:param ...:

:param url:"""
    params_dict: T_JSON_DICT = dict()
    params_dict['url'] = url
    cmd_dict = {'method': 'Browser.addPrivacySandboxEnrollmentOverride',
        'params': params_dict}
    json_result = yield cmd_dict
    return None


def cancel_download(guid: str, browser_context_id: typing.Optional[
    BrowserContextID]=None) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Cancel a download if in progress

**EXPERIMENTAL**

:param ...:

:param guid: Global unique identifier of the download.

:param browser_context_id: *(Optional)* BrowserContext to perform the action in. When omitted, default browser context is used."""
    params_dict: T_JSON_DICT = dict()
    params_dict['guid'] = guid
    if browser_context_id is not None:
        params_dict['browserContextId'] = browser_context_id.to_json()
    cmd_dict = {'method': 'Browser.cancelDownload', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def close() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Close browser gracefully."""
    cmd_dict = {'method': 'Browser.close'}
    json_result = yield cmd_dict
    return None


def crash() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Crashes browser on the main thread.

**EXPERIMENTAL**"""
    cmd_dict = {'method': 'Browser.crash'}
    json_result = yield cmd_dict
    return None


def crash_gpu_process() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Crashes GPU process.

**EXPERIMENTAL**"""
    cmd_dict = {'method': 'Browser.crashGpuProcess'}
    json_result = yield cmd_dict
    return None


def execute_browser_command(command_id: BrowserCommandId) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, None]:
    """Invoke custom browser commands used by telemetry.

**EXPERIMENTAL**

:param ...:

:param command_id:"""
    params_dict: T_JSON_DICT = dict()
    params_dict['commandId'] = command_id.to_json()
    cmd_dict = {'method': 'Browser.executeBrowserCommand', 'params':
        params_dict}
    json_result = yield cmd_dict
    return None


def get_browser_command_line() ->typing.Generator[T_JSON_DICT, T_JSON_DICT,
    typing.List[str]]:
    """Returns the command line switches for the browser process if, and only if
--enable-automation is on the commandline.

**EXPERIMENTAL**


:returns: Commandline parameters"""
    cmd_dict = {'method': 'Browser.getBrowserCommandLine'}
    json_result = yield cmd_dict
    return [i for i in json_result['arguments']]


def get_histogram(name: str, delta: typing.Optional[bool]=None
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, Histogram]:
    """Get a Chrome histogram by name.

**EXPERIMENTAL**

:param ...:

:param name: Requested histogram name.

:param delta: *(Optional)* If true, retrieve delta since last delta call.


:returns: Histogram."""
    params_dict: T_JSON_DICT = dict()
    params_dict['name'] = name
    if delta is not None:
        params_dict['delta'] = delta
    cmd_dict = {'method': 'Browser.getHistogram', 'params': params_dict}
    json_result = yield cmd_dict
    return Histogram.from_json(json_result['histogram'])


def get_histograms(query: typing.Optional[str]=None, delta: typing.Optional
    [bool]=None) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, typing.List[
    Histogram]]:
    """Get Chrome histograms.

**EXPERIMENTAL**

:param ...:

:param query: *(Optional)* Requested substring in name. Only histograms which have query as a substring in their name are extracted. An empty or absent query returns all histograms.

:param delta: *(Optional)* If true, retrieve delta since last delta call.


:returns: Histograms."""
    params_dict: T_JSON_DICT = dict()
    if query is not None:
        params_dict['query'] = query
    if delta is not None:
        params_dict['delta'] = delta
    cmd_dict = {'method': 'Browser.getHistograms', 'params': params_dict}
    json_result = yield cmd_dict
    return [Histogram.from_json(i) for i in json_result['histograms']]


def get_version() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, typing.Tuple
    [str, str, str, str, str]]:
    """Returns version information.


:returns: A tuple with the following items:

    1. **protocolVersion** - Protocol version.
    2. **product** - Product name.
    3. **revision** - Product revision.
    4. **userAgent** - User-Agent.
    5. **jsVersion** - V8 version."""
    cmd_dict = {'method': 'Browser.getVersion'}
    json_result = yield cmd_dict
    return json_result['protocolVersion'], json_result['product'], json_result[
        'revision'], json_result['userAgent'], json_result['jsVersion']


def get_window_bounds(window_id: WindowID) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, Bounds]:
    """Get position and size of the browser window.

**EXPERIMENTAL**

:param ...:

:param window_id: Browser window id.


:returns: Bounds information of the window. When window state is 'minimized', the restored window position and size are returned."""
    params_dict: T_JSON_DICT = dict()
    params_dict['windowId'] = window_id.to_json()
    cmd_dict = {'method': 'Browser.getWindowBounds', 'params': params_dict}
    json_result = yield cmd_dict
    return Bounds.from_json(json_result['bounds'])


def get_window_for_target(target_id: typing.Optional[target.TargetID]=None
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, typing.Tuple[WindowID,
    Bounds]]:
    """Get the browser window that contains the devtools target.

**EXPERIMENTAL**

:param ...:

:param target_id: *(Optional)* Devtools agent host id. If called as a part of the session, associated targetId is used.


:returns: A tuple with the following items:

    1. **windowId** - Browser window id.
    2. **bounds** - Bounds information of the window. When window state is 'minimized', the restored window position and size are returned."""
    params_dict: T_JSON_DICT = dict()
    if target_id is not None:
        params_dict['targetId'] = target_id.to_json()
    cmd_dict = {'method': 'Browser.getWindowForTarget', 'params': params_dict}
    json_result = yield cmd_dict
    return WindowID.from_json(json_result['windowId']), Bounds.from_json(
        json_result['bounds'])


def grant_permissions(permissions: typing.List[PermissionType], origin:
    typing.Optional[str]=None, browser_context_id: typing.Optional[
    BrowserContextID]=None) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Grant specific permissions to the given origin and reject all others.

**EXPERIMENTAL**

:param ...:

:param permissions:

:param origin: *(Optional)* Origin the permission applies to, all origins if not specified.

:param browser_context_id: *(Optional)* BrowserContext to override permissions. When omitted, default browser context is used."""
    params_dict: T_JSON_DICT = dict()
    params_dict['permissions'] = [i.to_json() for i in permissions]
    if origin is not None:
        params_dict['origin'] = origin
    if browser_context_id is not None:
        params_dict['browserContextId'] = browser_context_id.to_json()
    cmd_dict = {'method': 'Browser.grantPermissions', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def reset_permissions(browser_context_id: typing.Optional[BrowserContextID]
    =None) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Reset all permission management for all origins.

:param ...:

:param browser_context_id: *(Optional)* BrowserContext to reset permissions. When omitted, default browser context is used."""
    params_dict: T_JSON_DICT = dict()
    if browser_context_id is not None:
        params_dict['browserContextId'] = browser_context_id.to_json()
    cmd_dict = {'method': 'Browser.resetPermissions', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def set_dock_tile(badge_label: typing.Optional[str]=None, image: typing.
    Optional[str]=None) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Set dock tile details, platform-specific.

**EXPERIMENTAL**

:param ...:

:param badge_label: *(Optional)*

:param image: *(Optional)* Png encoded image. (Encoded as a base64 string when passed over JSON)"""
    params_dict: T_JSON_DICT = dict()
    if badge_label is not None:
        params_dict['badgeLabel'] = badge_label
    if image is not None:
        params_dict['image'] = image
    cmd_dict = {'method': 'Browser.setDockTile', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def set_download_behavior(behavior: str, browser_context_id: typing.
    Optional[BrowserContextID]=None, download_path: typing.Optional[str]=
    None, events_enabled: typing.Optional[bool]=None) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, None]:
    """Set the behavior when downloading a file.

**EXPERIMENTAL**

:param ...:

:param behavior: Whether to allow all or deny all download requests, or use default Chrome behavior if available (otherwise deny). |allowAndName| allows download and names files according to their download guids.

:param browser_context_id: *(Optional)* BrowserContext to set download behavior. When omitted, default browser context is used.

:param download_path: *(Optional)* The default path to save downloaded files to. This is required if behavior is set to 'allow' or 'allowAndName'.

:param events_enabled: *(Optional)* Whether to emit download events (defaults to false)."""
    params_dict: T_JSON_DICT = dict()
    params_dict['behavior'] = behavior
    if browser_context_id is not None:
        params_dict['browserContextId'] = browser_context_id.to_json()
    if download_path is not None:
        params_dict['downloadPath'] = download_path
    if events_enabled is not None:
        params_dict['eventsEnabled'] = events_enabled
    cmd_dict = {'method': 'Browser.setDownloadBehavior', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def set_permission(permission: PermissionDescriptor, setting:
    PermissionSetting, origin: typing.Optional[str]=None,
    browser_context_id: typing.Optional[BrowserContextID]=None
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Set permission settings for given origin.

**EXPERIMENTAL**

:param ...:

:param permission: Descriptor of permission to override.

:param setting: Setting of the permission.

:param origin: *(Optional)* Origin the permission applies to, all origins if not specified.

:param browser_context_id: *(Optional)* Context to override. When omitted, default browser context is used."""
    params_dict: T_JSON_DICT = dict()
    params_dict['permission'] = permission.to_json()
    params_dict['setting'] = setting.to_json()
    if origin is not None:
        params_dict['origin'] = origin
    if browser_context_id is not None:
        params_dict['browserContextId'] = browser_context_id.to_json()
    cmd_dict = {'method': 'Browser.setPermission', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def set_window_bounds(window_id: WindowID, bounds: Bounds) ->typing.Generator[
    T_JSON_DICT, T_JSON_DICT, None]:
    """Set position and/or size of the browser window.

**EXPERIMENTAL**

:param ...:

:param window_id: Browser window id.

:param bounds: New window bounds. The 'minimized', 'maximized' and 'fullscreen' states cannot be combined with 'left', 'top', 'width' or 'height'. Leaves unspecified fields unchanged."""
    params_dict: T_JSON_DICT = dict()
    params_dict['windowId'] = window_id.to_json()
    params_dict['bounds'] = bounds.to_json()
    cmd_dict = {'method': 'Browser.setWindowBounds', 'params': params_dict}
    json_result = yield cmd_dict
    return None


@event_class('Browser.downloadProgress')
@dataclass
class DownloadProgress:
    """**EXPERIMENTAL**

Fired when download makes progress. Last call has |done| == true."""
    guid: str
    total_bytes: float
    received_bytes: float
    state: str

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->DownloadProgress:
        return cls(guid=json_obj['guid'], total_bytes=json_obj['totalBytes'
            ], received_bytes=json_obj['receivedBytes'], state=json_obj[
            'state'])


@event_class('Browser.downloadWillBegin')
@dataclass
class DownloadWillBegin:
    """**EXPERIMENTAL**

Fired when page is about to start a download."""
    frame_id: page.FrameId
    guid: str
    url: str
    suggested_filename: str

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->DownloadWillBegin:
        return cls(frame_id=page.FrameId.from_json(json_obj['frameId']),
            guid=json_obj['guid'], url=json_obj['url'], suggested_filename=
            json_obj['suggestedFilename'])
