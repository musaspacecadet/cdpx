# # DO NOT EDIT THIS FILE!
# #
# # This file is generated from the CDP specification using AST. If you need to make
# # changes, edit the generator and regenerate all of the modules.

from __future__ import annotations
"""CDP domain: Input"""
import typing
import enum
from dataclasses import dataclass
from .util import T_JSON_DICT, event_class
None


@dataclass
class DragData:
    items: typing.List[DragDataItem]
    drag_operations_mask: int
    files: typing.Optional[typing.List[str]] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['items'] = [i.to_json() for i in self.items]
        json_data['dragOperationsMask'] = self.drag_operations_mask
        if self.files is not None:
            json_data['files'] = [i for i in self.files]
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->DragData:
        return cls(items=[DragDataItem.from_json(i) for i in json_obj[
            'items']], drag_operations_mask=json_obj['dragOperationsMask'],
            files=[i for i in json_obj['files']] if json_obj.get('files')
             is not None else None)


@dataclass
class DragDataItem:
    mime_type: str
    data: str
    title: typing.Optional[str] = None
    base_url: typing.Optional[str] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['mimeType'] = self.mime_type
        json_data['data'] = self.data
        if self.title is not None:
            json_data['title'] = self.title
        if self.base_url is not None:
            json_data['baseURL'] = self.base_url
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->DragDataItem:
        return cls(mime_type=json_obj['mimeType'], data=json_obj['data'],
            title=json_obj['title'] if json_obj.get('title') is not None else
            None, base_url=json_obj['baseURL'] if json_obj.get('baseURL')
             is not None else None)


@dataclass
class TouchPoint:
    x: float
    y: float
    radius_x: typing.Optional[float] = None
    radius_y: typing.Optional[float] = None
    rotation_angle: typing.Optional[float] = None
    force: typing.Optional[float] = None
    tangential_pressure: typing.Optional[float] = None
    tilt_x: typing.Optional[float] = None
    tilt_y: typing.Optional[float] = None
    twist: typing.Optional[int] = None
    id_: typing.Optional[float] = None

    def to_json(self) ->T_JSON_DICT:
        json_data: T_JSON_DICT = dict()
        json_data['x'] = self.x
        json_data['y'] = self.y
        if self.radius_x is not None:
            json_data['radiusX'] = self.radius_x
        if self.radius_y is not None:
            json_data['radiusY'] = self.radius_y
        if self.rotation_angle is not None:
            json_data['rotationAngle'] = self.rotation_angle
        if self.force is not None:
            json_data['force'] = self.force
        if self.tangential_pressure is not None:
            json_data['tangentialPressure'] = self.tangential_pressure
        if self.tilt_x is not None:
            json_data['tiltX'] = self.tilt_x
        if self.tilt_y is not None:
            json_data['tiltY'] = self.tilt_y
        if self.twist is not None:
            json_data['twist'] = self.twist
        if self.id_ is not None:
            json_data['id'] = self.id_
        return json_data

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->TouchPoint:
        return cls(x=json_obj['x'], y=json_obj['y'], radius_x=json_obj[
            'radiusX'] if json_obj.get('radiusX') is not None else None,
            radius_y=json_obj['radiusY'] if json_obj.get('radiusY') is not
            None else None, rotation_angle=json_obj['rotationAngle'] if 
            json_obj.get('rotationAngle') is not None else None, force=
            json_obj['force'] if json_obj.get('force') is not None else
            None, tangential_pressure=json_obj['tangentialPressure'] if 
            json_obj.get('tangentialPressure') is not None else None,
            tilt_x=json_obj['tiltX'] if json_obj.get('tiltX') is not None else
            None, tilt_y=json_obj['tiltY'] if json_obj.get('tiltY') is not
            None else None, twist=json_obj['twist'] if json_obj.get('twist'
            ) is not None else None, id_=json_obj['id'] if json_obj.get(
            'id') is not None else None)


class GestureSourceType(enum.Enum):
    DEFAULT = 'default'
    TOUCH = 'touch'
    MOUSE = 'mouse'

    @classmethod
    def from_json(cls, json: str) ->GestureSourceType:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<GestureSourceType.{}>'.format(self.value)


class MouseButton(enum.Enum):
    NONE = 'none'
    LEFT = 'left'
    MIDDLE = 'middle'
    RIGHT = 'right'
    BACK = 'back'
    FORWARD = 'forward'

    @classmethod
    def from_json(cls, json: str) ->MouseButton:
        return cls(json)

    def to_json(self) ->str:
        return self.value

    def __repr__(self) ->str:
        return '<MouseButton.{}>'.format(self.value)


class TimeSinceEpoch(float):
    """UTC time in seconds, counted from January 1, 1970.

Represents the CDP type 'Input.TimeSinceEpoch'."""

    def to_json(self) ->float:
        return self

    @classmethod
    def from_json(cls, json: float) ->TimeSinceEpoch:
        return cls(json)

    def __repr__(self) ->str:
        return 'TimeSinceEpoch({})'.format(super().__repr__())


def cancel_dragging() ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Cancels any active dragging in the page."""
    cmd_dict = {'method': 'Input.cancelDragging'}
    json_result = yield cmd_dict
    return None


def dispatch_drag_event(type_: str, x: float, y: float, data: DragData,
    modifiers: typing.Optional[int]=None) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, None]:
    """Dispatches a drag event into the page.

**EXPERIMENTAL**

:param ...:

:param type_: Type of the drag event.

:param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.

:param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.

:param data:

:param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0)."""
    params_dict: T_JSON_DICT = dict()
    params_dict['type'] = type_
    params_dict['x'] = x
    params_dict['y'] = y
    params_dict['data'] = data.to_json()
    if modifiers is not None:
        params_dict['modifiers'] = modifiers
    cmd_dict = {'method': 'Input.dispatchDragEvent', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def dispatch_key_event(type_: str, modifiers: typing.Optional[int]=None,
    timestamp: typing.Optional[TimeSinceEpoch]=None, text: typing.Optional[
    str]=None, unmodified_text: typing.Optional[str]=None, key_identifier:
    typing.Optional[str]=None, code: typing.Optional[str]=None, key: typing
    .Optional[str]=None, windows_virtual_key_code: typing.Optional[int]=
    None, native_virtual_key_code: typing.Optional[int]=None, auto_repeat:
    typing.Optional[bool]=None, is_keypad: typing.Optional[bool]=None,
    is_system_key: typing.Optional[bool]=None, location: typing.Optional[
    int]=None, commands: typing.Optional[typing.List[str]]=None
    ) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Dispatches a key event to the page.

:param ...:

:param type_: Type of the key event.

:param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).

:param timestamp: *(Optional)* Time at which the event occurred.

:param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ``keyUp`` and ``rawKeyDown`` events (default: "")

:param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").

:param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").

:param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").

:param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").

:param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).

:param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).

:param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).

:param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).

:param is_system_key: *(Optional)* Whether the event was a system key event (default: false).

:param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).

:param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ``document.execCommand`` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names."""
    params_dict: T_JSON_DICT = dict()
    params_dict['type'] = type_
    if modifiers is not None:
        params_dict['modifiers'] = modifiers
    if timestamp is not None:
        params_dict['timestamp'] = timestamp.to_json()
    if text is not None:
        params_dict['text'] = text
    if unmodified_text is not None:
        params_dict['unmodifiedText'] = unmodified_text
    if key_identifier is not None:
        params_dict['keyIdentifier'] = key_identifier
    if code is not None:
        params_dict['code'] = code
    if key is not None:
        params_dict['key'] = key
    if windows_virtual_key_code is not None:
        params_dict['windowsVirtualKeyCode'] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params_dict['nativeVirtualKeyCode'] = native_virtual_key_code
    if auto_repeat is not None:
        params_dict['autoRepeat'] = auto_repeat
    if is_keypad is not None:
        params_dict['isKeypad'] = is_keypad
    if is_system_key is not None:
        params_dict['isSystemKey'] = is_system_key
    if location is not None:
        params_dict['location'] = location
    if commands is not None:
        params_dict['commands'] = [i for i in commands]
    cmd_dict = {'method': 'Input.dispatchKeyEvent', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def dispatch_mouse_event(type_: str, x: float, y: float, modifiers: typing.
    Optional[int]=None, timestamp: typing.Optional[TimeSinceEpoch]=None,
    button: typing.Optional[MouseButton]=None, buttons: typing.Optional[int
    ]=None, click_count: typing.Optional[int]=None, force: typing.Optional[
    float]=None, tangential_pressure: typing.Optional[float]=None, tilt_x:
    typing.Optional[float]=None, tilt_y: typing.Optional[float]=None, twist:
    typing.Optional[int]=None, delta_x: typing.Optional[float]=None,
    delta_y: typing.Optional[float]=None, pointer_type: typing.Optional[str
    ]=None) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Dispatches a mouse event to the page.

:param ...:

:param type_: Type of the mouse event.

:param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.

:param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.

:param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).

:param timestamp: *(Optional)* Time at which the event occurred.

:param button: *(Optional)* Mouse button (default: "none").

:param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.

:param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).

:param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).

:param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).

:param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).

:param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).

:param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).

:param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).

:param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).

:param pointer_type: *(Optional)* Pointer type (default: "mouse")."""
    params_dict: T_JSON_DICT = dict()
    params_dict['type'] = type_
    params_dict['x'] = x
    params_dict['y'] = y
    if modifiers is not None:
        params_dict['modifiers'] = modifiers
    if timestamp is not None:
        params_dict['timestamp'] = timestamp.to_json()
    if button is not None:
        params_dict['button'] = button.to_json()
    if buttons is not None:
        params_dict['buttons'] = buttons
    if click_count is not None:
        params_dict['clickCount'] = click_count
    if force is not None:
        params_dict['force'] = force
    if tangential_pressure is not None:
        params_dict['tangentialPressure'] = tangential_pressure
    if tilt_x is not None:
        params_dict['tiltX'] = tilt_x
    if tilt_y is not None:
        params_dict['tiltY'] = tilt_y
    if twist is not None:
        params_dict['twist'] = twist
    if delta_x is not None:
        params_dict['deltaX'] = delta_x
    if delta_y is not None:
        params_dict['deltaY'] = delta_y
    if pointer_type is not None:
        params_dict['pointerType'] = pointer_type
    cmd_dict = {'method': 'Input.dispatchMouseEvent', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def dispatch_touch_event(type_: str, touch_points: typing.List[TouchPoint],
    modifiers: typing.Optional[int]=None, timestamp: typing.Optional[
    TimeSinceEpoch]=None) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Dispatches a touch event to the page.

:param ...:

:param type_: Type of the touch event. TouchEnd and TouchCancel must not contain any touch points, while TouchStart and TouchMove must contains at least one.

:param touch_points: Active touch points on the touch device. One event per any changed point (compared to previous touch event in a sequence) is generated, emulating pressing/moving/releasing points one by one.

:param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).

:param timestamp: *(Optional)* Time at which the event occurred."""
    params_dict: T_JSON_DICT = dict()
    params_dict['type'] = type_
    params_dict['touchPoints'] = [i.to_json() for i in touch_points]
    if modifiers is not None:
        params_dict['modifiers'] = modifiers
    if timestamp is not None:
        params_dict['timestamp'] = timestamp.to_json()
    cmd_dict = {'method': 'Input.dispatchTouchEvent', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def emulate_touch_from_mouse_event(type_: str, x: int, y: int, button:
    MouseButton, timestamp: typing.Optional[TimeSinceEpoch]=None, delta_x:
    typing.Optional[float]=None, delta_y: typing.Optional[float]=None,
    modifiers: typing.Optional[int]=None, click_count: typing.Optional[int]
    =None) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """Emulates touch event from the mouse event parameters.

**EXPERIMENTAL**

:param ...:

:param type_: Type of the mouse event.

:param x: X coordinate of the mouse pointer in DIP.

:param y: Y coordinate of the mouse pointer in DIP.

:param button: Mouse button. Only "none", "left", "right" are supported.

:param timestamp: *(Optional)* Time at which the event occurred (default: current time).

:param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).

:param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).

:param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).

:param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0)."""
    params_dict: T_JSON_DICT = dict()
    params_dict['type'] = type_
    params_dict['x'] = x
    params_dict['y'] = y
    params_dict['button'] = button.to_json()
    if timestamp is not None:
        params_dict['timestamp'] = timestamp.to_json()
    if delta_x is not None:
        params_dict['deltaX'] = delta_x
    if delta_y is not None:
        params_dict['deltaY'] = delta_y
    if modifiers is not None:
        params_dict['modifiers'] = modifiers
    if click_count is not None:
        params_dict['clickCount'] = click_count
    cmd_dict = {'method': 'Input.emulateTouchFromMouseEvent', 'params':
        params_dict}
    json_result = yield cmd_dict
    return None


def ime_set_composition(text: str, selection_start: int, selection_end: int,
    replacement_start: typing.Optional[int]=None, replacement_end: typing.
    Optional[int]=None) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """This method sets the current candidate text for IME.
Use imeCommitComposition to commit the final text.
Use imeSetComposition with empty string as text to cancel composition.

**EXPERIMENTAL**

:param ...:

:param text: The text to insert

:param selection_start: selection start

:param selection_end: selection end

:param replacement_start: *(Optional)* replacement start

:param replacement_end: *(Optional)* replacement end"""
    params_dict: T_JSON_DICT = dict()
    params_dict['text'] = text
    params_dict['selectionStart'] = selection_start
    params_dict['selectionEnd'] = selection_end
    if replacement_start is not None:
        params_dict['replacementStart'] = replacement_start
    if replacement_end is not None:
        params_dict['replacementEnd'] = replacement_end
    cmd_dict = {'method': 'Input.imeSetComposition', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def insert_text(text: str) ->typing.Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """This method emulates inserting text that doesn't come from a key press,
for example an emoji keyboard or an IME.

**EXPERIMENTAL**

:param ...:

:param text: The text to insert."""
    params_dict: T_JSON_DICT = dict()
    params_dict['text'] = text
    cmd_dict = {'method': 'Input.insertText', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def set_ignore_input_events(ignore: bool) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, None]:
    """Ignores input events (useful while auditing page).

:param ...:

:param ignore: Ignores input events processing when set to true."""
    params_dict: T_JSON_DICT = dict()
    params_dict['ignore'] = ignore
    cmd_dict = {'method': 'Input.setIgnoreInputEvents', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def set_intercept_drags(enabled: bool) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, None]:
    """Prevents default drag and drop behavior and instead emits ``Input.dragIntercepted`` events.
Drag and drop behavior can be directly controlled via ``Input.dispatchDragEvent``.

**EXPERIMENTAL**

:param ...:

:param enabled:"""
    params_dict: T_JSON_DICT = dict()
    params_dict['enabled'] = enabled
    cmd_dict = {'method': 'Input.setInterceptDrags', 'params': params_dict}
    json_result = yield cmd_dict
    return None


def synthesize_pinch_gesture(x: float, y: float, scale_factor: float,
    relative_speed: typing.Optional[int]=None, gesture_source_type: typing.
    Optional[GestureSourceType]=None) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, None]:
    """Synthesizes a pinch gesture over a time period by issuing appropriate touch events.

**EXPERIMENTAL**

:param ...:

:param x: X coordinate of the start of the gesture in CSS pixels.

:param y: Y coordinate of the start of the gesture in CSS pixels.

:param scale_factor: Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms out).

:param relative_speed: *(Optional)* Relative pointer speed in pixels per second (default: 800).

:param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type)."""
    params_dict: T_JSON_DICT = dict()
    params_dict['x'] = x
    params_dict['y'] = y
    params_dict['scaleFactor'] = scale_factor
    if relative_speed is not None:
        params_dict['relativeSpeed'] = relative_speed
    if gesture_source_type is not None:
        params_dict['gestureSourceType'] = gesture_source_type.to_json()
    cmd_dict = {'method': 'Input.synthesizePinchGesture', 'params': params_dict
        }
    json_result = yield cmd_dict
    return None


def synthesize_scroll_gesture(x: float, y: float, x_distance: typing.
    Optional[float]=None, y_distance: typing.Optional[float]=None,
    x_overscroll: typing.Optional[float]=None, y_overscroll: typing.
    Optional[float]=None, prevent_fling: typing.Optional[bool]=None, speed:
    typing.Optional[int]=None, gesture_source_type: typing.Optional[
    GestureSourceType]=None, repeat_count: typing.Optional[int]=None,
    repeat_delay_ms: typing.Optional[int]=None, interaction_marker_name:
    typing.Optional[str]=None) ->typing.Generator[T_JSON_DICT, T_JSON_DICT,
    None]:
    """Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

**EXPERIMENTAL**

:param ...:

:param x: X coordinate of the start of the gesture in CSS pixels.

:param y: Y coordinate of the start of the gesture in CSS pixels.

:param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).

:param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).

:param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.

:param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.

:param prevent_fling: *(Optional)* Prevent fling (default: true).

:param speed: *(Optional)* Swipe speed in pixels per second (default: 800).

:param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).

:param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).

:param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).

:param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "")."""
    params_dict: T_JSON_DICT = dict()
    params_dict['x'] = x
    params_dict['y'] = y
    if x_distance is not None:
        params_dict['xDistance'] = x_distance
    if y_distance is not None:
        params_dict['yDistance'] = y_distance
    if x_overscroll is not None:
        params_dict['xOverscroll'] = x_overscroll
    if y_overscroll is not None:
        params_dict['yOverscroll'] = y_overscroll
    if prevent_fling is not None:
        params_dict['preventFling'] = prevent_fling
    if speed is not None:
        params_dict['speed'] = speed
    if gesture_source_type is not None:
        params_dict['gestureSourceType'] = gesture_source_type.to_json()
    if repeat_count is not None:
        params_dict['repeatCount'] = repeat_count
    if repeat_delay_ms is not None:
        params_dict['repeatDelayMs'] = repeat_delay_ms
    if interaction_marker_name is not None:
        params_dict['interactionMarkerName'] = interaction_marker_name
    cmd_dict = {'method': 'Input.synthesizeScrollGesture', 'params':
        params_dict}
    json_result = yield cmd_dict
    return None


def synthesize_tap_gesture(x: float, y: float, duration: typing.Optional[
    int]=None, tap_count: typing.Optional[int]=None, gesture_source_type:
    typing.Optional[GestureSourceType]=None) ->typing.Generator[T_JSON_DICT,
    T_JSON_DICT, None]:
    """Synthesizes a tap gesture over a time period by issuing appropriate touch events.

**EXPERIMENTAL**

:param ...:

:param x: X coordinate of the start of the gesture in CSS pixels.

:param y: Y coordinate of the start of the gesture in CSS pixels.

:param duration: *(Optional)* Duration between touchdown and touchup events in ms (default: 50).

:param tap_count: *(Optional)* Number of times to perform the tap (e.g. 2 for double tap, default: 1).

:param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type)."""
    params_dict: T_JSON_DICT = dict()
    params_dict['x'] = x
    params_dict['y'] = y
    if duration is not None:
        params_dict['duration'] = duration
    if tap_count is not None:
        params_dict['tapCount'] = tap_count
    if gesture_source_type is not None:
        params_dict['gestureSourceType'] = gesture_source_type.to_json()
    cmd_dict = {'method': 'Input.synthesizeTapGesture', 'params': params_dict}
    json_result = yield cmd_dict
    return None


@event_class('Input.dragIntercepted')
@dataclass
class DragIntercepted:
    """**EXPERIMENTAL**

Emitted only when ``Input.setInterceptDrags`` is enabled. Use this data with ``Input.dispatchDragEvent`` to
restore normal drag and drop behavior."""
    data: DragData

    @classmethod
    def from_json(cls, json_obj: T_JSON_DICT) ->DragIntercepted:
        return cls(data=DragData.from_json(json_obj['data']))
