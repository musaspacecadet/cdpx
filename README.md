**Python Syntax for Chrome DevTools Protocol (CDP)**

This document describes the Python syntax generated by the provided script for interacting with the Chrome DevTools Protocol (CDP).

**Purpose:** Automatically generate Python code from the CDP specification to create a type-safe, idiomatic library for browser interaction.

**Method:** Uses Python's `ast` module to build the code structure programmatically, ensuring syntactic correctness.

**CDP to Python Mapping:**

* **Domains:**
    * Base modules (`page.py`, `network.py`): Contain core type, event, and command definitions.
    * API Wrapper Classes (`api/page.py -> PageAPI`, `api/network.py -> NetworkAPI`): Provide blocking methods for commands.
* **Commands:**
    * In base modules: Generator functions that `yield` the command dictionary.
        ```python
        def navigate(url: str, ...) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, FrameId]:
            """Navigates to URL."""
            cmd_dict: T_JSON_DICT = {'method': 'Page.navigate', 'params': {'url': url, ...}}
            json_result = yield cmd_dict # Yields command, receives result
            return FrameId.from_json(json_result['frameId']) # Deserialize result
        ```
    * In API classes: Blocking methods wrapping the generator and `client.send()`.
        ```python
        class PageAPI:
            client: CDPClient
            def navigate(self, url: str, ...) -> page.FrameId: # Blocking method
                """Navigates to URL (blocking)."""
                gen = page.navigate(url=url, ...) # Call base generator
                return self.client.send(gen) # Send via client, return result
        ```
* **Events:** `dataclass` classes, often with `@event_class` decorator.
    ```python
    @event_class('Page.loadEventFired')
    @dataclass
    class LoadEventFired:
        """Page load event."""
        timestamp: float # Event parameter

        @classmethod
        def from_json(cls, json_obj: T_JSON_DICT) -> LoadEventFired:
            return cls(timestamp=json_obj['timestamp'])
    ```
* **Types:**
    * **Objects with Properties:** `dataclass` classes.
        ```python
        @dataclass
        class Frame:
            """Frame information."""
            id: FrameId # Uses generated type
            url: str
            # ... other fields

            @classmethod
            def from_json(cls, json_obj: T_JSON_DICT) -> Frame: ... # Deserialization logic
            def to_json(self) -> T_JSON_DICT: ... # Serialization logic
        ```
    * **Enums:** `enum.Enum` classes.
        ```python
        class TransitionType(enum.Enum):
            LINK = "link"
            TYPED = "typed"

            @classmethod
            def from_json(cls, json: str) -> TransitionType: ...
            def to_json(self) -> str: ...
        ```
    * **Simple Types/Aliases/Arrays:** Classes inheriting from base types or `typing` aliases.
        ```python
        class FrameId(str): ... # Inherits from str, adds from/to_json

        # Likely defined in base module
        # DOMRectList = typing.List[dom.DOMRect] # Example alias
        ```

**Key Syntax Elements:**

* **Type Hinting:** Extensive use of `typing` (`List`, `Optional`, `Tuple`) and generated types for clarity and static analysis.
    ```python
    param: typing.Optional[str] = None
    return_value: typing.List[MyType]
    ```
* **`@dataclass`:** Simplifies data classes for types and events.
* **`enum.Enum`:** Represents fixed sets of values (CDP enums).
* **`from_json` / `to_json`:** Class methods and instance methods for JSON conversion.
* **Generators (`yield`):** Decouple command definition from execution in base modules.
* **Decorators:** `@event_class`, `@deprecated`.

**`CDPClient` Protocol:**

* Defined in `util.py` (e.g., `class CDPClient(typing.Protocol): ...`).
* Specifies the interface (e.g., `send` method) that a user-provided communication layer must implement.
* Generated code *uses* a `CDPClient` instance but does not implement the low-level communication.

**Usage Example (Aggregated Client):**

```python
from cdp_generated import DevTools, CDPClient
from my_cdp_client import MyClient # User-provided client implementation

client_impl: CDPClient = MyClient(...) # Instantiate your client
cdp: DevTools = DevTools(client_impl) # Instantiate the generated wrapper

frame_id: cdp_generated.page.FrameId = cdp.page.navigate(url='https://example.com') # Call blocking API method
cookies: typing.List[cdp_generated.network.Cookie] = cdp.network.get_all_cookies()

print(f'Frame ID: {frame_id}, Cookies count: {len(cookies)}')
```

**Generated Package Structure:** Modular, separating base definitions (`domain.py`), API wrappers (`api/domain.py`), utilities (`util.py`), and the main client (`client.py`).

**Limitations:** Focuses on protocol translation; complex state management or high-level logic must be built on top of the generated code.