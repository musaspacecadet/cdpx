## ðŸš€ Getting Started with CDP in Python

This code base gives you direct access to Chrome DevTools Protocol (CDP) features using clean, type-safe Python syntax. Whether you're reverse engineering web apps, testing browser behavior, or automating complex flows â€” this toolkit lets you drive the browser like a DevTools pro.

### ðŸ”§ Prerequisites

  * Python 3.9+

  * Chrome/Chromium with remote debugging enabled: Run Chrome like this:

    ```bash
    chrome --remote-debugging-port=9222 --headless
    ```

  * For detailed information on the Chrome DevTools Protocol and its domains, please refer to the official [CDP Documentation](https://chromedevtools.github.io/devtools-protocol/).

-----

### âš™ï¸ Basic Example

```python
from cdp_generated import DevTools
from my_client import WebSocketCDPClient  # Your implementation of CDPClient protocol

client = WebSocketCDPClient("ws://localhost:9222/devtools/page/XYZ")
cdp = DevTools(client)

cdp.page.enable()
cdp.network.enable()

cdp.page.navigate(url="https://example.com")
load_event = client.wait_for_event(cdp.page.LoadEventFired)

print("Page loaded at:", load_event.timestamp)
```

-----

### ðŸ§ª Debug JavaScript and Inspect DOM

```python
cdp.debugger.enable()
cdp.dom.enable()

def is_js(event: cdp.debugger.ScriptParsed) -> bool:
    return event.script_language == cdp.debugger.ScriptLanguage.JAVA_SCRIPT

# Wait until a JS file is parsed
event = client.wait_for_event_where(cdp.debugger.ScriptParsed, is_js)

# Get its source
source, bytecode = cdp.debugger.get_script_source(event.script_id)
print("Script source:\n", source)

# Evaluate runtime JS
result, error = cdp.runtime.evaluate(expression="document.title")
print("Page title:", result.value)
```

-----

### ðŸŒ Intercept Network Requests

```python
cdp.network.enable()
cdp.network.set_cache_disabled(True)

def log_request(event: cdp.network.RequestWillBeSent):
    print("âž¡ï¸ Request to:", event.request.url)

client.add_event_listener(cdp.network.RequestWillBeSent, log_request)
cdp.page.navigate(url="https://example.com")
```

-----

### ðŸ§© Working With Frames

```python
cdp.page.enable()

frame_id = cdp.page.navigate(url="https://example.com")
frame_tree = cdp.page.get_frame_tree()

print("Main Frame:", frame_tree.frame.url)
```

-----

### ðŸ’¡ Tip

All commands are blocking by default when using `DevTools`. If you want low-level control over the request/response cycle, work with the base generator functions directly in the domain modules.

```python
from cdp_generated.page import navigate

gen = navigate(url="https://example.com")
frame_id = client.send(gen)
```

-----

**Python Syntax for Chrome DevTools Protocol (CDP)**

This document describes the Python syntax generated by the provided script for interacting with the Chrome DevTools Protocol (CDP).

**Purpose:** Automatically generate Python code from the CDP specification to create a type-safe, idiomatic interface for browser interaction.

**Method:** Uses Python's `ast` module to build the code structure programmatically, ensuring syntactic correctness.

**CDP to Python Mapping:**

  * **Domains:**

      * Base modules (`page.py`, `network.py`): Contain core type, event, and command definitions.
      * API Wrapper Classes (`api/page.py -> PageAPI`, `api/network.py -> NetworkAPI`): Provide blocking methods for commands.

  * **Commands:**

      * In base modules: Generator functions that `yield` the command dictionary.

        ```python
        def navigate(url: str, ...) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, FrameId]:
            """Navigates to URL."""
            cmd_dict: T_JSON_DICT = {'method': 'Page.navigate', 'params': {'url': url, ...}}
            json_result = yield cmd_dict # Yields command, receives result
            return FrameId.from_json(json_result['frameId']) # Deserialize result
        ```

      * In API classes: Blocking methods wrapping the generator and `client.send()`.

        ```python
        class PageAPI:
            client: CDPClient
            def navigate(self, url: str, ...) -> page.FrameId: # Blocking method
                """Navigates to URL (blocking)."""
                gen = page.navigate(url=url, ...) # Call base generator
                return self.client.send(gen) # Send via client, return result
        ```

  * **Events:** `dataclass` classes, often with `@event_class` decorator.

    ```python
    @event_class('Page.loadEventFired')
    @dataclass
    class LoadEventFired:
        """Page load event."""
        timestamp: float # Event parameter

        @classmethod
        def from_json(cls, json_obj: T_JSON_DICT) -> LoadEventFired:
            return cls(timestamp=json_obj['timestamp'])
    ```

  * **Types:**

      * **Objects with Properties:** `dataclass` classes.

        ```python
        @dataclass
        class Frame:
            """Frame information."""
            id: FrameId # Uses generated type
            url: str
            # ... other fields

            @classmethod
            def from_json(cls, json_obj: T_JSON_DICT) -> Frame: ... # Deserialization logic
            def to_json(self) -> T_JSON_DICT: ... # Serialization logic
        ```

      * **Enums:** `enum.Enum` classes.

        ```python
        class TransitionType(enum.Enum):
            LINK = "link"
            TYPED = "typed"

            @classmethod
            def from_json(cls, json: str) -> TransitionType: ...
            def to_json(self) -> str: ...
        ```

      * **Simple Types/Aliases/Arrays:** Classes inheriting from base types or `typing` aliases.

        ```python
        class FrameId(str): ... # Inherits from str, adds from/to_json

        # Likely defined in base module
        # DOMRectList = typing.List[dom.DOMRect] # Example alias
        ```

**Key Syntax Elements:**

  * **Type Hinting:** Extensive use of `typing` (`List`, `Optional`, `Tuple`) and generated types for clarity and static analysis.

    ```python
    param: typing.Optional[str] = None
    return_value: typing.List[MyType]
    ```

  * **`@dataclass`:** Simplifies data classes for types and events.

  * **`enum.Enum`:** Represents fixed sets of values (CDP enums).

  * **`from_json` / `to_json`:** Class methods and instance methods for JSON conversion.

  * **Generators (`yield`):** Decouple command definition from execution in base modules.

  * **Decorators:** `@event_class`, `@deprecated`.

**`CDPClient` Protocol:**

  * Defined in `util.py` (e.g., `class CDPClient(typing.Protocol): ...`).
  * Specifies the interface (e.g., `send` method) that a user-provided communication layer must implement.
  * Generated code *uses* a `CDPClient` instance but does not implement the low-level communication.

**Usage Example (Aggregated Client):**

```python
from cdp_generated import DevTools, CDPClient
from my_cdp_client import MyClient # User-provided client implementation

client_impl: CDPClient = MyClient(...) # Instantiate your client
cdp: DevTools = DevTools(client_impl) # Instantiate the generated wrapper

frame_id: cdp_generated.page.FrameId = cdp.page.navigate(url='https://example.com') # Call blocking API method
cookies: typing.List[cdp_generated.network.Cookie] = cdp.network.get_all_cookies()

print(f'Frame ID: {frame_id}, Cookies count: {len(cookies)}')
```

**Generated Package Structure:** Modular, separating base definitions (`domain.py`), API wrappers (`api/domain.py`), utilities (`util.py`), and the main client (`client.py`).

**Limitations:** Focuses on protocol translation; complex state management or high-level logic must be built on top of the generated code.
