# --- START OF FILE ast_new.py ---

# ast_generator.py
import ast
import astor # type: ignore
import os
import json
import typing
from typing import List, Set, Dict, Optional, Tuple # Use typing types
import shutil
import logging
import operator
from pathlib import Path
from dataclasses import dataclass

from .models import CdpType, CommandDefinition, DomainDefinition, EventDefinition, ProtocolDefinition, TypeDefinition # For local @dataclass usage if needed
from .ast_utils import (
        snake_case, pascal_case, create_import, create_import_from,
        create_import_from_relative, create_docstring_node,
        build_annotation_ast, build_from_json_expr, build_to_json_assign, UTIL_PY_CONTENT # Import the util content string
    )


log_level = getattr(logging, os.environ.get('LOG_LEVEL', 'INFO').upper())
logging.basicConfig(level=log_level, format='%(levelname)s:%(name)s:%(message)s')
logger = logging.getLogger(__name__) # Use current module name

# --- Constants ---
GENERATED_PACKAGE_NOTICE = """\
## Generated by PyCDP AST Generator

The modules of this package were generated by a custom generator using AST,
do not modify their contents because the changes will be overwritten in next generations.
"""

SHARED_HEADER = """\
# DO NOT EDIT THIS FILE!
#
# This file is generated from the CDP specification using AST. If you need to make
# changes, edit the generator and regenerate all of the modules."""

# Global state (consider managing this better if generator becomes complex)
current_protocol_version = ''

# --- AST Generation Functions for Base CDP Modules ---

def generate_type_alias_ast(
    type_def: TypeDefinition,
    current_domain_name: str
) -> typing.List[ast.stmt]:
    """
    Generates AST for simple type aliases (string, number, integer, boolean, any)
    and array types as classes inheriting from the base type (e.g., str, int, list),
    including from_json/to_json methods.
    """
    py_name = type_def.id
    nodes = []

    # --- Handle Array Types -> Generate Class Inheriting from list ---
    if type_def.type == CdpType.ARRAY:
        logger.debug(f"Generating {py_name} as list subclass (array type).")
        array_class_body = []
        doc = f"Represents the CDP array type '{type_def.domain_name}.{type_def.id}'."
        if type_def.description:
            doc = f"{type_def.description}\n\n{doc}"
        array_class_body.extend(create_docstring_node(doc))

        # Add experimental/deprecated markers to docstring
        if type_def.is_deprecated:
            # Assuming current_protocol_version is accessible globally or passed in
            global current_protocol_version
            array_class_body[0].value.s += f"\n\n.. deprecated:: {current_protocol_version or 'Unknown'}"
        if type_def.is_experimental:
            array_class_body[0].value.s += "\n\n**EXPERIMENTAL**"

        # --- Build Annotation for the underlying list items ---
        # Example: For Quad (List[float]), this builds the annotation for 'float'
        # For ArrayOfStringIndex (List[StringIndex]), this builds 'StringIndex'
        # Context should be 'base' as this is for the internal type representation
        item_annotation = build_annotation_ast(
            type_ref=type_def.items.type_ref if type_def.items else 'any', # Default to 'any' if items missing? CDP spec usually has items for array.
            items=None, # Items of items not relevant here
            is_optional=False, # Item type itself isn't optional within the list context
            current_domain_name=current_domain_name,
            context='base'
        )

        # --- Build Annotation for the full list type (e.g., typing.List[float]) ---
        list_annotation = ast.Subscript(
            value=ast.Attribute(value=ast.Name(id='typing', ctx=ast.Load()), attr='List', ctx=ast.Load()),
            slice=item_annotation,
            ctx=ast.Load()
        )

        # --- to_json(self) -> typing.List[ItemType] ---
        # For list wrappers, to_json just returns self.
        to_json_method = ast.FunctionDef(
            name='to_json',
            args=ast.arguments(posonlyargs=[], args=[ast.arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]),
            body=[ast.Return(value=ast.Name(id='self', ctx=ast.Load()))],
            decorator_list=[],
            returns=list_annotation # Returns the List[ItemType]
        )

        # --- from_json(cls, json: typing.List[ItemType]) -> TypeName ---
        # For list wrappers, from_json calls cls(json).
        from_json_method = ast.FunctionDef(
            name='from_json',
            args=ast.arguments(
                posonlyargs=[],
                args=[ast.arg(arg='cls'), ast.arg(arg='json', annotation=list_annotation)], # Input is List[ItemType]
                kwonlyargs=[], kw_defaults=[], defaults=[]
            ),
            body=[ast.Return(value=ast.Call(func=ast.Name(id='cls', ctx=ast.Load()), args=[ast.Name(id='json', ctx=ast.Load())], keywords=[]))],
            decorator_list=[ast.Name(id='classmethod', ctx=ast.Load())],
            returns=ast.Name(id=py_name, ctx=ast.Load()) # Return type is the class itself
        )

        # --- __repr__(self) ---
        repr_method = ast.FunctionDef(
            name='__repr__',
            args=ast.arguments(posonlyargs=[], args=[ast.arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]),
            body=[
                ast.Return(
                    value=ast.Call(
                        func=ast.Attribute(
                            value=ast.Constant(value=f'{py_name}({{}})'), # Format string like "Quad({})"
                            attr='format',
                            ctx=ast.Load()
                        ),
                         # Call list's __repr__ via super()
                        args=[ast.Call(
                                func=ast.Attribute(
                                    value=ast.Call(func=ast.Name(id='super',ctx=ast.Load()), args=[], keywords=[]), # super()
                                    attr='__repr__',
                                    ctx=ast.Load()
                                ),
                                args=[],
                                keywords=[]
                             )
                        ],
                        keywords=[]
                    )
                )
            ],
            decorator_list=[],
            returns=ast.Name(id='str', ctx=ast.Load())
        )

        array_class_body.extend([to_json_method, from_json_method, repr_method])

        # --- Final Class Definition for Array ---
        array_class_def = ast.ClassDef(
            name=py_name,
            bases=[ast.Name(id='list', ctx=ast.Load())], # Inherit from list
            keywords=[],
            body=array_class_body,
            decorator_list=[] # No dataclass decorator needed here
        )
        nodes.append(array_class_def)
        return nodes

    # --- Original Logic for Primitive Types (string, int, float, bool, any) ---
    # (Keep the existing logic for non-array primitive types here)
    # Determine the base Python type
    base_py_type: Optional[str] = None
    base_py_type_ast: Optional[ast.expr] = None # AST node for the base type
    if type_def.type == CdpType.STRING:
        base_py_type = 'str'
        base_py_type_ast = ast.Name(id='str', ctx=ast.Load())
    elif type_def.type == CdpType.INTEGER:
        base_py_type = 'int'
        base_py_type_ast = ast.Name(id='int', ctx=ast.Load())
    elif type_def.type == CdpType.NUMBER:
        base_py_type = 'float'
        base_py_type_ast = ast.Name(id='float', ctx=ast.Load())
    elif type_def.type == CdpType.BOOLEAN:
        base_py_type = 'bool'
        base_py_type_ast = ast.Name(id='bool', ctx=ast.Load())
    elif type_def.type == CdpType.ANY:
        base_py_type = 'typing.Any'
        base_py_type_ast = ast.Attribute(value=ast.Name(id='typing', ctx=ast.Load()), attr='Any', ctx=ast.Load())
        base_class_ast = ast.Name(id='object', ctx=ast.Load()) # Inherit from object for 'any'
    else:
        # Should not happen for simple types, but handle defensively
        logger.warning(f"Unexpected type '{type_def.type}' encountered in generate_type_alias_ast for {py_name}. Treating as 'any'.")
        base_py_type = 'typing.Any'
        base_py_type_ast = ast.Attribute(value=ast.Name(id='typing', ctx=ast.Load()), attr='Any', ctx=ast.Load())
        base_class_ast = ast.Name(id='object', ctx=ast.Load())

    if 'base_class_ast' not in locals():
         # Use the type name AST as the base class (str, int, float, bool)
        base_class_ast = base_py_type_ast

    # --- Class Body for Primitives ---
    class_body = []
    doc = f"Represents the CDP type '{type_def.domain_name}.{type_def.id}'."
    if type_def.description:
        doc = f"{type_def.description}\n\n{doc}"
    class_body.extend(create_docstring_node(doc))

    if type_def.is_deprecated:
        class_body[0].value.s += f"\n\n.. deprecated:: {current_protocol_version or 'Unknown'}"
    if type_def.is_experimental:
        class_body[0].value.s += "\n\n**EXPERIMENTAL**"

    # to_json for primitives
    to_json_method = ast.FunctionDef(
        name='to_json',
        args=ast.arguments(posonlyargs=[], args=[ast.arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]),
        body=[ast.Return(value=ast.Name(id='self', ctx=ast.Load()))],
        decorator_list=[],
        returns=base_py_type_ast
    )

    # from_json for primitives
    from_json_method = ast.FunctionDef(
        name='from_json',
        args=ast.arguments(
            posonlyargs=[],
            args=[ast.arg(arg='cls'), ast.arg(arg='json', annotation=base_py_type_ast)],
            kwonlyargs=[], kw_defaults=[], defaults=[]
        ),
        body=[ast.Return(value=ast.Call(func=ast.Name(id='cls', ctx=ast.Load()), args=[ast.Name(id='json', ctx=ast.Load())], keywords=[]))],
        decorator_list=[ast.Name(id='classmethod', ctx=ast.Load())],
        returns=ast.Name(id=py_name, ctx=ast.Load())
    )

    # __repr__ for primitives
    repr_method = ast.FunctionDef(
        name='__repr__',
        args=ast.arguments(posonlyargs=[], args=[ast.arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]),
        body=[
            ast.Return(
                value=ast.Call(
                    func=ast.Attribute(value=ast.Constant(value=f'{py_name}({{}})'), attr='format', ctx=ast.Load()),
                    args=[ast.Call(func=ast.Attribute(value=ast.Call(func=ast.Name(id='super',ctx=ast.Load()), args=[], keywords=[]), attr='__repr__', ctx=ast.Load()), args=[], keywords=[])],
                    keywords=[]
                )
            )
        ],
        decorator_list=[],
        returns=ast.Name(id='str', ctx=ast.Load())
    )

    class_body.extend([to_json_method, from_json_method, repr_method])

    # Final Class Definition for Primitives
    class_def = ast.ClassDef(
        name=py_name,
        bases=[base_class_ast],
        keywords=[],
        body=class_body,
        decorator_list=[]
    )
    nodes.append(class_def)
    return nodes

def generate_enum_ast(type_def: TypeDefinition) -> ast.ClassDef:
    """Generates AST for an Enum class."""
    enum_name = type_def.id
    body = create_docstring_node(type_def.description)

    if not type_def.enum_values:
         logger.warning(f"Enum type {type_def.domain_name}.{enum_name} has no enum_values defined.")
         # Create an empty enum? Or return empty list?
         # Returning class def anyway for consistency, user will see it's empty.

    for member in type_def.enum_values or []:
        # Enum members should be UPPER_SNAKE_CASE
        member_name = snake_case(member).upper()
        # Basic check for invalid enum member names (e.g., starting with number, keyword)
        # `snake_case` already handles keywords by adding trailing `_`
        if not member_name.isidentifier() or member_name.startswith('_'):
             member_name = f"VAL_{member_name}" # Simple prefixing if starts with _ or is otherwise invalid
             logger.debug(f"Enum member '{member}' renamed to '{member_name}' in {enum_name}")
        assign = ast.Assign(
            targets=[ast.Name(id=member_name, ctx=ast.Store())],
            value=ast.Constant(value=member)
        )
        body.append(assign)

    # --- Standard Enum Methods ---
    # from_json(cls, json: str) -> EnumName: return cls(json)
    from_json_method = ast.FunctionDef(
        name='from_json',
        args=ast.arguments(
            posonlyargs=[],
            args=[ast.arg(arg='cls'), ast.arg(arg='json', annotation=ast.Name(id='str', ctx=ast.Load()))],
            kwonlyargs=[], kw_defaults=[], defaults=[]
        ),
        body=[ast.Return(value=ast.Call(func=ast.Name(id='cls', ctx=ast.Load()), args=[ast.Name(id='json', ctx=ast.Load())], keywords=[]))],
        decorator_list=[ast.Name(id='classmethod', ctx=ast.Load())],
        returns=ast.Name(id=enum_name, ctx=ast.Load()) # Return type is the enum itself
    )

    # to_json(self) -> str: return self.value
    to_json_method = ast.FunctionDef(
        name='to_json',
        args=ast.arguments(posonlyargs=[], args=[ast.arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]),
        body=[ast.Return(value=ast.Attribute(value=ast.Name(id='self', ctx=ast.Load()), attr='value', ctx=ast.Load()))],
        decorator_list=[],
        returns=ast.Name(id='str', ctx=ast.Load())
    )

    # __repr__ method (optional but helpful)
    repr_method = ast.FunctionDef(
        name='__repr__',
        args=ast.arguments(posonlyargs=[], args=[ast.arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]),
        body=[ast.Return(value=ast.Call(
            func=ast.Attribute(value=ast.Constant(value=f'<{enum_name}.{{}}>'), attr='format', ctx=ast.Load()),
            args=[ast.Attribute(value=ast.Name(id='self', ctx=ast.Load()), attr='value', ctx=ast.Load())],
            keywords=[]
        ))],
        decorator_list=[],
        returns=ast.Name(id='str', ctx=ast.Load())
    )

    body.extend([from_json_method, to_json_method, repr_method])

    # --- Decorators ---
    decorators = []
    # TODO: Add @deprecated if type_def.is_deprecated (needs handling similar to commands)

    return ast.ClassDef(
        name=enum_name,
        bases=[ast.Attribute(value=ast.Name(id='enum', ctx=ast.Load()), attr='Enum', ctx=ast.Load())],
        keywords=[],
        body=body,
        decorator_list=decorators
    )

def generate_dataclass_ast(
    type_def: TypeDefinition,
    current_domain_name: str
) -> typing.Union[ast.ClassDef, typing.List[ast.stmt]]: # Return type might be list if we generate helper alias
    """
    Generates AST for a CDP object type.
    - If properties exist, generates a @dataclass.
    - If no properties exist, generates a class inheriting from dict
      (representing a generic JSON object like Headers).
    """
    class_name = type_def.id

    # --- Case 1: Object type with NO properties (e.g., Headers) ---
    if not type_def.properties:
        logger.debug(f"Generating {class_name} as dict subclass (object type with no properties).")
        # Generate class Name(dict): ...
        dict_class_body = []
        doc = f"Represents the CDP object type '{type_def.domain_name}.{type_def.id}'. \nMaps to a dictionary."
        if type_def.description:
            doc = f"{type_def.description}\n\n{doc}"
        dict_class_body.extend(create_docstring_node(doc))

        # Add experimental/deprecated markers to docstring
        if type_def.is_deprecated:
            dict_class_body[0].value.s += f"\n\n.. deprecated:: {current_protocol_version or 'Unknown'}"
        if type_def.is_experimental:
            dict_class_body[0].value.s += "\n\n**EXPERIMENTAL**"

        # Assume T_JSON_DICT is imported (typing.Dict[str, typing.Any])
        json_dict_annotation = ast.Name(id='T_JSON_DICT', ctx=ast.Load())

        # to_json(self) -> T_JSON_DICT: return self
        to_json_method = ast.FunctionDef(
            name='to_json',
            args=ast.arguments(posonlyargs=[], args=[ast.arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]),
            body=[ast.Return(value=ast.Name(id='self', ctx=ast.Load()))],
            decorator_list=[],
            returns=json_dict_annotation
        )

        # from_json(cls, json: T_JSON_DICT) -> ClassName: return cls(json)
        from_json_method = ast.FunctionDef(
            name='from_json',
            args=ast.arguments(
                posonlyargs=[],
                args=[ast.arg(arg='cls'), ast.arg(arg='json_obj', annotation=json_dict_annotation)],
                kwonlyargs=[], kw_defaults=[], defaults=[]
            ),
            body=[ast.Return(value=ast.Call(func=ast.Name(id='cls', ctx=ast.Load()), args=[ast.Name(id='json_obj', ctx=ast.Load())], keywords=[]))],
            decorator_list=[ast.Name(id='classmethod', ctx=ast.Load())],
            returns=ast.Name(id=class_name, ctx=ast.Load()) # Returns the class itself
        )

        # __repr__(self)
        repr_method = ast.FunctionDef(
            name='__repr__',
            args=ast.arguments(posonlyargs=[], args=[ast.arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]),
            body=[
                ast.Return(
                    value=ast.Call(
                        func=ast.Attribute(
                            value=ast.Constant(value=f'{class_name}({{}})'), # Format string like "Headers({})"
                            attr='format',
                            ctx=ast.Load()
                        ),
                         # Call dict's __repr__ via super()
                        args=[ast.Call(
                                func=ast.Attribute(
                                    value=ast.Call(func=ast.Name(id='super',ctx=ast.Load()), args=[], keywords=[]), # super()
                                    attr='__repr__',
                                    ctx=ast.Load()
                                ),
                                args=[],
                                keywords=[]
                             )
                        ],
                        keywords=[]
                    )
                )
            ],
            decorator_list=[],
            returns=ast.Name(id='str', ctx=ast.Load())
        )

        dict_class_body.extend([to_json_method, from_json_method, repr_method])

        # Create the class definition inheriting from dict
        dict_class_def = ast.ClassDef(
            name=class_name,
            bases=[ast.Name(id='dict', ctx=ast.Load())], # Inherit from dict
            keywords=[],
            body=dict_class_body,
            decorator_list=[] # No @dataclass
        )
        # Return as list for consistency, although it's just one class def
        return [dict_class_def] # Important: wrap in list if generate_domain_module_ast expects list


    # --- Case 2: Object type WITH properties (Existing Dataclass Logic) ---
    # (Keep the existing logic for generating dataclasses when properties exist)
    body = create_docstring_node(type_def.description)

    # Properties - sorted by optionality
    sorted_props = sorted(type_def.properties, key=lambda p: p.is_optional)

    prop_assignments = []
    for prop in sorted_props:
        prop_name = snake_case(prop.name)
        annotation = build_annotation_ast(
            prop.type_ref, prop.items, prop.is_optional,
            current_domain_name,
            context='base'
        )
        assign = ast.AnnAssign(
            target=ast.Name(id=prop_name, ctx=ast.Store()),
            annotation=annotation,
            value=ast.Constant(value=None) if prop.is_optional else None,
            simple=1
        )
        prop_assignments.append(assign)

    # Add fields only if there are any (this condition is now implicitly true here)
    body.extend(prop_assignments)

    # --- to_json Method ---
    to_json_body: List[ast.stmt] = [
        ast.AnnAssign(
            target=ast.Name(id='json_data', ctx=ast.Store()),
            annotation=ast.Name(id='T_JSON_DICT', ctx=ast.Load()),
            value=ast.Call(func=ast.Name(id='dict', ctx=ast.Load()), args=[], keywords=[]),
            simple=1
        )
    ]
    for prop in sorted_props:
        to_json_body.extend(build_to_json_assign(prop, 'json_data', source_obj_name='self'))
    to_json_body.append(ast.Return(value=ast.Name(id='json_data', ctx=ast.Load())))

    to_json_method = ast.FunctionDef(
        name='to_json',
        args=ast.arguments(posonlyargs=[], args=[ast.arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]),
        body=to_json_body,
        decorator_list=[],
        returns=ast.Name(id='T_JSON_DICT', ctx=ast.Load())
    )

    # --- from_json Method ---
    from_json_args = []
    for prop in sorted_props:
        prop_name = snake_case(prop.name)
        from_json_args.append(ast.keyword(
            arg=prop_name,
            value=build_from_json_expr(prop, 'json_obj', current_domain_name)
        ))

    from_json_method = ast.FunctionDef(
        name='from_json',
        args=ast.arguments(
            posonlyargs=[],
            args=[ast.arg(arg='cls'), ast.arg(arg='json_obj', annotation=ast.Name(id='T_JSON_DICT', ctx=ast.Load()))],
            kwonlyargs=[], kw_defaults=[], defaults=[]
        ),
        body=[
            ast.Return(value=ast.Call(
                func=ast.Name(id='cls', ctx=ast.Load()),
                args=[],
                keywords=from_json_args
            ))
        ],
        decorator_list=[ast.Name(id='classmethod', ctx=ast.Load())],
        returns=ast.Name(id=class_name, ctx=ast.Load())
    )

    body.extend([to_json_method, from_json_method])

    # --- Decorators ---
    decorators = [ast.Name(id='dataclass', ctx=ast.Load())]
    if type_def.is_deprecated:
         decorators.append(ast.Call( # Add deprecated decorator if needed
            func=ast.Name(id='deprecated', ctx=ast.Load()),
            args=[],
            keywords=[ast.keyword(arg='version', value=ast.Constant(value=current_protocol_version or 'Unknown'))]
        ))
    # Note: Experimental might be better in docstring for classes

    dataclass_def = ast.ClassDef(
        name=class_name,
        bases=[],
        keywords=[],
        body=body,
        decorator_list=decorators
    )
    # Important: Return as list item if generate_domain_module_ast expects a list
    return [dataclass_def]

def generate_command_ast(
    command_def: CommandDefinition,
    current_domain_name: str # Domain where command is defined
) -> ast.FunctionDef:
    """Generates AST for a command function (as a generator) in the base module."""
    py_name = snake_case(command_def.name)

    # --- Parameters ---
    params = command_def.parameters
    sorted_params = sorted(params, key=lambda p: p.is_optional)
    args_list = []
    param_docs = []

    for param in sorted_params:
        param_py_name = snake_case(param.name)
        # Build annotation in base context
        annotation = build_annotation_ast(
            param.type_ref, param.items, param.is_optional,
            current_domain_name, # Domain being generated
            context='base' # Context is base module
        )
        args_list.append(ast.arg(
            arg=param_py_name,
            annotation=annotation,
            # Default value for optional params
            default=ast.Constant(value=None) if param.is_optional else None
        ))
        # Build param docstring lines
        doc_line = f":param {param_py_name}:"
        if param.is_deprecated: doc_line += " **(DEPRECATED)**"
        if param.is_experimental: doc_line += " **(EXPERIMENTAL)**"
        if param.is_optional: doc_line += " *(Optional)*"
        if param.description: doc_line += f" {param.description.replace(chr(10), ' ')}" # Flatten description
        param_docs.append(doc_line)

    # Extract defaults for the arguments object
    defaults = [a.default for a in args_list if a.default is not None]

    # --- Return Type Annotation ---
    returns = command_def.returns
    return_doc = None # Docstring part for returns

    if not returns:
        # Inner type is None
        return_annotation_inner = ast.Name(id='None', ctx=ast.Load())
        # No return doc needed for None return
    elif len(returns) == 1:
        ret_field = returns[0]
        # Build annotation in base context
        return_annotation_inner = build_annotation_ast(
            ret_field.type_ref, ret_field.items, ret_field.is_optional,
            current_domain_name, # Domain being generated
            context='base', # Context is base module
            is_return_annotation=True
        )
        ret_doc_desc = ret_field.description or ''
        if ret_field.is_optional: ret_doc_desc = f"*(Optional)* {ret_doc_desc}"
        return_doc = f":returns: {ret_doc_desc.replace(chr(10), ' ')}"
    else: # Multiple return values -> Tuple
        tuple_elts = []
        ret_docs_list = []
        for i, ret_field in enumerate(returns):
            # Build annotation in base context
            tuple_elts.append(build_annotation_ast(
                ret_field.type_ref, ret_field.items, ret_field.is_optional,
                current_domain_name, context='base', is_return_annotation=True
            ))
            r_doc = ret_field.description or ''
            if ret_field.is_optional: r_doc = f"*(Optional)* {r_doc}"
            ret_docs_list.append(f"    {i+1}. **{ret_field.name}** - {r_doc.replace(chr(10), ' ')}")

        return_annotation_inner = ast.Subscript(
            value=ast.Attribute(value=ast.Name(id='typing', ctx=ast.Load()), attr='Tuple', ctx=ast.Load()),
            slice=ast.Tuple(elts=tuple_elts, ctx=ast.Load()),
            ctx=ast.Load()
        )
        return_doc = ":returns: A tuple with the following items:\n\n" + "\n".join(ret_docs_list)

    # Final Generator annotation: typing.Generator[T_JSON_DICT, T_JSON_DICT, ReturnType]
    # Assume T_JSON_DICT is imported
    generator_annotation = ast.Subscript(
        value=ast.Attribute(value=ast.Name(id='typing', ctx=ast.Load()), attr='Generator', ctx=ast.Load()),
        slice=ast.Tuple(elts=[ast.Name(id='T_JSON_DICT', ctx=ast.Load()),
                              ast.Name(id='T_JSON_DICT', ctx=ast.Load()),
                              return_annotation_inner], ctx=ast.Load()),
        ctx=ast.Load()
    )

    # --- Function Body ---
    body: typing.List[ast.stmt] = []

    # Docstring
    docstring_parts = []
    if command_def.description: docstring_parts.append(command_def.description)
    if command_def.redirect: docstring_parts.append(f"Redirects to command '{command_def.redirect}'.")
    if command_def.is_deprecated: docstring_parts.append(f".. deprecated:: {current_protocol_version or 'Unknown'}") # Use global version
    if command_def.is_experimental: docstring_parts.append("**EXPERIMENTAL**")
    if param_docs: docstring_parts.extend(["", ":param ...:"] if not command_def.description else [":param ...:"]) # Separator needed?
    if param_docs: docstring_parts.extend(param_docs)
    if return_doc: docstring_parts.extend(["", return_doc]) # Separator needed?
    full_docstring = "\n\n".join(docstring_parts).replace("\n\n\n", "\n\n") # Clean up excessive newlines
    body.extend(create_docstring_node(full_docstring))

    # Build command dict elements as list of tuples: [(key_expr, value_expr)]
    cmd_dict_key_vals: List[Tuple[ast.expr, ast.expr]] = [
        (ast.Constant(value='method'), ast.Constant(value=f'{current_domain_name}.{command_def.name}'))
    ]

    if params:
        # params_dict: T_JSON_DICT = dict()
        body.append(ast.AnnAssign(
            target=ast.Name(id='params_dict', ctx=ast.Store()),
            annotation=ast.Name(id='T_JSON_DICT', ctx=ast.Load()),
            value=ast.Call(func=ast.Name(id='dict', ctx=ast.Load()), args=[], keywords=[]),
            simple=1
        ))
        # Populate params_dict using build_to_json_assign helper
        for param in params:
             param_var_name = snake_case(param.name)
             # Source is the function parameter variable itself
             body.extend(build_to_json_assign(
                 param,
                 'params_dict',
                 source_expr=ast.Name(id=param_var_name, ctx=ast.Load()), # Pass param variable AST node
                 source_obj_name=None # Ignore object name when source_expr is given
             ))
        # Add 'params': params_dict to the command dict elements
        cmd_dict_key_vals.append(
             (ast.Constant(value='params'), ast.Name(id='params_dict', ctx=ast.Load()))
        )

    # Create the actual command dictionary AST node
    cmd_dict_assign = ast.Assign(
        targets=[ast.Name(id='cmd_dict', ctx=ast.Store())],
        value=ast.Dict(keys=[k for k,v in cmd_dict_key_vals],
                       values=[v for k,v in cmd_dict_key_vals])
    )
    body.append(cmd_dict_assign)

    # json_result = yield cmd_dict
    yield_expr = ast.Yield(value=ast.Name(id='cmd_dict', ctx=ast.Load()))
    json_result_assign = ast.Assign(
        targets=[ast.Name(id='json_result', ctx=ast.Store())],
        value=yield_expr
    )
    body.append(json_result_assign)

    # Return value processing - use build_from_json_expr with base context
    if not returns:
        # No return statement needed, generator implicitly returns None
        # Add explicit `return None` for clarity if preferred
        body.append(ast.Return(value=ast.Constant(value=None)))
    elif len(returns) == 1:
        return_expr = build_from_json_expr(returns[0], 'json_result', current_domain_name)
        body.append(ast.Return(value=return_expr))
    else: # Tuple return
        return_elements = [build_from_json_expr(r, 'json_result', current_domain_name) for r in returns]
        body.append(ast.Return(value=ast.Tuple(elts=return_elements, ctx=ast.Load())))


    # --- Decorators ---
    decorators = []
    if command_def.is_deprecated:
        # @deprecated(version="...") - Assuming 'deprecated' is imported
        decorators.append(ast.Call(
            func=ast.Name(id='deprecated', ctx=ast.Load()),
            args=[],
            keywords=[ast.keyword(arg='version', value=ast.Constant(value=current_protocol_version or 'Unknown'))]
        ))
    # TODO: Add @experimental decorator if desired/available

    # --- Final FunctionDef ---
    return ast.FunctionDef(
        name=py_name,
        args=ast.arguments(
            posonlyargs=[],
            args=args_list,
            kwonlyargs=[],
            kw_defaults=[],
            defaults=defaults # Use the extracted defaults list
        ),
        body=body,
        decorator_list=decorators,
        returns=generator_annotation
    )

def generate_event_ast(
    event_def: EventDefinition,
    current_domain_name: str
) -> ast.ClassDef:
    """Generates AST for an event dataclass."""
    class_name = pascal_case(event_def.name) # Use PascalCase for event classes
    body = []

    # --- Docstring ---
    docstring_parts = []
    if event_def.is_experimental: docstring_parts.append("**EXPERIMENTAL**")
    if event_def.description: docstring_parts.append(event_def.description)
    if event_def.is_deprecated: docstring_parts.append(f".. deprecated:: {current_protocol_version or 'Unknown'}")
    full_docstring = "\n\n".join(docstring_parts)
    body.extend(create_docstring_node(full_docstring))

    # --- Properties (as AnnAssign for dataclass) ---
    params = event_def.parameters
    prop_assignments = []
    # Event parameters are typically all required from the protocol's perspective
    # but we should still respect the 'optional' flag if present in the spec.
    sorted_params = sorted(params, key=lambda p: p.is_optional)

    for param in sorted_params:
         param_py_name = snake_case(param.name)
         # Build annotation in base context
         annotation = build_annotation_ast(
             param.type_ref, param.items, param.is_optional, # Use is_optional from definition
             current_domain_name, # Domain being generated
             context='base' # Context is base module
         )
         # Use AnnAssign for dataclass fields
         assign = ast.AnnAssign(
             target=ast.Name(id=param_py_name, ctx=ast.Store()),
             annotation=annotation,
             # Add default=None if optional, otherwise no default needed for required fields
             value=ast.Constant(value=None) if param.is_optional else None,
             simple=1
         )
         prop_assignments.append(assign)

    if prop_assignments:
        body.extend(prop_assignments)
    else:
        body.append(ast.Pass()) # Add pass if event has no parameters


    # --- from_json Method ---
    from_json_args = []
    for param in sorted_params: # Use sorted params consistent with AnnAssigns
         param_py_name = snake_case(param.name)
         from_json_args.append(ast.keyword(
             arg=param_py_name,
             # Pass current domain name context, uses context='base' internally
             value=build_from_json_expr(param, 'json_obj', current_domain_name)
         ))

    from_json_method = ast.FunctionDef(
        name='from_json',
        args=ast.arguments(
            posonlyargs=[],
            args=[ast.arg(arg='cls'), ast.arg(arg='json_obj', annotation=ast.Name(id='T_JSON_DICT', ctx=ast.Load()))],
            kwonlyargs=[], kw_defaults=[], defaults=[]
        ),
        body=[
            ast.Return(value=ast.Call(
                func=ast.Name(id='cls', ctx=ast.Load()),
                args=[],
                keywords=from_json_args
            ))
        ],
        decorator_list=[ast.Name(id='classmethod', ctx=ast.Load())],
        returns=ast.Name(id=class_name, ctx=ast.Load()) # Return the class itself (by name)
    )

    # Add method only if there are parameters
    #if prop_assignments:
    body.append(from_json_method)

    # --- Decorators ---
    # Use event_class decorator (assumed imported from .util)
    event_class_decorator = ast.Call(
         func=ast.Name(id='event_class', ctx=ast.Load()),
         args=[ast.Constant(value=f'{current_domain_name}.{event_def.name}')],
         keywords=[]
    )
    dataclass_decorator = ast.Name(id='dataclass', ctx=ast.Load())
    decorators = [event_class_decorator, dataclass_decorator] # Order matters? dataclass first?

    if event_def.is_deprecated:
         # @deprecated(version="...")
         decorators.insert(0, ast.Call( # Insert before event_class/dataclass
             func=ast.Name(id='deprecated', ctx=ast.Load()),
             args=[],
             keywords=[ast.keyword(arg='version', value=ast.Constant(value=current_protocol_version or 'Unknown'))]
         ))

    return ast.ClassDef(
        name=class_name,
        bases=[],
        keywords=[],
        body=body,
        decorator_list=decorators
    )

def generate_domain_module_ast(domain_def: DomainDefinition, protocol: ProtocolDefinition) -> ast.Module:
    """Generates the complete AST for a base domain module (e.g., page.py)."""
    module_body: typing.List[ast.stmt] = []
    current_domain_name = domain_def.name

    # --- Future Imports ---
    module_body.append(create_import_from('__future__', ['annotations']))

    # --- Module Docstring ---
    exp = ' (experimental)' if domain_def.is_experimental else ''
    depr = ' (deprecated)' if domain_def.is_deprecated else ''
    module_doc = f"CDP domain: {domain_def.name}{exp}{depr}"
    if domain_def.description:
         module_doc += f"\n\n{domain_def.description}"
    module_body.extend(create_docstring_node(module_doc))

    # --- Standard Imports ---
    needs_dataclasses = False
    needs_deprecated = domain_def.is_deprecated # Module itself can be deprecated

    # Check if dataclasses are needed (for object types or events)
    if any(t.type == CdpType.OBJECT for t in domain_def.types.values()) or domain_def.events:
         needs_dataclasses = True

    # Check if deprecated needed for types, commands, events
    if not needs_deprecated:
        needs_deprecated = (
            any(t.is_deprecated for t in domain_def.types.values()) or
            any(c.is_deprecated for c in domain_def.commands.values()) or
            any(e.is_deprecated for e in domain_def.events.values())
        )

    # --- Collect Cross-Domain Dependencies ---
    dependencies: Set[str] = set(domain_def.dependencies) # Start with explicit ones
    refs: Set[Optional[str]] = set()

    for type_def in domain_def.types.values():
        if type_def.type == CdpType.OBJECT:
            needs_dataclasses = True # Ensure dataclasses is imported if object type exists
            for prop in type_def.properties:
                 refs.add(prop.type_ref)
                 if prop.items: refs.add(prop.items.type_ref)
        elif type_def.items:
             refs.add(type_def.items.type_ref)
        # Enums, basic types don't add cross-domain refs generally

    for cmd_def in domain_def.commands.values():
        for item in cmd_def.parameters + cmd_def.returns:
            refs.add(item.type_ref)
            if item.items: refs.add(item.items.type_ref)

    for event_def in domain_def.events.values():
        needs_dataclasses = True # Events use dataclasses
        for param in event_def.parameters:
            refs.add(param.type_ref)
            if param.items: refs.add(param.items.type_ref)

    # Add referenced domains to dependencies, excluding self and invalid refs
    for ref in refs:
        if ref and '.' in ref:
            ref_domain_name, _ = ref.split('.', 1)
            # Check if the domain exists in the protocol and is not the current one
            if ref_domain_name != current_domain_name and ref_domain_name in protocol.domains:
                 dependencies.add(ref_domain_name)

    # --- Generate Import AST Nodes ---
    module_body.append(create_import('typing'))
    module_body.append(create_import('enum'))
    if needs_dataclasses:
        module_body.append(create_import_from('dataclasses', ['dataclass']))

    # Import T_JSON_DICT from util (relative import within the cdp package)
    # Also import event_class if needed
    util_imports = ['T_JSON_DICT']
    if domain_def.events:
        util_imports.append('event_class')
    if util_imports:
        module_body.append(create_import_from('util', util_imports, level=1)) # from .util import ...

    if needs_deprecated:
        module_body.append(create_import_from( # from deprecated.sphinx import deprecated
            'deprecated.sphinx', ['deprecated'], level=0
        ))
        # Add "# type: ignore[import-untyped]" for deprecated? Difficult with AST.
        # Best handled by adding it during write or post-processing if needed.

    # Relative imports for domain dependencies: from . import other_domain
    for dep_domain_name in sorted(list(dependencies)):
         dep_module_name = snake_case(dep_domain_name)
         module_body.append(create_import_from_relative(dep_module_name, level=1))

    # Add a blank line after imports for style
    module_body.append(ast.Expr(value=ast.Constant(value=None))) # Represents a blank line visually


    # --- Type Definitions ---
    type_nodes: typing.List[ast.stmt] = []
    # Sort types: Enums, Aliases, then Classes for readability
    #sorted_types = sorted(domain_def.types.values(), key=lambda t: (
    #    0 if t.enum_values and t.type != CdpType.OBJECT else (1 if t.type != CdpType.OBJECT else 2),
    #    t.id
    #))
    #sorted_types = sorted(domain_def.types.values(), key=lambda t: (
    #    0 if t.type == CdpType.OBJECT else (1 if t.enum_values else 2), # 0: Classes, 1: Enums, 2: Aliases
    #    t.id # Secondary sort by name
    #))
    # Define a helper function for sorting (can be placed before the loop or inside)
    def get_type_sort_key(type_def: TypeDefinition):
        """Determines the sort order priority for type definitions."""
        if type_def.type == CdpType.OBJECT:
            return (0, type_def.id) # Classes first
        elif type_def.enum_values:
            return (1, type_def.id) # Enums second
        # Check for simple, primitive-like aliases (not arrays)
        elif type_def.type in [CdpType.STRING, CdpType.NUMBER, CdpType.INTEGER, CdpType.BOOLEAN, CdpType.ANY] and not type_def.items:
            # Prioritize aliases that are just simple integers, strings etc.
            # StringIndex = int should fall here.
            return (2, type_def.id)
        else:
            # Array aliases (like ArrayOfStrings = List[StringIndex]) or others last
            return (3, type_def.id)

    # Use the new key function for sorting
    sorted_types = sorted(domain_def.types.values(), key=get_type_sort_key) #

    for type_def in sorted_types:
        if type_def.enum_values and type_def.type != CdpType.OBJECT : # Enum
            type_nodes.append(generate_enum_ast(type_def))
        elif type_def.type == CdpType.OBJECT: # Dataclass OR Dict Subclass
            # generate_dataclass_ast now returns a list (usually with one item)
            type_nodes.extend(generate_dataclass_ast(type_def, current_domain_name)) # Use extend
        else: # Primitive, Any, Arrays -> Generate simple type alias/class
             type_nodes.extend(generate_type_alias_ast(type_def, current_domain_name)) # Use extend


    # --- Command Definitions ---
    command_nodes: typing.List[ast.FunctionDef] = []
    for cmd_def in sorted(domain_def.commands.values(), key=lambda c: c.name):
        command_nodes.append(generate_command_ast(cmd_def, current_domain_name))

    # --- Event Definitions ---
    event_nodes: typing.List[ast.ClassDef] = []
    for event_def in sorted(domain_def.events.values(), key=lambda e: e.name):
        event_nodes.append(generate_event_ast(event_def, current_domain_name))

    # Combine all generated nodes, separated by newlines implicitly by astor
    module_body.extend(type_nodes)
    module_body.extend(command_nodes)
    module_body.extend(event_nodes)

    # Create the final module AST
    module_ast = ast.Module(body=module_body, type_ignores=[])
    ast.fix_missing_locations(module_ast) # Recommended practice
    return module_ast

def generate_init_ast(all_domains: typing.List[DomainDefinition]) -> ast.Module:
    """Generates the __init__.py AST for the base cdp package."""
    body: List[ast.stmt] = []

    # Add future import just in case? Not strictly necessary for simple imports.
    # body.append(create_import_from('__future__', ['annotations']))

    # Add header/docstring? Let generate_all handle header comment.
    body.extend(create_docstring_node("Generated CDP Base Modules"))

    # from . import domain1, domain2, ...
    domain_modules = sorted([snake_case(d.name) for d in all_domains])
    if domain_modules: # Only add import if there are domain modules
        # Generate: from . import domain_one, domain_two ...
        body.extend(create_import_from_relative(mod, level=1) for mod in domain_modules)

    # Optionally add __all__ = [domain_module_names]
    if domain_modules:
        body.append(ast.Assign(
            targets=[ast.Name(id='__all__', ctx=ast.Store())],
            value=ast.List(elts=[ast.Constant(value=mod) for mod in domain_modules], ctx=ast.Load())
        ))

    return ast.Module(body=body, type_ignores=[])

# --- AST Generation Functions for API Wrapper Modules ---

def generate_api_wrapper_method_ast(
    command_def: CommandDefinition,
    domain_module_alias: str, # e.g., _page_module
    api_domain_name: str, # The domain name for this API class (e.g., 'Page')
    # Receive the alias
    primary_domain_module_alias: str
) -> ast.FunctionDef:
    """Generates AST for an API wrapper method for a command."""
    py_name = snake_case(command_def.name)

    # --- Parameters ---
    params = command_def.parameters
    sorted_params = sorted(params, key=lambda p: p.is_optional)
    args_list = [ast.arg(arg='self')] # Wrapper methods are instance methods
    param_docs = []
    param_pass_args = [] # For calling the original generator

    for param in sorted_params:
        param_py_name = snake_case(param.name)
        # Build annotation using API context AND pass the alias
        annotation = build_annotation_ast(
            param.type_ref, param.items, param.is_optional,
            api_domain_name, # Current API domain being generated
            context='api', # Use API context
            primary_domain_module_alias=primary_domain_module_alias # Pass alias!
        )
        args_list.append(ast.arg(
            arg=param_py_name,
            annotation=annotation,
            default=ast.Constant(value=None) if param.is_optional else None
        ))
        param_pass_args.append(ast.keyword( # Pass as keyword arg to original func
            arg=param_py_name,
            value=ast.Name(id=param_py_name, ctx=ast.Load())
        ))
        # Build param docstring lines (same as original command)
        doc_line = f":param {param_py_name}:"
        if param.is_deprecated: doc_line += " **(DEPRECATED)**"
        if param.is_experimental: doc_line += " **(EXPERIMENTAL)**"
        if param.is_optional: doc_line += " *(Optional)*"
        if param.description: doc_line += f" {param.description.replace(chr(10), ' ')}"
        param_docs.append(doc_line)

    # Add timeout parameter (doesn't need alias)
    args_list.append(ast.arg(
        arg='_response_timeout',
        annotation=ast.Subscript( # typing.Optional[float]
            value=ast.Attribute(value=ast.Name(id='typing', ctx=ast.Load()), attr='Optional', ctx=ast.Load()),
            slice=ast.Name(id='float', ctx=ast.Load()),
            ctx=ast.Load()
        ),
        default=ast.Constant(value=None)
    ))
    param_docs.append(":param _response_timeout: Optional timeout in seconds for the command.")

    # Extract defaults
    defaults = [a.default for a in args_list[1:] if a.default is not None]

    # --- Return Type ---
    # Rebuild the return annotation from the command definition using context='api' AND the alias
    returns = command_def.returns
    return_doc = None # Docstring part for returns

    if not returns:
        return_annotation = ast.Name(id='None', ctx=ast.Load())
        return_doc = None
    elif len(returns) == 1:
        ret_field = returns[0]
        # Build annotation using API context and alias
        return_annotation = build_annotation_ast(
            ret_field.type_ref, ret_field.items, ret_field.is_optional,
            api_domain_name, context='api', is_return_annotation=True,
            primary_domain_module_alias=primary_domain_module_alias # Pass alias!
        )
        # Build return doc
        ret_doc_desc = ret_field.description or ''
        if ret_field.is_optional: ret_doc_desc = f"*(Optional)* {ret_doc_desc}"
        return_doc = f":returns: {ret_doc_desc.replace(chr(10), ' ')}"
    else: # Multiple returns -> Tuple
        tuple_elts = []
        ret_docs_list = []
        for i, ret_field in enumerate(returns):
            # Build annotation using API context and alias
            tuple_elts.append(build_annotation_ast(
                ret_field.type_ref, ret_field.items, ret_field.is_optional,
                api_domain_name, context='api', is_return_annotation=True,
                primary_domain_module_alias=primary_domain_module_alias # Pass alias!
            ))
            # Build return doc part
            r_doc = ret_field.description or ''
            if ret_field.is_optional: r_doc = f"*(Optional)* {r_doc}"
            ret_docs_list.append(f"    {i+1}. **{ret_field.name}** - {r_doc.replace(chr(10), ' ')}")


        return_annotation = ast.Subscript(
            value=ast.Attribute(value=ast.Name(id='typing', ctx=ast.Load()), attr='Tuple', ctx=ast.Load()),
            slice=ast.Tuple(elts=tuple_elts, ctx=ast.Load()),
            ctx=ast.Load()
        )
        return_doc = ":returns: A tuple with the following items:\n\n" + "\n".join(ret_docs_list)


    # --- Function Body ---
    body: typing.List[ast.stmt] = []

    # Docstring
    docstring_parts = []
    if command_def.description: docstring_parts.append(command_def.description)
    docstring_parts.append("\nNOTE: This is a blocking wrapper method that executes the underlying generator command using the client.")
    if command_def.redirect: docstring_parts.append(f"Redirects to command '{command_def.redirect}'.")
    if command_def.is_deprecated: docstring_parts.append(f".. deprecated:: {current_protocol_version or 'Unknown'}")
    if command_def.is_experimental: docstring_parts.append("**EXPERIMENTAL**")
    if param_docs: docstring_parts.extend(["", ":param ...:"] if docstring_parts else [":param ...:"])
    if param_docs: docstring_parts.extend(param_docs)
    if return_doc: docstring_parts.extend(["", return_doc])
    full_docstring = "\n\n".join(docstring_parts).replace("\n\n\n", "\n\n")
    body.extend(create_docstring_node(full_docstring))

    # 1. Call the original generator function from the imported base module:
    #    gen = _domain_module.command_name(param1=param1, ...)
    generator_call = ast.Call(
        func=ast.Attribute(
            value=ast.Name(id=domain_module_alias, ctx=ast.Load()),
            attr=py_name, # The original generator function name
            ctx=ast.Load()
        ),
        args=[],
        keywords=param_pass_args # Pass parameters collected earlier
    )
    assign_gen = ast.Assign(
        targets=[ast.Name(id='gen', ctx=ast.Store())],
        value=generator_call
    )
    body.append(assign_gen)

    # 2. Call client.send:
    #    return self.client.send(gen, timeout=timeout)
    send_call = ast.Call(
        func=ast.Attribute(
            value=ast.Attribute(value=ast.Name(id='self', ctx=ast.Load()), attr='client', ctx=ast.Load()),
            attr='send',
            ctx=ast.Load()
        ),
        args=[ast.Name(id='gen', ctx=ast.Load())],
        keywords=[ast.keyword(arg='_response_timeout', value=ast.Name(id='_response_timeout', ctx=ast.Load()))]
    )
    body.append(ast.Return(value=send_call))

    # --- Decorators ---
    decorators = []
    # Add @deprecated if the original command was deprecated
    if command_def.is_deprecated:
        decorators.append(ast.Call(
            func=ast.Name(id='deprecated', ctx=ast.Load()),
            args=[],
            keywords=[ast.keyword(arg='version', value=ast.Constant(value=current_protocol_version or 'Unknown'))]
        ))


    # --- Final FunctionDef ---
    func_def = ast.FunctionDef(
        name=py_name,
        args=ast.arguments(
            posonlyargs=[],
            args=args_list,
            kwonlyargs=[],
            kw_defaults=[],
            defaults=defaults
        ),
        body=body,
        decorator_list=decorators,
        returns=return_annotation # Use the correctly generated API-context annotation
    )
    ast.fix_missing_locations(func_def)
    return func_def

def generate_domain_api_ast(domain_def: DomainDefinition, protocol: ProtocolDefinition) -> ast.Module:
    """Generates the AST for a domain's API wrapper class module (e.g., api/page.py)."""
    module_body: typing.List[ast.stmt] = []
    domain_py_name = snake_case(domain_def.name)
    api_class_name = f"{pascal_case(domain_py_name)}API"
    # Alias for the imported base domain module (e.g., '_page_module')
    domain_module_alias = f"_{domain_py_name}_module"
    current_api_domain_name = domain_def.name # The domain this API is for

    # --- Future Imports ---
    module_body.append(create_import_from('__future__', ['annotations']))

    # --- Module Docstring ---
    module_doc = f"API wrapper for the {domain_def.name} domain."
    module_body.extend(create_docstring_node(module_doc))

    # --- Imports ---
    module_body.append(create_import('typing'))
    # Import the client protocol from base util (level 2 relative import)
    module_body.append(create_import_from('util', ['CDPClient'], level=2)) # from ..util import CDPClient

    # Import the base domain module being wrapped (level 2 relative import)
    # from .. import page as _page_module
    module_body.append(create_import_from_relative(
        domain_py_name, level=2, alias=domain_module_alias
    ))

    # Import *other* domains referenced in types (needed for annotations)
    # Collect dependencies based on command parameters/returns used in this API
    dependencies: Set[str] = set()
    refs: Set[Optional[str]] = set()
    for cmd_def in domain_def.commands.values():
        for item in cmd_def.parameters + cmd_def.returns:
            refs.add(item.type_ref)
            if item.items: refs.add(item.items.type_ref)

    # Add referenced domains to dependencies, excluding self and invalid refs
    for ref in refs:
        if ref and '.' in ref:
            ref_domain_name, _ = ref.split('.', 1)
            # Add dependency if it's a valid domain (even if it's the current one,
            # as API needs to reference base types like page.Frame)
            if ref_domain_name in protocol.domains:
                 dependencies.add(ref_domain_name)

    # Import necessary *base* modules for annotations (level 2 relative)
    # from .. import dom # (Need the module name for attribute access in build_annotation_ast)
    for dep_domain_name in sorted(list(dependencies)):
         # Skip importing self with an alias, we already did that.
         if dep_domain_name == current_api_domain_name:
             continue
         dep_module_name = snake_case(dep_domain_name)
         module_body.append(create_import_from_relative(dep_module_name, level=2)) # from .. import other_domain


    needs_deprecated = domain_def.is_deprecated # Module itself can be deprecated

    # Check if deprecated needed for types, commands, events
    if not needs_deprecated:
        needs_deprecated = (
            any(t.is_deprecated for t in domain_def.types.values()) or
            any(c.is_deprecated for c in domain_def.commands.values()) or
            any(e.is_deprecated for e in domain_def.events.values())
        )

    if needs_deprecated:
        module_body.append(create_import_from( # from deprecated.sphinx import deprecated
             'deprecated.sphinx', ['deprecated'], level=0
        ))

    # Add a blank line after imports
    module_body.append(ast.Expr(value=ast.Constant(value=None)))


    # --- Class Definition ---
    class_body = []

    # Class Docstring
    class_doc = f"Provides an API wrapper for the '{domain_def.name}' domain commands."
    if domain_def.is_deprecated:
        class_doc += f"\n\n.. deprecated:: {current_protocol_version or 'Unknown'}"
    if domain_def.is_experimental:
        class_doc += "\n\n**EXPERIMENTAL**"
    if domain_def.description:
        class_doc += f"\n\nDomain Description:\n{domain_def.description}"
    class_body.extend(create_docstring_node(class_doc))

    # __init__ method
    init_method = ast.FunctionDef(
        name='__init__',
        args=ast.arguments(
            posonlyargs=[],
            args=[
                ast.arg(arg='self'),
                # Use the protocol for better type hinting (imported via level=2)
                ast.arg(arg='client', annotation=ast.Name(id='CDPClient', ctx=ast.Load()))
            ],
            kwonlyargs=[], kw_defaults=[], defaults=[]
        ),
        body=[
            # Use AnnAssign for typed attribute: self.client: CDPClient = client
            ast.AnnAssign(
                 target=ast.Attribute(value=ast.Name(id='self', ctx=ast.Load()), attr='client', ctx=ast.Store()),
                 annotation=ast.Name(id='CDPClient', ctx=ast.Load()),
                 value=ast.Name(id='client', ctx=ast.Load()),
                 simple=0 # Target is Attribute, not simple Name
            )
        ],
        decorator_list=[],
        returns=ast.Constant(value=None) # __init__ returns None
    )
    class_body.append(init_method)

    # Wrapper Methods
    for cmd_def in sorted(domain_def.commands.values(), key=lambda c: c.name):
        # Pass the alias down to the method generator
        class_body.append(generate_api_wrapper_method_ast(
            cmd_def,
            domain_module_alias, # The actual alias string (e.g., '_page_module')
            current_api_domain_name,
            primary_domain_module_alias=domain_module_alias # Pass the alias here!
            ))

    # Final ClassDef
    api_class_decorators = []
    if domain_def.is_deprecated:
         api_class_decorators.append(ast.Call(
            func=ast.Name(id='deprecated', ctx=ast.Load()),
            args=[],
            keywords=[ast.keyword(arg='version', value=ast.Constant(value=current_protocol_version or 'Unknown'))]
        ))

    api_class = ast.ClassDef(
        name=api_class_name,
        bases=[],
        keywords=[],
        body=class_body,
        decorator_list=api_class_decorators
    )
    module_body.append(api_class)

    # Final Module
    module_ast = ast.Module(body=module_body, type_ignores=[])
    ast.fix_missing_locations(module_ast)
    return module_ast

def generate_client_class_ast(
    all_domain_defs: List[DomainDefinition],
    client_protocol_name: str = "CDPClient", # Name of the protocol to type hint
    client_protocol_module: str = "util" # Module where the protocol is defined
) -> ast.Module:
    """
    Generates the AST for the main client class that aggregates domain APIs.

    Args:
        all_domain_defs: List of all parsed domain definitions.
        client_protocol_name: The name of the client protocol class/type.
        client_protocol_module: The module path (relative level 1) to import the protocol from.

    Returns:
        An ast.Module representing client.py.
    """
    module_body: List[ast.stmt] = []
    class_name = "DevTools" # Or make this configurable?

    # --- Future Imports ---
    module_body.append(create_import_from('__future__', ['annotations']))

    # --- Imports ---
    # Import the client protocol
    module_body.append(create_import_from(client_protocol_module, [client_protocol_name], level=1))

    # Import all necessary DomainAPI classes from .api
    api_imports = []
    api_class_names = []
    for domain_def in sorted(all_domain_defs, key=lambda d: d.name):
        # Only import if the API module was likely generated (i.e., has commands)
        if domain_def.commands:
            module_name = snake_case(domain_def.name)
            api_class = f"{pascal_case(module_name)}API"
            api_imports.append(create_import_from(f"api.{module_name}", [api_class], level=1))
            api_class_names.append((domain_def.name, api_class)) # Store (domain_name, APIClassName)

    module_body.extend(api_imports)

    # Blank line after imports
    module_body.append(ast.Expr(value=ast.Constant(value=None)))

    # --- Class Definition ---
    class_body: List[ast.stmt] = []

    # Class Docstring
    class_doc = f"""\
Convenience wrapper class that aggregates CDP domain API methods.

Provides access to domain-specific APIs (e.g., `page`, `network`) as attributes.
Initialize this class with an object conforming to the `{client_protocol_name}` protocol.
"""
    class_body.extend(create_docstring_node(class_doc))

    # --- __init__ method ---
    init_body: List[ast.stmt] = []

    # Store the client instance (e.g., self.client: CDPClient = client)
    # Use AnnAssign for the typed attribute
    client_param_annotation = ast.Name(id=client_protocol_name, ctx=ast.Load())
    init_body.append(ast.AnnAssign(
        target=ast.Attribute(value=ast.Name(id='self', ctx=ast.Load()), attr='client', ctx=ast.Store()),
        annotation=client_param_annotation,
        value=ast.Name(id='client', ctx=ast.Load()),
        simple=0 # Target is Attribute
    ))

    # Initialize DomainAPI attributes
    for domain_name, api_class_name_str in api_class_names:
        domain_attr_name = snake_case(domain_name)
        # self.domain_name = DomainAPI(self.client)
        assign_stmt = ast.Assign(
            targets=[ast.Attribute(
                value=ast.Name(id='self', ctx=ast.Load()),
                attr=domain_attr_name,
                ctx=ast.Store()
            )],
            value=ast.Call(
                func=ast.Name(id=api_class_name_str, ctx=ast.Load()),
                args=[ast.Attribute( # Pass self.client
                    value=ast.Name(id='self', ctx=ast.Load()),
                    attr='client',
                    ctx=ast.Load()
                )],
                keywords=[]
            )
        )
        init_body.append(assign_stmt)

    # If no APIs were added, add pass
    if not api_class_names:
        init_body.append(ast.Pass())


    init_method = ast.FunctionDef(
        name='__init__',
        args=ast.arguments(
            posonlyargs=[],
            args=[
                ast.arg(arg='self'),
                ast.arg(arg='client', annotation=client_param_annotation)
            ],
            kwonlyargs=[], kw_defaults=[], defaults=[]
        ),
        body=init_body,
        decorator_list=[],
        returns=ast.Constant(value=None) # __init__ returns None
    )
    class_body.append(init_method)

    # --- Optional: Delegate send method? ---
    # If you want this class to *also* conform to CDPClient by delegating
    # add this method:
    # def send(self, cmd_generator, timeout=None):
    #     return self.client.send(cmd_generator, timeout=timeout)
    # send_method = ast.FunctionDef(...) # Define this AST if needed

    # Final ClassDef
    client_class = ast.ClassDef(
        name=class_name,
        bases=[], # Not inheriting from protocol, it holds a client instance
        keywords=[],
        body=class_body,
        decorator_list=[]
    )
    module_body.append(client_class)

    # Final Module
    module_ast = ast.Module(body=module_body, type_ignores=[])
    ast.fix_missing_locations(module_ast)
    return module_ast

# --- Main Generation Logic ---

def generate_all(protocol: ProtocolDefinition, output_path: Path):
    """Parses protocols, generates Python modules using AST, and writes them."""
    global current_protocol_version
    current_protocol_version = f"{protocol.version_major}.{protocol.version_minor}"
    logger.info(f"Generating for protocol version: {current_protocol_version}")

    # --- Configuration (Placeholder - Adapt if using config file) ---
    # These would ideally come from a config file or arguments
    client_protocol_name = "CDPClient"
    client_protocol_module = "util" # Assuming util.py is generated
    generated_package_name = output_path.name # e.g., "cdp_ast_generated"

    # --- Output Path Setup ---
    base_output_path = output_path # e.g., ./cdp_generated
    if not base_output_path.exists():
        logger.info(f"Creating base output directory: {base_output_path}")
        base_output_path.mkdir(parents=True)
    elif not base_output_path.is_dir():
        logger.error(f"Output path {base_output_path} exists but is not a directory.")
        return

    api_output_path = base_output_path / 'api' # e.g., ./cdp_generated/api/
    if not api_output_path.exists():
        logger.info(f"Creating API wrapper directory: {api_output_path}")
        api_output_path.mkdir()
    elif not api_output_path.is_dir():
        logger.error(f"API output path {api_output_path} exists but is not a directory.")
        return

    all_domain_defs = list(protocol.domains.values())
    all_domain_defs.sort(key=operator.attrgetter('name')) # Sort domains alphabetically

    # --- Generate Base Domain Modules ---
    logger.info("--- Generating Base Domain Modules ---")
    for domain_def in all_domain_defs:
        module_name = snake_case(domain_def.name)
        module_path = base_output_path / f"{module_name}.py"
        logger.info(f"Generating base module: {domain_def.name} -> {module_path}")
        try:
            module_ast = generate_domain_module_ast(domain_def, protocol)
            header_comment = "\n".join(f"# {line}" for line in SHARED_HEADER.splitlines()) + "\n\n"
            module_code = astor.to_source(module_ast)
            full_code = header_comment + module_code
            module_path.write_text(full_code, encoding='utf-8')
        except Exception as e:
            logger.error(f"Error generating base module {module_name}: {e}", exc_info=True)

    # --- Generate Utilities ---
    logger.info("--- Generating Utilities ---")
    util_dest_path = base_output_path / 'util.py'
    logger.info(f"Generating utilities -> {util_dest_path}")
    try:
        util_header_comment = "\n".join(f"# {line}" for line in SHARED_HEADER.splitlines()) + "\n\n"
        util_code = util_header_comment + UTIL_PY_CONTENT
        util_dest_path.write_text(util_code, encoding='utf-8')
    except Exception as e:
        logger.error(f"Error generating utility file: {e}", exc_info=True)


    # --- Generate API Wrapper Modules ---
    logger.info("--- Generating API Wrapper Modules ---")
    api_modules_generated = []
    for domain_def in all_domain_defs:
        if not domain_def.commands:
            logger.debug(f"Skipping API wrapper for domain '{domain_def.name}' (no commands).")
            continue

        module_name = snake_case(domain_def.name)
        api_module_path = api_output_path / f"{module_name}.py"
        logger.info(f"Generating API wrapper module: {domain_def.name} -> {api_module_path}")
        try:
            api_module_ast = generate_domain_api_ast(domain_def, protocol)
            header_comment = "\n".join(f"# {line}" for line in SHARED_HEADER.splitlines()) + "\n\n"
            api_module_code = astor.to_source(api_module_ast)
            full_api_code = header_comment + api_module_code
            api_module_path.write_text(full_api_code, encoding='utf-8')
            api_modules_generated.append(module_name) # Track successfully generated modules
        except Exception as e:
            logger.error(f"Error generating API module {module_name}: {e}", exc_info=True)

    # --- Generate API __init__.py ---
    logger.info("--- Generating API Package Init ---")
    api_init_path = api_output_path / "__init__.py"
    logger.info(f"Generating {api_init_path}")
    try:
        api_init_body: List[ast.stmt] = []
        api_init_body.extend(create_docstring_node("Generated CDP Domain API Wrappers")) # Module docstring
        api_all_list_elements = [] # AST nodes for __all__ list

        for module_name in sorted(api_modules_generated):
            class_name = f"{pascal_case(module_name)}API"
            api_init_body.append(create_import_from(f"{module_name}", [class_name], level=1))
            api_all_list_elements.append(ast.Constant(value=class_name))

        if api_all_list_elements:
            api_init_body.append(ast.Expr(value=ast.Constant(value=None))) # Blank line
            api_init_body.append(ast.Assign(
                targets=[ast.Name(id='__all__', ctx=ast.Store())],
                value=ast.List(elts=api_all_list_elements, ctx=ast.Load())
            ))

        api_init_ast = ast.Module(body=api_init_body, type_ignores=[])
        ast.fix_missing_locations(api_init_ast)

        header_comment = "\n".join(f"# {line}" for line in SHARED_HEADER.splitlines()) + "\n\n"
        api_init_code = astor.to_source(api_init_ast)
        full_api_init_code = header_comment + api_init_code
        api_init_path.write_text(full_api_init_code, encoding='utf-8')
    except Exception as e:
        logger.error(f"Error generating api/__init__.py: {e}", exc_info=True)

    # --- Generate Client Class ---
    logger.info("--- Generating Aggregated Client Class ---")
    client_class_path = output_path / "client.py"
    client_class_generated = False # Flag to track success
    logger.info(f"Generating client class -> {client_class_path}")
    try:
        client_class_ast = generate_client_class_ast(
            all_domain_defs,
            client_protocol_name,
            client_protocol_module # Pass module where CDPClient is defined
        )
        header_comment = "\n".join(f"# {line}" for line in SHARED_HEADER.splitlines()) + "\n\n"
        client_class_code = astor.to_source(client_class_ast)
        full_client_class_code = header_comment + client_class_code
        client_class_path.write_text(full_client_class_code, encoding='utf-8')
        client_class_generated = True
    except Exception as e:
        logger.error(f"Error generating client class module: {e}", exc_info=True)


    # --- Generate Top-Level __init__.py ---
    logger.info("--- Generating Top-Level Package Init ---")
    init_path = base_output_path / "__init__.py"
    logger.info(f"Generating top-level {init_path}")
    try:
        # Create AST for top-level __init__
        top_init_body: List[ast.stmt] = []
        top_init_body.extend(create_docstring_node(f"Generated CDP Client Package: {generated_package_name}"))
        top_init_body.append(ast.Expr(value=ast.Constant(value=None))) # Blank line

        # Import base domain modules (from . import domain)
        domain_module_names = sorted([snake_case(d.name) for d in all_domain_defs])
        if domain_module_names:
             top_init_body.extend(create_import_from_relative(mod, level=1) for mod in domain_module_names)
             top_init_body.append(ast.Expr(value=ast.Constant(value=None))) # Blank line

        # Import API subpackage (import .api) - Users access via client obj or cdp.api.PageAPI
        top_init_body.append(create_import_from_relative("api", level=1))
        top_init_body.append(ast.Expr(value=ast.Constant(value=None))) # Blank line

        # Import Util stuff? Maybe T_JSON_DICT and CDPClient?
        # Decide what to expose from util. CDPClient might be useful.
        top_init_body.append(create_import_from("util", ["CDPClient", "T_JSON_DICT"], level=1))
        top_init_body.append(ast.Expr(value=ast.Constant(value=None))) # Blank line


        # Import the main client class
        client_class_name = "DevTools" # Should match generate_client_class_ast
        if client_class_generated:
            top_init_body.append(create_import_from("client", [client_class_name], level=1))
            top_init_body.append(ast.Expr(value=ast.Constant(value=None))) # Blank line


        # Define __all__
        top_all_elements = [ast.Constant(value=mod) for mod in domain_module_names]
        top_all_elements.append(ast.Constant(value="api")) # Export the api package
        top_all_elements.extend([ast.Constant(value="CDPClient"), ast.Constant(value="T_JSON_DICT")]) # Export util types
        if client_class_generated:
            top_all_elements.append(ast.Constant(value=client_class_name))

        if top_all_elements:
             # Sort __all__ alphabetically for consistency
             top_all_elements.sort(key=lambda x: x.value)
             top_init_body.append(ast.Assign(
                 targets=[ast.Name(id='__all__', ctx=ast.Store())],
                 value=ast.List(elts=top_all_elements, ctx=ast.Load())
             ))

        # Final Module AST for top-level __init__
        init_ast = ast.Module(body=top_init_body, type_ignores=[])
        ast.fix_missing_locations(init_ast)

        # Write top-level __init__.py
        header_comment = "\n".join(f"# {line}" for line in SHARED_HEADER.splitlines()) + "\n\n"
        init_code = astor.to_source(init_ast)
        full_init_code = header_comment + init_code
        init_path.write_text(full_init_code, encoding='utf-8')
    except Exception as e:
        logger.error(f"Error generating top-level __init__.py: {e}", exc_info=True)


    # --- Generate READMEs ---
    logger.info("--- Generating README Files ---")
    try:
        # Generate base README.md
        (base_output_path / 'README.md').write_text(GENERATED_PACKAGE_NOTICE, encoding='utf-8')
        # Generate py.typed
        (base_output_path / 'py.typed').touch()
        # Generate api/README.md
        (api_output_path / 'README.md').write_text(
            "## Generated CDP API Wrappers\n\n"
            "These classes provide an object-oriented, blocking wrapper around the base CDP commands.\n\n"
            f"Instantiate them individually with a client object conforming to the `CDPClient` protocol (defined in `../util.py`), or use the aggregated `{client_class_name}` from the main package.\n\n"
            "Example (Individual API):\n"
            "```python\n"
            f"from {generated_package_name}.api import PageAPI\n"
            f"from {generated_package_name} import CDPClient\n"
            "from my_cdp_client import MyClient # Your implementation of CDPClient\n\n"
            "client: CDPClient = MyClient(...)\n"
            "page_api = PageAPI(client)\n\n"
            "result = page_api.navigate(url='https://example.com')\n"
            "print(f'Navigation frame ID: {result}') # Example output\n"
            "```\n\n"
             "Example (Aggregated Client):\n"
            "```python\n"
            f"from {generated_package_name} import {client_class_name}, CDPClient\n"
            "from my_cdp_client import MyClient # Your implementation of CDPClient\n\n"
            "client_impl: CDPClient = MyClient(...)\n"
            f"cdp = {client_class_name}(client_impl)\n\n"
            "frame_id = cdp.page.navigate(url='https://example.com')\n"
            "cookies = cdp.network.get_all_cookies()\n"
            "print(f'Frame: {frame_id}, Cookies: {len(cookies)}')\n"
            "```\n",
            encoding='utf-8'
        )
    except Exception as e:
        logger.error(f"Error generating README files: {e}", exc_info=True)

    logger.info("--- Generation process completed. ---")

